<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cmake</title>
    <url>/2022/07/28/Cmake/</url>
    <content><![CDATA[<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><p>多人跨平台(多个语言)编译一个项目时，用于输出一个可执行文件</p>
<p>所有操作通过CMakeLists.txt完成</p>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p><a href="https://blog.csdn.net/zhengnianli/article/details/116213854?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-116213854-blog-122966681.pc_relevant_multi_platform_whitelistv1_exp2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-116213854-blog-122966681.pc_relevant_multi_platform_whitelistv1_exp2&amp;utm_relevant_index=2">(93条消息) 实用 | 使用Cmake快速生成visual studio工程_嵌入式大杂烩的博客-CSDN博客_cmake vs</a></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>写一个HELLO.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>写一个CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br></pre></td></tr></table></figure>
<p>使用cmake进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .</span><br><span class="line"><span class="comment">#表示当前文件夹下的cmakelist</span></span><br><span class="line"><span class="comment">#..则是上一文件夹下</span></span><br></pre></td></tr></table></figure>
<p>此时生成makefile或者.sln等工程文件(目标平台下的原生工程文件)</p>
<h2 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h2><p>CMAKE_MINIMUM_REQUIRED(VERSION 版本)<br>用于指定最低cmake版本</p>
<p>PROJECT (工程名字 支持语言 …)<br>默认支持所有语言</p>
<p>此处有两个隐式变量<br>\<projectname\>_BINARY_DIR<br>\<projectname\>_SOURCE_DIR</p>
<p>SET(变量名 常量 …)<br>用来定义变量<br>或者file(GLOB 变量名 “文件夹/*.h”)<br>使用通配符包含大量文件<br>${变量名}即可引用</p>
<p>MESSAEG<br>用来向终端输出，包括3中类型信息<br>SEND_ERROR产生错误并跳过生产，SATUS输出信息，FATAL_ERROR终止cmake</p>
<p>ADD_EXECUTABLE(生成可执行文件名 依赖文件)<br>用来生成可执行文件</p>
<p>INSTALL(内容 … 安装到的目录)<br>用于安装内容<br>内容可以是路径，以/结尾则是该文件夹下所有内容<br>否则则是该文件夹</p>
<p>ADD_LIBRARY(库名 库类型 源文件)<br>用于生成库(.so)<br>类型SHARED动态STATIC静态</p>
<p>FIND_PACKAGE(库名 是否必须)<br>cmake在计算机寻找库<br>REQUIRED必须</p>
<p>TARGET_LINK_LIBRARIES(执行文件名 PRIVATE 库名)<br>连接库</p>
<p>TARGET_COMPILE_FEATURES(执行文件名 PRIVATE cxx_std_17)<br>打开对c++17的支持</p>
<p>参数间可以空格或者分号来分割<br>指令不区分打小写，建议大写<br>若文件名包括空格则要用””括起文件名以免歧义</p>
<h2 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h2><p>在CMakeLists.txt的文件夹中(即工程文件下)创建一个build<br>进入build文件，此时用 make .. 即可</p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><p>在工程文件下<br>src文件夹放工程源代码<br>doc文件夹放文档<br>添加COPYRIGHT和README<br>添加runhello.sh脚本用于调用hello的二进制文件</p>
<p>注意每个文件夹下(build除外)都与要CMakeLists.txt<br>在工程目录下的CMakeLists.txt要关联文件夹<br>如ADD_SUBDIRECTORY(src bin)即src生成的文件最后放在生成的/build/bin文件夹下<br>在子文件夹下的CMakeLists.txt不需要PROJECT</p>
<h2 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h2><p>vcpkg</p>
]]></content>
  </entry>
  <entry>
    <title>c语言库</title>
    <url>/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%BA%93/</url>
    <content><![CDATA[<h2 id="库：string-h"><a href="#库：string-h" class="headerlink" title="库：string.h"></a>库：string.h</h2><p>函数：char <em> strtok(char </em> str,const char * delim)<br>功能：从str[0]开始往后查找delim，找到后返回delim前的子串，否则返回NULL</p>
<p>函数：char * strchr(const char * str, int c)<br>功能：从str[0]开始往后查找c，找到后返回该位置，否则返回NULL<br>注意：第一次调用strtok必须将C字符串传入<br>            后续调用必须指定NULL为第一个参数,它告诉函数继续对您首先传入的字符串进行标记</p>
<h2 id="库：stdlib-h"><a href="#库：stdlib-h" class="headerlink" title="库：stdlib.h"></a>库：stdlib.h</h2><p>函数：int atoi(const char * str)<br>功能：转换字符串为整数，没有执行有效转换则返回零</p>
<h2 id="库：stdio-h"><a href="#库：stdio-h" class="headerlink" title="库：stdio.h"></a>库：stdio.h</h2><p>函数：int sprintf(char <em> str, const char </em> format, …)<br>功能：向str写入format内容(可插入标签)，…为标签参数，返回写入字符数</p>
<p>函数：FILE*freopen(const*filename,const char *mode,file*strream)<br>功能：重定向文件流<br>注意：没有任何方法可以恢复原来的输出流，在操作系统中，命令行控制台（即键盘或者显示器）被视为一个文件windows为CON，linux为/dev/tty</p>
<h2 id="库：arduino-h"><a href="#库：arduino-h" class="headerlink" title="库：arduino.h"></a>库：arduino.h</h2><p>函数：Serial.flush()<br>功能：arduino1.0之前的版本作用是清空串口缓存,但在1.0之后的版本作用调整为等待串口数据传送完毕</p>
<p>函数：Serial.readBytesUntil(缓冲区,’结束字符‘,最长长度)<br>功能：从串口读取指定长度的字符到缓存数组，函数在读取终止字符时停止函数即终止符不会在缓冲区中</p>
<p>函数：delay(ms)<br>功能：延时</p>
<h2 id="库：BluetoothSerial-h"><a href="#库：BluetoothSerial-h" class="headerlink" title="库：BluetoothSerial.h"></a>库：BluetoothSerial.h</h2><p>函数：SerialBT.begin(“名字”)<br>功能：开启蓝牙，若作为主机则需要true参数</p>
<p>函数：SerialBT.connect(从机名字)<br>功能：蓝牙主机连接从机</p>
<p>函数：SerialBT.register_callback(Bluetooth_Event)<br>功能：设置事件回调函数<br>event == ESP_SPP_OPEN_EVT || event == ESP_SPP_SRV_OPEN_EVT<br>蓝牙连接成功标志<br>else if(event == ESP_SPP_CLOSE_EVT<br>蓝牙断开连接标志<br>else if(event == ESP_SPP_DATA_IND_EVT<br>数据接收标志<br>else if(event == ESP_SPP_WRITE_EVT<br>数据发送标志</p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2022/03/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="c语言组成"><a href="#c语言组成" class="headerlink" title="c语言组成"></a>c语言组成</h1><h2 id="关键字-32个"><a href="#关键字-32个" class="headerlink" title="关键字(32个)"></a>关键字(32个)</h2><p>auto signed unsigned int float double char long short<br>if else switch case default for do while continue break return goto<br>tyedef const static extern<br>struct union enum register<br>volatile sizeof</p>
<h2 id="运算符特殊功能符号"><a href="#运算符特殊功能符号" class="headerlink" title="运算符特殊功能符号"></a>运算符特殊功能符号</h2><p>￥ $ &amp; ^ * ()</p>
<h2 id="值-计算机直接识别直接存储"><a href="#值-计算机直接识别直接存储" class="headerlink" title="值(计算机直接识别直接存储)"></a>值(计算机直接识别直接存储)</h2><p>整型:十进制;八进制0为前置;十六进制0x前缀;无符号u后缀<br>浮点:lf后缀为double，f为float（不加默认double）<br>字符:   ‘   ’   括起来一个字符   \加东西也是一个字符<br>字符串字面量:   “   ”   括起来的</p>
<h2 id="标识符-程序员定义"><a href="#标识符-程序员定义" class="headerlink" title="标识符(程序员定义)"></a>标识符(程序员定义)</h2><p>如include，库，函数，变量，宏，结构，联合体名等等<br>命名规则：<br>1、只有数字，字母，下划线组成<br>2、不可以数字开头<br>3、不可以和关键字冲突<br>4、大小写敏感<br>最好顾名思义且好看<br>i,j,k循环变量<br>r,ret函数返回值<br>CreatWindow（windows习惯）或creat_window（linux习惯）</p>
<h2 id="vs注意事项"><a href="#vs注意事项" class="headerlink" title="vs注意事项"></a>vs注意事项</h2><h1 id="define-CRT-SECURE-NO-WARNINGS"><a href="#define-CRT-SECURE-NO-WARNINGS" class="headerlink" title="define _CRT_SECURE_NO_WARNINGS"></a>define _CRT_SECURE_NO_WARNINGS</h1><p>//vs要关安全开发周期检查，不然要加宏<br>//关周期：项目，属性，c/c++，sdl检查关掉</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="单位与大小"><a href="#单位与大小" class="headerlink" title="单位与大小"></a>单位与大小</h2><p>对于计算机所有数据都是2进制<br>内存的最小管理单位byte字节，单位TB,GB,MB,KB,B；<br>内存的最小单位bit比特，晶体管，单位b<br>每秒bit比特率，单位bps</p>
<h2 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>int（16位2字节32位4字节） char float double short long<br>char的本质是int，所有类型都要转成整数来储存<br>double:正负占1位，指数占11位，科学计数法占52位<br>char是多字节字符集，wchar_t宽字节字符集、unicode字符集<br>值在常量区（只读），变量在变量区</p>
<p>auto关键字，表示局部变量，如：auto int i;则i为一个局部变量，对于局部变量默认都是auto<br>对于上诉例子省略类型只写auto，则默认为int类型</p>
<h2 id="位域-段"><a href="#位域-段" class="headerlink" title="位域(段)"></a>位域(段)</h2><p>常用于结构体中<br>：设置对应占用位的数量<br>位域不可以跨字节，同一字节可以有多个位域<br>位域不超过8<br>可以设置无名空域，即跳过不使用<br>没使用的位填0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> a0;<span class="comment">//默认占用8bit</span></span><br><span class="line">	<span class="type">char</span> a1:<span class="number">1</span>;<span class="comment">//占用1bit</span></span><br><span class="line">	<span class="type">char</span> a2:<span class="number">4</span>;<span class="comment">//占用4bit</span></span><br><span class="line">    <span class="comment">//此处空开3bit填充0不用</span></span><br><span class="line">	<span class="type">char</span> a3:<span class="number">8</span>;<span class="comment">//占用8bit</span></span><br><span class="line">	<span class="type">char</span> :<span class="number">2</span><span class="comment">//无名位域占2位</span></span><br><span class="line">    <span class="comment">//此处空开6bit填充0不用</span></span><br><span class="line">&#125;;<span class="comment">//共4个char即32bit</span></span><br></pre></td></tr></table></figure>
<h2 id="命名问题"><a href="#命名问题" class="headerlink" title="命名问题"></a>命名问题</h2><p>以字母或下划线开始，不能以数字开始，不允许使用关键字<br>即标识符的命名只能由字母（a～z，A～Z）、数字（0～9）、下划线（_）组成，并且标识符的第一个字符必须是字母或下划线，不能以数字开头<br>标识符(变量)：声明,定义,使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//声明并定义一个变量 类型为int 变量名为n，占据了一个可写的内存</span></span><br><span class="line">    n = <span class="number">10</span>;<span class="comment">//使用变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回一个常量，占据一个只读的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="符号与范围"><a href="#符号与范围" class="headerlink" title="符号与范围"></a>符号与范围</h2><p>存储模式：有无符号，不影响类型<br>所有类型默认有符号，加上unsign表示无符号<br>数的范围：无符号0 ~ 2^n-1,有符号-2^(n-1) ~ 2^(n-1)</p>
<h2 id="源码，反码，补码"><a href="#源码，反码，补码" class="headerlink" title="源码，反码，补码"></a>源码，反码，补码</h2><p>计算机内全部储存都是补码，补码=反码+1,反码=按位取反<br>补码原理：1111+0001-m即回绕<br>反码原理：1111-m</p>
<h2 id="类型转换和溢出"><a href="#类型转换和溢出" class="headerlink" title="类型转换和溢出"></a>类型转换和溢出</h2><p>c语言是弱类型语言，类型检查不严格</p>
<p>标准io：在stdio.h库中，有printf和scanf<br>printf()可变长参数列表用 , 隔开参数<br>第一个参数是字符串（字符指针，字符数组，字符串字面量）<br>转义字符：%占位符，\功能符（ascii码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">55</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="number">66.66</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    <span class="comment">//隐式转换，对于int a = b+c(b,c是double)这里是数据丢失</span></span><br><span class="line">	<span class="comment">//危险情况：输出时溢出被截断,截断高位。注意：如果多个%d就再读4字节而不是读下一个参数，因为这是压栈式（数据从右往左，高字节压倒低字节）</span></span><br><span class="line">	<span class="comment">//运算溢出几乎都会回绕(会扩大内存进位1仍存在)，赋值几乎都是截断</span></span><br><span class="line">	<span class="comment">//(int)d;//强制类型转换，小数转整形直接丢弃小数(丢失数据不是截断)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大小端系统"><a href="#大小端系统" class="headerlink" title="大小端系统"></a>大小端系统</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//高低端字节序通过指针可以看出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x11223344</span>;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	c = n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//表达式具备唯一返回值</span></span><br><span class="line">	<span class="comment">//,连接多个语句     =赋值    ;结束语句   ()提升优先级</span></span><br><span class="line">	<span class="comment">//赋值顺序右往左</span></span><br><span class="line">	<span class="comment">//目数（操作数个数）：单双三    如  ，双目    ；单目    ？：三目</span></span><br><span class="line">	<span class="comment">//a?b:c;即a真假，真则b假则c（非0真，0假）</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	n = <span class="number">1</span>,<span class="number">2</span>;<span class="comment">//n=1</span></span><br><span class="line">	n = (<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//n=2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//只用于输出字符   </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hahaha&quot;</span>);<span class="comment">//只用于输出字符串 ，并自动回车  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">int</span>) <span class="string">&quot;1&quot;</span>); </span><br><span class="line">    <span class="comment">//字符串总以\0结尾(可省略),返回的是地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hahahaha%d\n&quot;</span>, <span class="number">10</span>);<span class="comment">//无输出上限</span></span><br><span class="line">	<span class="comment">//char 1字节，中文 2字节 属于字符串</span></span><br><span class="line">	<span class="comment">//char中存的是ascii码   a对应97</span></span><br><span class="line">	<span class="comment">//字符集 char 1字节 wchar_t 2字节</span></span><br><span class="line">	<span class="comment">//小数存储 float（4字节） 1符号，8e（ieee规定存储的时候要加上一个中间值127或1023）,23科学计数  double(8字节) 1符号，11e,52科学计数（科学计数：只要一位整数且小数点前必为1所以省去，只保留的小数点后面的部分）(e绝对范围，科学计数绝对精度)</span></span><br><span class="line">	<span class="comment">//2进制科学计数法： 小数点后就是n1*1/2^1+n2*1/2^2+n3*1/2^3…… </span></span><br><span class="line">	<span class="comment">//无可避免的浮点误差0.1+0.2=0.3(存储方式问题)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>+-正负 + -  / *  %</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>~  &amp;  |  ^  《  》</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>+=    -=    *=    /=    %=    &amp;=  |=   ^=   &lt;&lt;=  &gt;&gt;=</p>
<h2 id="自运算法"><a href="#自运算法" class="headerlink" title="自运算法"></a>自运算法</h2><p>n—  n++  —n  ++n</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>！  &amp;&amp;   ||  </p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&lt; &gt;  ==  ！=  &gt;=  &lt;=</p>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>：，  ；  #  &amp;  ？：   （） （） （）[]  []  {} &lt;&gt; ‘’  “”  <em>  .   -&gt;  \  /   //     /</em>   @</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>除法运算10/3=3，注意类型；10/3.0=3.3（在cpp中强类型语言隐式转换会报错）<br>不同类型运算时，整形提升，类型提升为更大的数据类型<br>取余运算，全部按正的算，看%左取正负<br>自运算符号位置在前先自运算再执行，在后先执行再自运算  例：n=6,n++ + ++n + n++ + ++n=6+8+8+10=32<br>位运算针对二进制：按位取反~    按位与&amp;（全真为真，用来保留位）    按位或|（有真就真）<br>n&lt;<m;a>&gt;b;n左移m位（补0），a右移b位（补符号位）<br>sizeof是关键字不是运算符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x80000001</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x    %x\n&quot;</span>,n&lt;&lt;<span class="number">1</span>,n&gt;&gt;<span class="number">1</span>);<span class="comment">//输出中遇到\0认为是字符串结尾结束输出</span></span><br><span class="line">	n = <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n++ + ++n + n++ + ++n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>不一定要main为入口，vs项目-&gt;属性-&gt;c/cpp-&gt;链接器-&gt;入口</p>
<p>黑窗口只能输入十进制</p>
<p>关系符的混合使用要注意优先级，一般用  (  )  括起来，以免出差错</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>按位异或 ^ 同0异1<br>按位同或   同1异0（实现~和^一起用）<br>关系运算符   返回一定是逻辑值1真0假<br>指针只有NULL代表假，数值0就是假，\0是假，字符串自变量一定真因为返回的是地址<br>逻辑运算符<br>1、连接关系运算符，只看逻辑值,!逻辑非<br>2、&amp;&amp;和||具备短路性质，如果左值能决定那么右值不运算（优化）</p>
<p>注意运算符优先级!!!</p>
<p>注意在1&lt;a&lt;2按左到右计算1&lt;a返回0或1然后和&lt;2运算</p>
<p>0.0000000000000000000001放在float中还是有值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>, m = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> temp = n;</span><br><span class="line">	n = m;</span><br><span class="line">	m = temp;</span><br><span class="line">	n = n + m;</span><br><span class="line">	m = n - m;</span><br><span class="line">	n = n - m;<span class="comment">//有范围上的缺陷</span></span><br><span class="line">	n = n ^ m;<span class="comment">//1001^1100=0101</span></span><br><span class="line">	m = n ^ m;<span class="comment">//0101^1100=1001</span></span><br><span class="line">	n = n ^ m;<span class="comment">//0101^1001=1100</span></span><br><span class="line">	<span class="comment">//有两个可以推第三个</span></span><br><span class="line">	<span class="comment">//同或也可实现该功能</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after swap:%d\n%d\n&quot;</span>, n, m);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 2</span></span><br><span class="line">	n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (n = <span class="number">6</span> &lt; <span class="number">3</span> &amp;&amp; (m == <span class="number">999</span>))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, n, m);<span class="comment">//输出0,2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, n, m);<span class="comment">//输出0,2</span></span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n == <span class="number">1</span> &gt;= <span class="number">0</span>);<span class="comment">//输出0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="条件转跳"><a href="#条件转跳" class="headerlink" title="条件转跳"></a>条件转跳</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">	;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">	;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	;</span><br><span class="line"><span class="comment">//以上属于一个if语句</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上属于一个if语句</span></span><br></pre></td></tr></table></figure>
<p>一个if可以有多个else if和一个else以此判断，但有一个满足，执行后立即跳出整个if语句</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>在多个if时考虑使用switch<br>在汇编底层，循环就是跳转jmp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span> (n) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">		<span class="number">2</span>; <span class="number">2</span>;</span><br><span class="line">	&#125;; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不加{}只能加一条语句<br>语法限制：n要求只能返回整形值（不会帮你隐式转换）且case一定是值<br>swtich指从哪个case进入不break就会一直执行下面的</p>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>用法：goto 标签d一般配合if使用</p>
<p>底层直接jmp</p>
<p>素数  m%(2到m-1)!=0</p>
<p>判断素数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span><span class="comment">//c语言用布尔运算要加这个头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;	</span><br><span class="line">	<span class="type">bool</span> t;</span><br><span class="line">	t = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">flag:</span><br><span class="line">	<span class="keyword">if</span> (n% i == <span class="number">0</span>)t = <span class="literal">true</span>;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n) <span class="keyword">goto</span> flag;<span class="comment">//写法</span></span><br><span class="line">	<span class="keyword">if</span> (t)<span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>);</span><br><span class="line">    	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="循环如何结束"><a href="#循环如何结束" class="headerlink" title="循环如何结束"></a>循环如何结束</h2><p>1、逻辑值判断为假<br>2、break打断，直接跳出当前循环<br>3、goto无条件跳转,return结束函数,exit(0)程序正常退出exit(1)程序异常退出<br>4、continue跳过本次循环</p>
<h2 id="goto实现循环"><a href="#goto实现循环" class="headerlink" title="goto实现循环"></a>goto实现循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">loop:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n % <span class="number">10</span>);</span><br><span class="line">	n /= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>)<span class="keyword">goto</span> loop;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (;n&gt;<span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n % <span class="number">10</span>);</span><br><span class="line">		n / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for (n=10; n &gt; 0;n—)<br>在括号里定义的变量属于局部变量，只用于该语句体<br>第一个表达式是初始化<br>第二个是判断条件真<br>则执行第三个表达式和语句体，然后回到第二个表达式</p>
<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断while后面（）中只要为真就执行后面的语句<br>执行语句后再进行判断</p>
<h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与while几乎没区别<br>进入语句时先执行一次<br>再判断while后面（）中只要为真就执行后面的语句<br>执行语句后再进行判断</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h2 id="scanf输入"><a href="#scanf输入" class="headerlink" title="scanf输入"></a>scanf输入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//&amp;是取地址符，&amp;n表示n的首地址</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> m = &amp;n;</span><br><span class="line">	<span class="comment">//scanf(&quot;%d&quot;, m);</span></span><br><span class="line">	<span class="comment">//scanf(&quot;%d&quot;, &amp;n);//两条同理</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d，%c%d&quot;</span>, &amp;m,&amp;c, &amp;n);</span><br><span class="line">	<span class="comment">//scanf(&quot;%d&quot;, &amp;n);</span></span><br><span class="line">	<span class="comment">//scanf(&quot;%c&quot;, &amp;c);</span></span><br><span class="line">	<span class="comment">//注意空格属于字符在输入时加空格会别%c识别</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d%c%d&quot;</span>, n, c, m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入问题"><a href="#输入问题" class="headerlink" title="输入问题"></a>输入问题</h2><p>用fflush(流名称) 用于清空一个流</p>
<p>scanf在遇到空白，宽度结束，非法输入时，停止该数据输入<br>在遇到空白时会丢弃一个字符<br>注意enter包括\r回车 \n换行，\n没被丢弃可以赋予给%c<br>注意string，会读到\0即空白就停止<br>注意在scanf””中有格式其它的字符外会空读取，要保持格式一样</p>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>%c一个字符<br>%d一个十进制<br>%o一个八进制<br>%x一个十六进制<br>%s一个字符串<br>%f一个浮点数e和g和lf同<br>%p一个指针<br>%u一个无符号十进制<br>%%即%<br>%e指数形式<br>%[]读[]里的字符合集,在[]中加^取反即不读取<br>.n只留几位小数不进位或者对字符串只读头几个字符<br>修饰符：<br>l长数据，%lld64为整型<br>h短数据<br>*空读一个数据<br>在%与格式之间加数字限定读入字符<br>(B)略去多个空白字符直至出现非空白字符;该条一般默认存在<br>(c)略去该个固定的字符<br>%xn输出n位，不足左侧用x补齐(默认空格)<br>%x-n输出n位，不足右侧用x补齐(默认空格)</p>
<h1 id="指针含义"><a href="#指针含义" class="headerlink" title="指针含义"></a>指针含义</h1><p>cpu通过寄存器读内存<br>每个内存有一个地址</p>
<p>指针：首地址+类型（地址大小：地址位数 = 寄存器位数 = int = 32位）<br>指针变量：用来存储指针的变量</p>
<h1 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h1><p>给函数传参时是单向赋值</p>
<p>要改变传过去的变量的内容，要传该变量的指针</p>
<p>int**  指  指针的指针</p>
<p>**a     指  解引用2次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeNum1</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">changeNum2</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>**)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">11</span>;</span><br><span class="line">	changeNum1(num);<span class="comment">//没有改动</span></span><br><span class="line">	changeNum2(&amp;num);<span class="comment">//有效改动</span></span><br><span class="line">	<span class="comment">//因此要修改传入指针时要传比他高一级的指针，访问则不用</span></span><br><span class="line">	<span class="type">int</span>* p;</span><br><span class="line">	change(&amp;p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeNum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeNum2</span><span class="params">(<span class="type">int</span>* n)</span> &#123;</span><br><span class="line">	 (*n)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>**a)</span> &#123;</span><br><span class="line">	(*a)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>double func(int a,float*b);函数</p>
<p>double ()(int a,float*);函数类型</p>
<p>double (<em> ) (int a,float</em>);函数类型指针</p>
<p>double <em> p (int a,float</em>);定义一个函数类型的指针变量</p>
<p>注意函数名返回的是函数类型的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func</span><span class="params">(<span class="type">int</span>* a, <span class="type">float</span>** f)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">float</span> f = <span class="number">66.66</span>;</span><br><span class="line">	<span class="type">float</span>* pf = &amp;f;  </span><br><span class="line">    <span class="comment">//先定义一个函数指针pFunc</span></span><br><span class="line">	<span class="type">void</span>* (*pFunc)(<span class="type">int</span>* a, <span class="type">float</span>** f);</span><br><span class="line">	pFunc = func;</span><br><span class="line">    <span class="type">void</span>* p = func(&amp;n, &amp;pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p:%g\n&quot;</span>, *(<span class="type">float</span>*)p);</span><br><span class="line">    <span class="type">void</span>* p = pFunc(&amp;n, &amp;pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p:%g\n&quot;</span>, *(<span class="type">float</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">func</span><span class="params">(<span class="type">int</span>* a, <span class="type">float</span>** f)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func被调用*a:%d,**f:%g\n&quot;</span>, *a, **f);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)(*f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>同普通变量一样，需要声明和定义<br>[]内必须是确定值(低版本)，有初始化可以不用</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>连续内存段<br>数组名绑定一块内存段，数组名的返回值是数组首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> height = <span class="number">168</span>;</span><br><span class="line">	<span class="type">int</span> height6, height5, height4, height3, height2, height1;</span><br><span class="line">	<span class="type">int</span> height0[<span class="number">666</span>];</span><br><span class="line">	<span class="comment">//初始化（只有这个时候可以用=赋值）</span></span><br><span class="line">	<span class="comment">//没写的补0，什么都没写就不初始化，经典写法=&#123;0&#125;</span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">6</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="comment">//访问：读，写</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//数组下标（正整数）访问数组,可以超出定义即越界（0~n-1）但是</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区分字符串"><a href="#区分字符串" class="headerlink" title="区分字符串"></a>区分字符串</h2><p>字符串字面量(即字符)：（以\0结尾，没有会自动填充）以ascii码保存<br>字符数组：用数组存多个字符<br>字符指针(即字符类型的指针)</p>
<h2 id="功能符与ascii码"><a href="#功能符与ascii码" class="headerlink" title="/功能符与ascii码"></a>/功能符与ascii码</h2><p>‘0’=0x30   ‘A’=0x41  ‘a’=0x61</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="string">&quot;afuab&quot;</span>;<span class="comment">//字符串返回值是首地址，类比数组，不可以给a赋值</span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="string">&quot;afuab&quot;</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;abcde&quot;</span>;<span class="comment">//或者=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//注意：输出时一个个字符输出直到遇到\0</span></span><br><span class="line">	<span class="comment">//&quot;abcdef&quot;[0] = 1;//只读内存段（常量）不可修改</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str,<span class="string">&quot;asd&quot;</span>);<span class="comment">//字符串拷贝，遇到\0结束</span></span><br><span class="line">	<span class="built_in">memcpy</span>(str,<span class="string">&quot;asf&quot;</span>,<span class="number">8</span>);<span class="comment">//内存拷贝，以字节为单位，可以无视类型</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><h2 id="指针解引用"><a href="#指针解引用" class="headerlink" title="指针解引用"></a>指针解引用</h2><p>int <em> n;//n绑定了一个内存段，用  </em> n 就是引用这个内存段<br>解引用*单目运算符，右操作数是指针，一个带类型的首地址，返回一个内存段指针数学运算，带类型运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//定义： 类型* 变量</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* p;<span class="comment">//储存一个int类型内存段的指针</span></span><br><span class="line">	</span><br><span class="line">	p = &amp;n;<span class="comment">//&amp;取n首地址，给p</span></span><br><span class="line">	<span class="comment">//指针变量p指向n（指针变量p绑定的内存段中保存着变量n的首地址）</span></span><br><span class="line">	*p = <span class="number">1</span>;<span class="comment">//可写，返回的是一个内存段，*p实际上就等同于n</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其他赋值	</span></span><br><span class="line">    <span class="type">int</span>* w = <span class="number">0x11223344</span>;<span class="comment">//可以直接人工给地址，一般不会用	</span></span><br><span class="line">	<span class="type">char</span>* q = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">	<span class="comment">//拿到1234四个字符的首地址(字符1的地址（字符串,一个一个字符存/数字是直接一整个存）)放在q）</span></span><br><span class="line">	p = q;<span class="comment">//把存在q中的地址复制到p中</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %x\n&quot;</span>, *p,*q);<span class="comment">//输出ascii码从字符1开始</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算</span></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="type">char</span> *a= arr;</span><br><span class="line">	<span class="type">int</span>* b = arr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *a);<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *b);<span class="comment">//1</span></span><br><span class="line">	a += <span class="number">1</span>;</span><br><span class="line">	b += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *a);<span class="comment">//0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *b);<span class="comment">//2</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用指针访问数组"><a href="#利用指针访问数组" class="headerlink" title="利用指针访问数组"></a>利用指针访问数组</h2><p>[]在访问时的意思是，读该偏移地址的值<br>数组[i]  等同于  首地址+i后解引用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span>* str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	<span class="type">char</span> arr[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="comment">//访问方式</span></span><br><span class="line">	<span class="comment">//下标访问</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//指针访问</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(str+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,* (<span class="string">&quot;abcdefg&quot;</span>+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组名的返回"><a href="#数组名的返回" class="headerlink" title="数组名的返回"></a>数组名的返回</h2><p>地址返回值包括：带类型的地址</p>
<p>数组名的返回值是第一个元素的地址<br>        即元素类型的地址<br>        所以数组名不是首地址</p>
<p>&amp;数组名的返回值是数组类型地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>] = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, arr );<span class="comment">//,返回第一个元素的首地址，单位是int类型，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, &amp;arr );<span class="comment">//取整个数组的首地址,类型是int数组类型</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, &amp;arr + <span class="number">1</span>);<span class="comment">//相当于加了一个数组长度,8字节</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, arr + <span class="number">1</span>);<span class="comment">//只加了4个字节</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><p>二维数组元素类型是一维数组类型</p>
<p>[ ]的优先级高于*</p>
<p>int (*p)[4]  指  指针指向数组的类型为int [4]</p>
<p>int *(p[4])  指  类型为指针的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span>*(pa[<span class="number">3</span>])[<span class="number">7</span>];<span class="comment">//数组容量为3，存储容量为7的数组的指针（指针数组）</span></span><br><span class="line">	<span class="type">int</span>* ps[<span class="number">3</span>][<span class="number">7</span>];<span class="comment">//同上</span></span><br><span class="line">	<span class="type">int</span> ((*pd)[<span class="number">7</span>])[<span class="number">3</span>];<span class="comment">//指针（数组指针）</span></span><br><span class="line">	<span class="type">int</span>(*pf)[<span class="number">7</span>][<span class="number">3</span>];<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> arr[<span class="number">3</span>] = &#123; <span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">	<span class="type">int</span>(*p1)[<span class="number">3</span>] = &amp;arr;<span class="comment">//数组的指针</span></span><br><span class="line">	<span class="type">int</span>* p2 = arr;<span class="comment">//数组第一个元素的指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n%c&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arr[0] 的类型是int</p>
<p>&amp;arr[0]的类型是int*</p>
<p>arr的类型是int*</p>
<p>&amp;arr的类型是int(*)[]</p>
<p>arr的值等于&amp;arr但类型不同</p>
<h1 id="指针数组和数组指针区别"><a href="#指针数组和数组指针区别" class="headerlink" title="指针数组和数组指针区别"></a>指针数组和数组指针区别</h1><p>数组就是多个相同类型整合成一个，<br>指针数组就是多个同类型的指针整合起来<br>int*[] p则是定义一个元素为int类型指针的数组</p>
<p>数组指针则是&amp;数组名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span>* parr[<span class="number">2</span>] = &#123;&amp;arr[<span class="number">0</span>],&amp; arr[<span class="number">1</span>]&#125;;</span><br><span class="line">	<span class="type">int</span>* p[] = &#123; <span class="string">&quot;asd123asd&quot;</span>,<span class="string">&quot;qwe456qwe&quot;</span>,<span class="string">&quot;zxc789zxc&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//int* (p[])= &#123; &quot;asd&quot;, &quot;qwe&quot;, &quot;zxc&quot; &#125;同上;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*((<span class="type">char</span>*)p[<span class="number">0</span>]+<span class="number">1</span>));<span class="comment">//注意类型不同		</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((<span class="type">char</span>*)p[<span class="number">0</span>])[<span class="number">1</span>]);<span class="comment">//同上				</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//先执行p[0]得到地址，但指针类型不变还是int，[1]就加4字节,注意此处与二位数组不同</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>元素是数组的数组</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最底层元素类型 数组名 [一维数] [二维数]</p>
<h3 id="二维数组元素类型"><a href="#二维数组元素类型" class="headerlink" title="二维数组元素类型"></a>二维数组元素类型</h3><p>最底层元素类型（）[二维数]</p>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,<span class="comment">//arr第一个元素</span></span><br><span class="line">		<span class="comment">//&#123;1，1，1，1&#125;中每个元素是arr[0]的每个元素</span></span><br><span class="line">		&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,<span class="comment">//arr第二个元素</span></span><br><span class="line">		&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,<span class="comment">//arr第三个元素</span></span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,<span class="comment">//arr第四个元素</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> arr1[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,</span><br><span class="line">	<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">	<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span></span><br><span class="line">	&#125;;<span class="comment">//与arr是相同定义</span></span><br><span class="line">	<span class="comment">//可见申请也是以一维数组方式申请,连续,即：</span></span><br><span class="line">	<span class="type">int</span>* parr = <span class="built_in">malloc</span>(<span class="number">4</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		parr[i] = arr[i / <span class="number">4</span>][i % <span class="number">4</span>];<span class="comment">//访问时位移[第一个]*[第二个定义]+[第二个]</span></span><br><span class="line">	parr = &amp;arr;<span class="comment">//与上结果同</span></span><br><span class="line">	<span class="comment">//一般访问</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[j][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr1[j][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(parr+i+j*<span class="number">4</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数也需要：声明，定义，使用<br>声明后才可以使用定义时参数可以只写类型<br>声明才可以使用函数<br>在前面定义相当于声明</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>定义返回类型 函数名（类型 参数列表（用, 隔开参数））</p>
<h2 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h2><p>跳转：函数名的返回值是函数的地址<br>传参：以赋值形势（单向）<br>        值传递，地址传递，引用（cpp才有）<br>        ()内有void不允许传参，不然可以传任意参数,传参即初始化<br>返回：函数表达式被函数的返回值代替<br>        返回值不写的话,编译器会帮你默认返回int 0<br>        printf函数返回字节值<br>        (返回值都在eax里，printf占用后，不写默认返回字节数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">1</span>);<span class="comment">//参数的使用</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">666</span>));</span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;, 666)是表达式，先执行，然后返回值，大小为输出了的字节数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n&quot;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a),<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b));</span><br><span class="line">	<span class="comment">//scanf(&quot;%d&quot;,&amp;a)也是表达式，先执行，然后返回值，大小为输入了的字节数,多了的%d会输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="comment">//注意这里ab与上面输入刚好反序</span></span><br><span class="line">	<span class="comment">//reason:输出多个时，是从后面开始，因为先压栈的最后出，所以上面的先读了b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里不写返回最后一个printf输出的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h2><p>调用函数<br>        语言自带：<stdio.h> printf scanf<br>        系统自带 ：<windows.h> Sleep<br>        第三方库：<winmm.lib> mciSendString<br>自定义函数<br>多文档编程<br>        同一个工程中(只有一个main)拆分多个源文件，分出.h和.c文件<br>        include后加“头文件名.h”<br>        “”先在当前文件夹找，再去系统文件夹找；用&lt;&gt;直接去系统文件夹找<br>库 静态库 动态库</p>
<h2 id="函数查询"><a href="#函数查询" class="headerlink" title="函数查询"></a>函数查询</h2><p>选中函数然后F1可以看函数怎么用<br>选中函数然后F12可以看函数原型（其实是看库内定义）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//这个就是函数的声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;winmm.lib&quot;</span>)<span class="comment">//加静态库（library）</span></span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">function() &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数建立&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">swap(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = function(),m=<span class="number">1</span>;</span><br><span class="line">	swap(n, m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, n,m);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置定义，在前处已经声明了</span></span><br><span class="line">swap(<span class="type">int</span> a,<span class="type">int</span> b) &#123;</span><br><span class="line">	<span class="type">int</span> temp = a; a = b; b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><h1 id="include-“stdafx-h”"><a href="#include-“stdafx-h”" class="headerlink" title="include “stdafx.h”"></a>include “stdafx.h”</h1><p>包含了<stdio.h>和<tchar.h>,tchar又有#define _tmain main</p>
<p>int _tmain(int argc,char* argv][])<br>这个是windows提供对unicode和ansi字符集自动转换用的程序入口点，会根据宏改对应的函数签名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc,<span class="type">char</span>* argv][],<span class="type">char</span> **env )&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> m = （<span class="type">int</span>)&amp; n;<span class="comment">//cpp一定要强制转换</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//两者相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>argc和argv参数在用命令行编译程序时有用<br>第一个参数，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1，有参数时会自动改变<br>第二个参数，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数<br>    各成员含义如下：<br>    argv[0]指向程序运行的全路径名<br>    argv[1]指向在DOS命令行中执行程序名后的第一个字符串<br>    argv[2]指向执行程序名后的第二个字符串<br>    argv[3]指向执行程序名后的第三个字符串<br>    argv[argc]为NULL<br>第三个参数，env[]的每一个元素都包含ENVVAR=value形式的字符串<br>其中ENVVAR为环境变量，value为其对应的值，平时使用到的比较少</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>每一个应用程序都有一个4G 虚拟内存<br>内存有申请和释放（内存泄漏：使用完没有及时释放）</p>
<h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p>定义变量的时候自动分配了对应大小的内存<br>系统会在对应时期自动释放<br>泄露可能性小，但是不能自由使用内存</p>
<h2 id="手动分配"><a href="#手动分配" class="headerlink" title="手动分配"></a>手动分配</h2><p>需要头文件stdlib.h</p>
<p>使用：malloc(memory alloce)<br>返回值为void*，类型在分配后绑定<br>free解除绑定，即取消这块内存的使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span>* p = <span class="built_in">malloc</span>(<span class="number">1024</span>);<span class="comment">//void是无类型即任意</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="built_in">printf</span>(<span class="string">&quot;申请失败&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;申请成功&quot;</span>);</span><br><span class="line">	<span class="type">char</span> name[] = <span class="string">&quot;名字&quot;</span>;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">16</span>;</span><br><span class="line">	<span class="type">char</span> sex = <span class="string">&quot;f&quot;</span>;</span><br><span class="line">	<span class="type">double</span> score = <span class="number">66.66</span>;</span><br><span class="line">	<span class="type">char</span>* pTemp = p;</span><br><span class="line">	<span class="comment">//以下给对应内存赋值</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pTemp, name);<span class="comment">//memcpy(pTemp,name,len)</span></span><br><span class="line">	<span class="comment">//注意前者不会检查oTemp中是否有足够长度给name,可能导致缓冲区溢出</span></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(name);<span class="comment">//长度为\0前的字符数量</span></span><br><span class="line">	pTemp += len;<span class="comment">//加上长度，改变输出位置</span></span><br><span class="line">	*((<span class="type">int</span>*)pTemp )= age;<span class="comment">//赋值记得改变类型</span></span><br><span class="line">	pTemp += <span class="number">4</span>;</span><br><span class="line">	*pTemp = sex;</span><br><span class="line">	pTemp += <span class="number">1</span>;</span><br><span class="line">	*((<span class="type">double</span>*)pTemp) = score;</span><br><span class="line">	<span class="comment">//读取</span></span><br><span class="line">	pTemp = p;</span><br><span class="line">	<span class="comment">//printf(&quot;%s&quot;, pTemp);</span></span><br><span class="line">	<span class="comment">//注意这个不行因为在字符串复制时没有\0结束符(strlen不计算\0导致被覆盖)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *pTemp++);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *((<span class="type">int</span>*)pTemp));</span><br><span class="line">	pTemp += <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *pTemp);</span><br><span class="line">	pTemp += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, *((<span class="type">double</span>*)pTemp));</span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//解除绑定</span></span><br><span class="line">	p = <span class="literal">NULL</span>;<span class="comment">//取消指针</span></span><br><span class="line">	<span class="comment">//释放再读也可以，但是可能被其他变量占用而读出乱码</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *pTemp++);<span class="comment">//这里++优	先级高，先对pTemp进行修改</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *((<span class="type">int</span>*)pTemp));</span><br><span class="line">	pTemp += <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *pTemp);</span><br><span class="line">	pTemp += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, *((<span class="type">double</span>*)pTemp));</span><br><span class="line">	pTemp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>calloc(元素数量,元素大小)和realloc(旧内存，新内存大小)也是内存分配函数<br>前者自动计算大小并初始化为0，后者即为修改内存大小，内容不做更改</p>
<h1 id="变量作用-使用-域"><a href="#变量作用-使用-域" class="headerlink" title="变量作用(使用)域"></a>变量作用(使用)域</h1><h2 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h2><p>栈：编译器自动分配释放参数，局部变量<br>堆：程序员手动分配的内存区，程序结束由os统一回收<br>全局（静态）区（bss（未初始化（都是0）的全局变量））：const修饰常量为只读且要初始化，全局变量，静态变量<br>全局（常量）区放着常量字符串，我们定义是从这里拷贝，程序结束os回收<br>代码区：函数</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>修饰变量为静态变量（默认初始化为0）只对当前文件可见<br>再定义保留上一次的值（即不销毁）<br>局部static和全局static的区别只是作用(使用)域不同</p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>对其他c文件可见，函数和全局变量默认extern</p>
<h2 id="变量重名问题"><a href="#变量重名问题" class="headerlink" title="变量重名问题"></a>变量重名问题</h2><p>等同作用域内不可以重名</p>
<p>在同一作用域中，就近原则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1</span></span><br></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="变量位置和状态"><a href="#变量位置和状态" class="headerlink" title="变量位置和状态"></a>变量位置和状态</h2><p>全局    main前面        声明到程序结束<br>局部    函数里面        声明到函数结束<br>全局静态static修饰        声明到程序结束<br>局部静态static修饰        声明到程序结束<br>堆        手动分配内存    申请到释放        </p>
<h2 id="规则-程序运行时"><a href="#规则-程序运行时" class="headerlink" title="规则(程序运行时)"></a>规则(程序运行时)</h2><p>自己申请的内存只能自己释放<br>一般在{}内定义的变量，离开{}自动释放<br>static变量，不会被释放<br>全局变量，不会被释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>  a)</span> &#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//malloc返回首地址和类型</span></span><br><span class="line">	<span class="comment">//可以返回p，没危险</span></span><br><span class="line">	<span class="comment">//这里绑定了内存,要自己释放</span></span><br><span class="line">	<span class="comment">//所以申请后一定返回p，不然没法释放</span></span><br><span class="line">	a += <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">	<span class="comment">//返回变量地址危险，因为a是局部变量，分配的内存会自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span>* ptr;<span class="comment">//野指针，不知道指向哪里所以危险</span></span><br><span class="line">	<span class="type">int</span>* p = f(<span class="number">656</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)+<span class="number">222</span>);<span class="comment">// 能用但是很危险</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>用于自定义类型，不允许空结构体</p>
<h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><p>struct 结构名{</p>
<p>包含变量</p>
<p>}可定义变量名；</p>
<h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><p>struct 结构名 变量名；</p>
<p>结构体内内存连续可以直接在定义的时候(;之前)用={}来初始化</p>
<p>也可以.包含变量名= 来固定初始化</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>对象(结构体变量).成员<br>对象指针-&gt;成员<br>(*对象指针).成员</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">double</span> ywScore;</span><br><span class="line">	<span class="type">double</span> sxScore;</span><br><span class="line">	<span class="type">double</span> cScore;</span><br><span class="line">&#125;s2,s3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//定义</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;a&quot;</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123; .id=<span class="number">2</span>,.cScore=<span class="number">66</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%lf %lf %lf&quot;</span>, 						s1.name[<span class="number">20</span>],s1.id,s1.ywScore,s1.sxScore,s1.cScore);</span><br><span class="line">	<span class="built_in">strcpy</span>(s1.name[<span class="number">20</span>], <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%lf %lf %lf&quot;</span>, s1.name[<span class="number">20</span>], s1.id, s1.ywScore, s1.sxScore, s1.cScore);</span><br><span class="line">	<span class="comment">//-&gt;访问</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">ps1</span>;</span></span><br><span class="line">	ps1 = &amp;s1;</span><br><span class="line">	(*ps1).id = <span class="number">3</span>;</span><br><span class="line">	ps1-&gt;id = <span class="number">3</span>;<span class="comment">//同上</span></span><br><span class="line">	<span class="built_in">strcpy</span>((*ps1).name[<span class="number">20</span>], <span class="string">&quot;李四&quot;</span>);<span class="comment">//指针是一样的用法</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[5] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;a&quot;</span><span class="comment">/*&#123;&#x27;a&#x27;&#125;*/</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,		</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span><span class="comment">/*&#123;&#x27;a&#x27;&#125;*/</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;a&quot;</span><span class="comment">/*&#123;&#x27;a&#x27;&#125;*/</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;a&quot;</span><span class="comment">/*&#123;&#x27;a&#x27;&#125;*/</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;a&quot;</span><span class="comment">/*&#123;&#x27;a&#x27;&#125;*/</span> ,<span class="number">1</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">p</span>=</span>arr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d \n&quot;</span>,arr[<span class="number">1</span>].id,p[<span class="number">1</span>].id,(p+<span class="number">1</span>)-&gt;id,(arr+<span class="number">1</span>)-&gt;id);</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">struct</span> student);<span class="comment">//获取结构体的大小</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>包含内容：</p>
<p>创建节点类型</p>
<p>创建节点的函数</p>
<p>查找节点地址</p>
<p>遍历，输出所有节点</p>
<p>插入(头，尾，中间)</p>
<p>删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNext</span>;</span><span class="comment">//下一个节点类型的指针变量，用于连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">CreatNode</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">findPos</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertToHead</span><span class="params">(<span class="type">int</span> n, <span class="keyword">struct</span> Node** <span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertToTail</span><span class="params">(<span class="type">int</span> n, <span class="keyword">struct</span> Node* <span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertBehind</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="keyword">struct</span> Node* <span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">view</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node** <span class="built_in">list</span>, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pList可以指向一个列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pList</span> ;</span></span><br><span class="line">	<span class="comment">//创建调用</span></span><br><span class="line">	pList = CreatNode(<span class="number">2</span>);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	insertToHead(<span class="number">15</span>, &amp;pList);<span class="comment">//15 2</span></span><br><span class="line"></span><br><span class="line">	travel(pList);</span><br><span class="line"></span><br><span class="line">	insertToTail(<span class="number">3</span>, pList);<span class="comment">//15 2 3</span></span><br><span class="line"></span><br><span class="line">	travel(pList);</span><br><span class="line"></span><br><span class="line">	insertBehind(<span class="number">4</span>, <span class="number">1</span>, pList);<span class="comment">//15 4 2 3</span></span><br><span class="line"></span><br><span class="line">	insertBehind(<span class="number">888</span>, <span class="number">888</span>, pList);<span class="comment">//15 4 2 3 888</span></span><br><span class="line"></span><br><span class="line">	travel(pList);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> a =deleteNode(&amp;pList, <span class="number">2</span>);<span class="comment">//15 2 3 888</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">true</span>)<span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;删除失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	travel(pList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点的函数</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">CreatNode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node*));<span class="comment">//分配一个节点大小的内存</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pNew) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;n = n;</span><br><span class="line">	pNew-&gt;pNext = <span class="literal">NULL</span>;<span class="comment">//给该内存赋值</span></span><br><span class="line">	<span class="keyword">return</span> pNew;<span class="comment">//返回该内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找节点地址</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">findPos</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertToHead</span><span class="params">(<span class="type">int</span> n,<span class="keyword">struct</span> Node**<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == *<span class="built_in">list</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//防呆</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;<span class="comment">//如果是空列表</span></span><br><span class="line">		*<span class="built_in">list</span> = CreatNode(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> Node* pNew = CreatNode(n);</span><br><span class="line">		pNew-&gt;pNext = *<span class="built_in">list</span>;<span class="comment">//先把list指向的地址给到该节点</span></span><br><span class="line">		*<span class="built_in">list</span> = pNew;<span class="comment">//再把该节点给list</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertToTail</span><span class="params">(<span class="type">int</span> n, <span class="keyword">struct</span> Node*list1)</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">list</span> =</span> list1;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>-&gt;pNext) &#123;</span><br><span class="line">			<span class="built_in">list</span>-&gt;pNext = CreatNode(n);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertBehind</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a,<span class="keyword">struct</span> Node* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNew</span> =</span> CreatNode(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; a; i++) &#123;<span class="comment">//注意1个直接就是第一个节点所以只用n-1次</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>-&gt;pNext) &#123;</span><br><span class="line">			insertToTail(n, <span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;pNext;<span class="comment">//循环遍历到要插入其后的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;pNext = <span class="built_in">list</span>-&gt;pNext;<span class="comment">//先把原先指向下一节点的指针给新插入的节点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;pNext = pNew;<span class="comment">//再把该节点的地址给上面的节点</span></span><br><span class="line">	<span class="comment">//一定是先获取节点地址再连接新节点</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历（链表查看）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">travel</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="comment">/*NULL != */</span> <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">//if (NULL == pTemp) break;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">list</span>-&gt;n);</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">view</span><span class="params">(<span class="keyword">struct</span> Node* <span class="built_in">list</span>,<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\%d&quot;</span>,<span class="built_in">list</span>-&gt;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(按位置)删除节点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node** <span class="built_in">list</span>, <span class="type">int</span> num)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == *<span class="built_in">list</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//防呆</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、先找到，找不到，删除失败</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pDeleteNode</span> =</span> findPos(*<span class="built_in">list</span>, num);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pDeleteNode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//2、找到了，区分头和其他节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//头 换头 删除	</span></span><br><span class="line">	<span class="keyword">if</span> (*<span class="built_in">list</span> == pDeleteNode) &#123;</span><br><span class="line">		*<span class="built_in">list</span> = pDeleteNode-&gt;pNext;</span><br><span class="line">		<span class="built_in">free</span>(pDeleteNode);</span><br><span class="line">		pDeleteNode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他 前一个连后一个 删除</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> Node* pDeletePreNode = findPos(*<span class="built_in">list</span>, num - <span class="number">1</span>);<span class="comment">//找到前一个</span></span><br><span class="line">		pDeletePreNode-&gt;pNext= pDeleteNode-&gt;pNext;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p>类似结构体的定义和使用</p>
<h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>union</p>
<p>多个成员共用一块内存</p>
<p>该内存大小=内存最大的成员的内存大小</p>
<p>初始化时只能初始第一个成员的类型</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum</p>
<p>枚举成员必定是int型所以没有内存名</p>
<p>首位默认为0</p>
<p>内部成员会依次递增</p>
<h3 id="const限定"><a href="#const限定" class="headerlink" title="const限定"></a>const限定</h3><p>const修饰为只读变量</p>
<h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>不可以改变的量(常量)的指针</p>
<h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><p>指针不可以修改</p>
<h3 id="综上实例"><a href="#综上实例" class="headerlink" title="综上实例"></a>综上实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> &#123;</span></span><br><span class="line">	星期一,星期二,星期三,星期四=<span class="number">4</span>,星期五,星期六,星期日</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">Stu</span> <span class="title">u</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Week</span> <span class="title">w</span> ;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, 星期二);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* p = &amp;a;</span><br><span class="line">	*p = <span class="number">666</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *b = &amp;m;<span class="comment">//常量(的)指针</span></span><br><span class="line">    <span class="comment">//同int const* b;  </span></span><br><span class="line">	m = <span class="number">66</span>;</span><br><span class="line">	<span class="comment">//限制了*b的修改</span></span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> c=&amp;m;<span class="comment">//指针(是)常量</span></span><br><span class="line">	<span class="comment">//限制了c指针的修改</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;<span class="comment">//解引用和指针都不能修改</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文件内容本质是char </p>
<p>存储时 字符变为整数 表示时 整数变为字符<br>即字符文件和字节文件</p>
<h2 id="文件开关"><a href="#文件开关" class="headerlink" title="文件开关"></a>文件开关</h2><p>打开 关闭 改变光标位置 读 写(替代并不是插入)<br>FILE* 定义一个文件指针<br>fopen，fclose 开启关闭文件</p>
<h2 id="以字符操作文件"><a href="#以字符操作文件" class="headerlink" title="以字符操作文件"></a>以字符操作文件</h2><p>r 只读光标在第一个  w创建一个空文件（代替现有文件）来写 a打开一个存在文件光标在最后</p>
<p>写入：fprintf(fp, “%s\t”, “名字”);</p>
<p>读出：fscanf(fp, “%s\t”, name);</p>
<p>每次读写对应指针都会后移</p>
<h2 id="以字节操作文件"><a href="#以字节操作文件" class="headerlink" title="以字节操作文件"></a>以字节操作文件</h2><p>rb wb ab rb+ wb+ ab+</p>
<p>fread和fwrite参数均为：</p>
<p>指向要写入(读出)的数据的指针,一次写入(读出)项大小（以字节为单位）,要写入(读出)的项的最大数量（写(读)多少次）,指向文件的FILE指针</p>
<p>每次读写对应指针都会后移</p>
<h2 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h2><p>r+ w+ a+ (都拓展为读写)<br>r+是读写同指针 w+同r+但是可以生成文件 a+读写指针分开</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>创建文本文件 指定路径为桌面<br>往里面写入数据<br>关闭<br>打开<br>读到内存<br>输出<br>关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//以字符操作文件</span></span><br><span class="line">	FILE* fp = fopen(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\数据.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">	<span class="comment">//写入</span></span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\t&quot;</span>, <span class="string">&quot;名字&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\t&quot;</span>, <span class="number">666</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;%.2lf\n&quot;</span>, <span class="number">6.666</span>);</span><br><span class="line">	<span class="comment">//关闭并保存</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="comment">//打开</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\数据.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="comment">//读取到内存</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">double</span> score;</span><br><span class="line">	<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s\t&quot;</span>, name);</span><br><span class="line">	<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d\t&quot;</span>, &amp;age);</span><br><span class="line">	<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%lf\n&quot;</span>, &amp;score);</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="comment">//内存显示到cmd</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, &amp;age);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,&amp;score);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//以字节操作文件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">		<span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">double</span> score;</span><br><span class="line">	&#125;;</span><br><span class="line">	FILE* fp = fopen(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\数据.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">0</span> &#125;,s2 = &#123; <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1.name);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s1.age);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;s1.score);</span><br><span class="line">	fwrite(&amp;s1, <span class="number">1</span>, <span class="keyword">sizeof</span> (s1), fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	fp = fopen(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\数据.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	fread(&amp;s2, <span class="number">1</span>, <span class="keyword">sizeof</span>(s2), fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件详细操作"><a href="#文件详细操作" class="headerlink" title="文件详细操作"></a>文件详细操作</h1><h2 id="文件内容指针"><a href="#文件内容指针" class="headerlink" title="文件内容指针"></a>文件内容指针</h2><p>文件指针          FILE*<br>文件内容指针      理解为光标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	FILE* fp = fopen(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span>==fp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开成功\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开成功\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	fread(&amp;c, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), fp);</span><br><span class="line">	fread(&amp;c, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), fp);<span class="comment">//读的时候光标会向后</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		r = fread(&amp;c, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), fp);<span class="comment">//r返回一共读到的字节量</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> != r)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">		fseek(fp, <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">		<span class="comment">//offset偏移量，正后负前</span></span><br><span class="line">		<span class="comment">//seek_cur 当前位置</span></span><br><span class="line">		<span class="comment">//seek_set 开头位置</span></span><br><span class="line">		<span class="comment">//seek_end 结尾位置		</span></span><br><span class="line">		<span class="comment">//if (0 == count % 2)printf(&quot;%c&quot;, c);</span></span><br><span class="line">		<span class="comment">//count++;//只输出偶数位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>图片，声音文件都能拷贝</p>
<p>原理为逐字节复制到另一文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//1、用户输入src dst文件路径</span></span><br><span class="line">	<span class="type">char</span> srcFileName[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> dstFileName[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//路径长度最大只能260</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, srcFileName);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, dstFileName);</span><br><span class="line">	<span class="comment">//2、打开src文件   创建dst文件</span></span><br><span class="line">	FILE* fpSrc = fopen(srcFileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	FILE* fpDst = fopen(dstFileName, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == fpSrc|| <span class="literal">NULL</span> == fpDst) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开成功\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//3、循环读取src到内存写入dst读完结束</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];<span class="comment">//看读多少建立缓冲区（buffer）</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		r = fread(buf, <span class="number">1</span>, <span class="number">1024</span>, fpSrc);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			fwrite(buf, <span class="number">1</span>, r, fpDst);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3、关闭</span></span><br><span class="line">	fclose(fpSrc); fclose(fpDst);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><p>在文件拷贝的过程中，改变文件内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	FILE* fpSrc = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	FILE* fpDst = fopen(<span class="string">&quot;a.jiami&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		r = fread(c, <span class="number">1</span>, <span class="number">1</span>, fpSrc);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			c ^= <span class="number">0x56</span>; <span class="comment">//记得换成多字符集，这里是异或加密</span></span><br><span class="line">			fwrite(c, <span class="number">1</span>, <span class="number">1</span>, fpDst);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3、关闭</span></span><br><span class="line">	fclose(fpSrc); fclose(fpDst);</span><br><span class="line">	<span class="comment">//4、把argv[1]删掉并给打包文件改为原来的名字</span></span><br><span class="line">	DeleteFile(argv[<span class="number">1</span>]);</span><br><span class="line">	MoveFile(<span class="string">&quot;a.jiami&quot;</span>, argv[<span class="number">1</span>]);<span class="comment">//记得换成多字符集</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件解密"><a href="#文件解密" class="headerlink" title="文件解密"></a>文件解密</h2><p>和加密同理<br>其他加密和解密方式请查看密码学资料</p>
<h2 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h2><p>多个文件合并成一个，合成后的文件要有标识</p>
<p>标识组成：文件个数，文件个数个结构体的文件名和文件大</p>
<p>标识后面是依次文件数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileInfo</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> fileName[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span> fileSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">	<span class="comment">//1、创建并打开打包后文件</span></span><br><span class="line">	FILE* fpPag=fopen(<span class="string">&quot;a.pag&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="comment">//2、命令行参数得到打包文件信息(用户输入也行)</span></span><br><span class="line">	<span class="type">int</span> fileNum = argc - <span class="number">1</span>;<span class="comment">//-1是因为去除mian本身的运行路径，详情看c语言8</span></span><br><span class="line">	fwrite(&amp;fileNum, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), fpPag);</span><br><span class="line">    <span class="comment">//3、创建第二段标识的内存空间并清空置零</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FileInfo</span>* <span class="title">pFI</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> FileInfo));</span><br><span class="line">	menset(pFI, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> FileInfo));</span><br><span class="line">    <span class="comment">//4、填充数据</span></span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FileInfo</span>* <span class="title">fTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fileNum; i++) &#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(&amp;(pFI[i].fileName), argv[i + <span class="number">1</span>]);<span class="comment">//复制文件名</span></span><br><span class="line">		fTemp = fopen(&amp;(argv[i + <span class="number">1</span>]), <span class="string">&quot;rb&quot;</span>);<span class="comment">//打开文件</span></span><br><span class="line">		fseek(fTemp, <span class="number">0</span>, SEEK_END);<span class="comment">//指针移到结尾</span></span><br><span class="line">		size=ftell(fTemp);<span class="comment">//获取文件指针到文件头的字节量</span></span><br><span class="line">		pFI[i].fileSize = size;<span class="comment">//复制文件大小</span></span><br><span class="line">		<span class="comment">//将内存空间写入打包文件</span></span><br><span class="line">		fwrite(&amp;(pFI[i]), <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> FileInfo), fpPag);</span><br><span class="line">		fclose(&amp;(argv[i + <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//5、循环依序读取文件并写入打包文件</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">666</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fileNum; i++) &#123;</span><br><span class="line">		fTemp = fopen(pFI[i].fileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			r = fread(&amp;buf, <span class="number">1</span>, <span class="number">1</span>, fTemp);</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span> == r) &#123;</span><br><span class="line">				fwrite(&amp;buf, <span class="number">1</span>, <span class="number">1</span>, fpPag);</span><br><span class="line">				fclose(pFI[i].fileName);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5、关闭</span></span><br><span class="line">	fclose(<span class="string">&quot;a.pag&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多文档编程"><a href="#多文档编程" class="headerlink" title="多文档编程"></a>多文档编程</h1><h2 id="h中写声明"><a href="#h中写声明" class="headerlink" title=".h中写声明"></a>.h中写声明</h2><p>在.h中的定义，属于全局变量</p>
<p>其他里有全局定义，其他文件靠extern接口来寻找该变量，注意不可以初始化</p>
<h2 id="其他-c中写函数定义"><a href="#其他-c中写函数定义" class="headerlink" title="其他.c中写函数定义"></a>其他.c中写函数定义</h2><p>传参：在传变量时是单向的，要传地址才能改变变量的值(真实工作中)</p>
<h2 id="main-c中写变量定义和main"><a href="#main-c中写变量定义和main" class="headerlink" title="main.c中写变量定义和main"></a>main.c中写变量定义和main</h2><p>所有.c都要包括.h</p>
<p>一般不再.h中定义，因为以免用库导致包含库重复</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>.c 编成经过的步骤.exe<br>step1预处理<br>step2编译<br>step3链接</p>
<h2 id="头文件引入"><a href="#头文件引入" class="headerlink" title="头文件引入"></a>头文件引入</h2><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><p>&lt;&gt;在系统目录下找 “”先在当前目录找再去系统目录找</p>
<h1 id="pragma-once-防止头文件重复引入"><a href="#pragma-once-防止头文件重复引入" class="headerlink" title="pragma once 防止头文件重复引入"></a>pragma once 防止头文件重复引入</h1><h1 id="ifndef-HAHA-ifdef-前者定义了执行，后者反之"><a href="#ifndef-HAHA-ifdef-前者定义了执行，后者反之" class="headerlink" title="ifndef HAHA   #ifdef 前者定义了执行，后者反之"></a>ifndef HAHA   #ifdef 前者定义了执行，后者反之</h1><h1 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h1><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p>上面三句运用等于#pragma once</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GRAPHICS_H <span class="comment">// 防止graphics.h被重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPHICS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 引用标准库的头文件</span></span></span><br></pre></td></tr></table></figure>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h1 id="define-pi-3-14-简单代码替换"><a href="#define-pi-3-14-简单代码替换" class="headerlink" title="define pi 3.14 简单代码替换"></a>define pi 3.14 简单代码替换</h1><p>宏只占编译时间，函数调用则占用运行时间<br>使用宏次数多时，宏展开后源程序很长<br>因为每展开一次都会使源程序增长<br>当有很多宏展开，目标文件很大<br>一般来说，用宏来代表简短的表达式比较合适<br>可以考虑使用宏，或者内联函数</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> F int main() &#123; </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>给类型取别名，主要作用在给函数类型，或者长名字的类型多重命名</p>
<p>用法：typedef 旧名 新名</p>
<p>两个名字均可用</p>
<p>注意：在typedef前不能使用新名字</p>
<p>typedef结构体时，最后;前面的不再是定义而是新名字<br>由于此特性，创建结构的时候可以无名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">	INT m = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;n:%d\n,m:%d\n&quot;</span>, n,m);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="——————————————"><a href="#——————————————" class="headerlink" title="——————————————"></a>——————————————</h1><h1 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h1><h2 id="打砖块"><a href="#打砖块" class="headerlink" title="打砖块"></a>打砖块</h2><p>代码流程：<br>显示<br>移动<br>检查判断<br>显示</p>
<p>注意：需要easyX图形库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span>  <span class="comment">//easyX  库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span> <span class="comment">//键入检测的库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zk_w 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zk_h 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zk_r 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zk_c 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> win_h 800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> win_w zk_c*zk_w</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bz_h 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bz_w 300</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> zk[zk_r][zk_c] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> game = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> vx = <span class="number">3</span>, vy = <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawgame</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawball</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawzk</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawzkall</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawbz</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bzmove</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ballmove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bz_x = (win_w - bz_w) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> bz_y = (win_h - bz_h);</span><br><span class="line"><span class="type">int</span> bx = win_w / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> by = win_h - bz_h - r;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	initgraph(win_w,win_h, SHOWCONSOLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (game) &#123;</span><br><span class="line">		drawgame();</span><br><span class="line">		ctrl();</span><br><span class="line">		</span><br><span class="line">		Sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//zk[1][1] = 1;</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawgame</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	BeginBatchDraw();</span><br><span class="line">	cleardevice();</span><br><span class="line">	drawzkall();</span><br><span class="line">	drawbz();</span><br><span class="line">	drawball();</span><br><span class="line">	EndBatchDraw();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl</span><span class="params">()</span> &#123;</span><br><span class="line">	check1();</span><br><span class="line">	check2();</span><br><span class="line">	bzmove();</span><br><span class="line">	ballmove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawball</span><span class="params">()</span> &#123;</span><br><span class="line">	setlinecolor(RED);</span><br><span class="line">	setfillcolor(GREEN);</span><br><span class="line">	fillcircle(bx, by, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawzk</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	setlinecolor(GREEN);</span><br><span class="line">	setfillcolor(RED);</span><br><span class="line">	<span class="keyword">if</span> (zk[x][y] ==<span class="literal">false</span>) &#123;</span><br><span class="line">		fillrectangle(y * zk_w, x * zk_h, (y+<span class="number">1</span>)*zk_w,(x+<span class="number">1</span>)*zk_h);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawzkall</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zk_r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zk_c; j++)</span><br><span class="line">			drawzk(i,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">drawbz</span><span class="params">()</span> &#123;</span><br><span class="line">	setlinecolor(RED);</span><br><span class="line">	setfillcolor(YELLOW);</span><br><span class="line">	fillrectangle(bz_x, bz_y, bz_x + bz_w, bz_y + bz_h);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ((vx &gt; <span class="number">0</span>) &amp;&amp; <span class="comment">//球往右边走</span></span><br><span class="line">		(bx &gt;= (win_w - r))) &#123;<span class="comment">//撞上了右边沿</span></span><br><span class="line">		vx = <span class="number">-3</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测球是否撞上左边沿</span></span><br><span class="line">	<span class="keyword">if</span> ((vx &lt; <span class="number">0</span>) &amp;&amp; <span class="comment">//球往左边走</span></span><br><span class="line">		(bx &lt;= r)) &#123;<span class="comment">//撞上了左边沿</span></span><br><span class="line">		vx = <span class="number">3</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测球是否撞上上边沿</span></span><br><span class="line">	<span class="keyword">if</span> ((vy &lt; <span class="number">0</span>) &amp;&amp; <span class="comment">//球往上边走</span></span><br><span class="line">		(by &lt;= r)) &#123;<span class="comment">//撞上了上边沿</span></span><br><span class="line">		vy = <span class="number">3</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测球是否撞上下边沿</span></span><br><span class="line">	<span class="keyword">if</span> ((vy &gt; <span class="number">0</span>) &amp;&amp; <span class="comment">//球往下边走</span></span><br><span class="line">		(by &gt;= (win_h - r))) &#123;<span class="comment">//撞上了下边沿</span></span><br><span class="line">		game = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测球是否撞上板子</span></span><br><span class="line">	<span class="keyword">if</span> ((vy &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		(by &gt;= (bz_y - r)) &amp;&amp;<span class="comment">//球y坐标</span></span><br><span class="line">		(bx &gt;= bz_x) &amp;&amp;</span><br><span class="line">		(bx &lt;= (bz_x + bz_w))) &#123;</span><br><span class="line">		vy = <span class="number">-3</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; zk_r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zk_c; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (zk[i][j] == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bx &gt;= j * zk_w - r &amp;&amp; bx &lt;= j * zk_w + r + <span class="number">5</span> &amp;&amp; by &gt;= i * zk_h &amp;&amp; by &lt;= (i + <span class="number">1</span>) * zk_h) &#123;<span class="comment">//左</span></span><br><span class="line">					zk[i][j] = <span class="number">1</span>;</span><br><span class="line">					vx = <span class="number">-3</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (bx &lt;= (j+<span class="number">1</span>) * zk_w + r &amp;&amp; bx &gt;= (j+<span class="number">1</span>) * zk_w - r - <span class="number">5</span> &amp;&amp; by &gt;= i * zk_h &amp;&amp; by &lt;= (i + <span class="number">1</span>) * zk_h) &#123;<span class="comment">//右</span></span><br><span class="line">					zk[i][j] = <span class="number">1</span>;</span><br><span class="line">					vx = <span class="number">3</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (by &gt;= i * zk_h &amp;&amp; by &lt;= i * zk_h - <span class="number">5</span> &amp;&amp; bx &gt;= j * zk_w &amp;&amp; bx &lt;= (j + <span class="number">1</span>) * zk_w) &#123;<span class="comment">//上</span></span><br><span class="line">					zk[i][j] = <span class="number">1</span>;</span><br><span class="line">					vy = <span class="number">-3</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (by&lt;=(i+<span class="number">1</span>)*zk_h&amp;&amp;by&gt;= (i + <span class="number">1</span>) * zk_h<span class="number">-5</span> &amp;&amp; bx &gt;= j * zk_w &amp;&amp; bx &lt;= (j + <span class="number">1</span>) * zk_w) &#123;<span class="comment">//下</span></span><br><span class="line">					zk[i][j] = <span class="number">1</span>;</span><br><span class="line">					vy = <span class="number">3</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bzmove</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">true</span> == _kbhit()) &#123;</span><br><span class="line">		<span class="type">int</span> ch = _getch();</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line">				<span class="keyword">if</span>(bz_x&gt;<span class="number">0</span>)</span><br><span class="line">				bz_x -= <span class="number">5</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line">				<span class="keyword">if</span> (bz_x &lt; win_w-bz_w )</span><br><span class="line">				bz_x += <span class="number">5</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ballmove</span><span class="params">()</span> &#123;</span><br><span class="line">	bx += vx;</span><br><span class="line">	by += vy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九九乘法表"><a href="#九九乘法表" class="headerlink" title="九九乘法表"></a>九九乘法表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j + <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%2d   &quot;</span>, j, i, i * j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>, third,m=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">	third = first + second;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, third);</span><br><span class="line">	first = second;</span><br><span class="line">	second = third;</span><br><span class="line">	Sleep(<span class="number">2000</span>);</span><br><span class="line">	m += third;</span><br><span class="line">	c++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main参数实践方法"><a href="#main参数实践方法" class="headerlink" title="main参数实践方法"></a>main参数实践方法</h2><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>找到exe文件的所在文件夹<br>运行cmd<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“程序名.exe” 参数a 参数b 参数c</span><br></pre></td></tr></table></figure>
<p>便可运行程序，程序可通过argv[i]使用参数</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>vs中<br>项目-&gt;属性-&gt;调试-&gt;命令参数<br>输入所需参数即可<br>注意空格隔开</p>
<h2 id="简易计算器-函数指针"><a href="#简易计算器-函数指针" class="headerlink" title="简易计算器(函数指针)"></a>简易计算器(函数指针)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">1</span>,m = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> *<span class="title function_">p</span> <span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line">	<span class="comment">//使用</span></span><br><span class="line">    p=add;</span><br><span class="line">	p(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//1+2</span></span><br><span class="line">    p=sub;</span><br><span class="line">    p(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//1-2</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用typedef升级版"><a href="#利用typedef升级版" class="headerlink" title="利用typedef升级版"></a>利用typedef升级版</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给int（*）（int，int）取别名为PFUNC</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*PFUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call</span><span class="params">(PFUNC p, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;p(a, b);&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">1</span>,m = <span class="number">2</span>;</span><br><span class="line">	call(add, n, m);<span class="comment">//1+2</span></span><br><span class="line">	call(sub, n, m);<span class="comment">//1-2</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言项目</title>
    <url>/2022/07/21/C%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="C4"><a href="#C4" class="headerlink" title="C4"></a>C4</h1><p>特点：<br>用于编译c语言，代码简洁，onepass Parse，可自举</p>
<p>需要构建自己的虚拟机(指令集)，将源代码转化成目标代码(编译器)，将目标代码放入虚拟机中获得结果（使用符号表记录词）</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>定义：<br>把高级语言翻译成低级语言形成可执行文件</p>
<p>过程：<br>先经过自己的<strong>词法分析</strong>和<strong>语法分析</strong>生成中间代码(IR)<br>可选择优化器将AST(抽象语法树)进行效率优化<br>最后用将语法树转化成目标代码</p>
<p><img src="https://static.oschina.net/uploads/space/2019/0706/121704_AnOp_12.png" alt="img"></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>计算基于寄存器和栈<br>寄存器包括ax/sp/bp/pc(programme counter)<br>内存段包括Code/Data/Stack<br>指令集包括S&amp;L/运算/分支转跳/Native-Call</p>
<p>c4的虚拟机是堆叠机</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/rswier/c4">rswier/c4: C in four functions (github.com)</a></p>
<h1 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h1>]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言补充</title>
    <url>/2022/06/11/C%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>字符的处理策略称为贪心法或大嘴法，即下一个符号为从当前字符开始可能组成一个符号的最长字符串</p>
<p>如a—-b为a— - b<br>如a+++++b为a++ ++ + b由于a++为左值不可以++所以会编译错误</p>
<p>对于.不存在时，默认是整数，如2.0和2有区别</p>
<p>“abc”和”a””b””c”是同一个东西</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数名是一个指针，ANSI C允许在定义和调用(即引用函数指针)的时候将*省略</p>
<p>在声明时，若参数五float,short,char完全可以省略参数类型的说明，否则将自动转变为int或者double</p>
<p>对于缺乏返回值的函数声明，编译器会默认为整型</p>
<p>注意(对于声明)</p>
<p>int f()[];或者int (*f)()[];非法<br>函数只能返回标量值，不能返回数组</p>
<p>int f[] ();或int  (*f)[] ();非法<br>不允许使用函数数组</p>
<p>int  (<em>f[]) ();或int  (\</em>(*f)[]) ();合法<br>表示f保存着指向 <strong>返回值为整型的函数指针</strong> 的指针</p>
<p>对于函数指针<br>声明后可以用&amp;function或者function给其赋值<br>使用时可以(*pf)();或者pf();直接调用</p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>同一优先级的运算符，运算次序由结合方向所决定<br>注意：后置++的优先级高于前置++，++是先运算了然后返回原来的值</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.doc.wendoc.com%2Fpic%2Fafd9cd16faa0bfa9062f1718%2F1-920-jpg_6_0_______-626-0-0-626.jpg&amp;refer=http%3A%2F%2Fimg.doc.wendoc.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1660199509&amp;t=4005c56c2a97ff6366cad1f10a128cd7" alt="点击查看图片来源"></p>
<h4 id="悬挂else"><a href="#悬挂else" class="headerlink" title="悬挂else"></a>悬挂else</h4><p>else始终与同一括号内最近的未被匹配的if结合</p>
<p>初始化列表中多余的逗号</p>
<p>如int days[] = {1,2,3,4,5,6,7,}; 原因是方便编译器编译</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>c语言从0开始计算<br>1、避免栏杆错误(100m每隔10m一条栏杆需要11条)<br>2、形成不对称边界，简化程序设计</p>
<h4 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h4><p>对于&amp;&amp;，若左侧不成立，则右侧不执行<br>对于||，若左侧成立，则右侧不执行</p>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>先对左侧进行运算后丢弃，然后执行右侧</p>
<h4 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h4><p>函数和函数体外的变量默认extern，编译器会对static变量做名词修饰，让其不与外部产生冲突</p>
<p>extern对象不能多次定义，所以一般int a;定义一个，在其他文件extern int a;引用这个定义</p>
<p>由于名词修饰，可以同时存在静态和动态的同名函数</p>
<p>如果一个函数不需要外部调用，应该尽量使用static</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>连接器接收编译器生成的文件时检查extern对象与传入的文件是否冲突，然后解析其中定义的extern并标记已定义</p>
<h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><p>移位运算时对于无符号数用0填充，有符号数则复制符号位</p>
<p>移位不能超出长度，也不可以为负数</p>
<p>移位运算效率高，在已知为正数时可用&gt;&gt;1代替/2</p>
<h4 id="转换与提升"><a href="#转换与提升" class="headerlink" title="转换与提升"></a>转换与提升</h4><p>隐式定义：<br>如果赋值运算符两侧的类型不一致，但都是基本类型时，在赋值时要进行类型转换<br>不同类型一起运算时，要提升为排名更高的类型再进行运算</p>
<p>转换规则：<br>将浮点型数据赋给整型变量时，先对浮点数取整，即舍弃小数部分，然后赋予整型变量<br>将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存储到变量中<br>将double型数据赋给float变量时，先取6~7位有效数字，存储到float型变量的4个字节中，应注意双精度数值的大小不能超出float型变量的数值范围<br>字符型数据赋给整型变量时，将字符的ASCII码值赋给整型变量<br>将一个占字节多的整型数据赋给一个占字节少的整型变量或字符型变量时，只将其低字节原封不动地送到被赋值的变量(即发生截断)</p>
<p>提升排名：long double&gt;double&gt;float&gt;ulong&gt;long&gt;uint&gt;int(short和char一定会自动转为int)</p>
<p>转换需注意：小数转整数时直接丢弃小数部分，超过6位的整数转小数会丢失精度</p>
<h4 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h4><p>通过宏来实现，宏定义于stdarg.h<br>包括va_list类型(列表指针)，va_start,va_arg,va_end三个宏<br>使用时，需要有一个参数来确定个数，然后在个数后面用···来省略可变参数<br>函数体中，定义一个va_list变量，调用va_start(va_list变量,个数)确定参数列表<br>调用va_arg(va_list变量,位置)获取对于位置的参数参数，从0开始<br>使用完，需要调用va_end(va_list变量)删除参数列表</p>
<p>需要注意的是从···开始便全部属于参数列表部分，确定参数列表时无法跳过前面的<br>且参数列表时没确定类型，要注意指定类型</p>
<h4 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h4><p>动态分配的内存必须被整块一起释放</p>
<p>如果不释放内存，会导致内存泄漏</p>
<p>注意不要使用超出分配内存的范围</p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>__FILE__进行编译的源文件名<br>__LINE__文件当前行号<br>__DATE__文件被编译日期<br>__TIME__文件被编译时间<br>__STDC__编译器遵循ANSI C则为1</p>
<p>宏定义的作用是代替该部分，可以当作定义、函数的调用，但是要注意替代会产生很多表达式占用空间}<br>注意：用宏定义函数的时候不加;，调用时再加;并且宏参数有副作用，对于传入x++可能会导致多次++</p>
<h1 id="undef-用于移除宏"><a href="#undef-用于移除宏" class="headerlink" title="undef 用于移除宏"></a>undef 用于移除宏</h1><h1 id="if-elif-else-endif用于条件编译"><a href="#if-elif-else-endif用于条件编译" class="headerlink" title="if #elif #else #endif用于条件编译"></a>if #elif #else #endif用于条件编译</h1><h1 id="ifdef-ifndef用于判断是否被定义"><a href="#ifdef-ifndef用于判断是否被定义" class="headerlink" title="ifdef #ifndef用于判断是否被定义"></a>ifdef #ifndef用于判断是否被定义</h1><h1 id="include-用于包含头文件"><a href="#include-用于包含头文件" class="headerlink" title="include 用于包含头文件"></a>include 用于包含头文件</h1><h1 id="error-message-用于生成错误信息"><a href="#error-message-用于生成错误信息" class="headerlink" title="error message 用于生成错误信息"></a>error message 用于生成错误信息</h1><h1 id="line-用于改变当前行数和文件名称"><a href="#line-用于改变当前行数和文件名称" class="headerlink" title="line 用于改变当前行数和文件名称"></a>line 用于改变当前行数和文件名称</h1><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>&lt;&gt;在标准位置查找 “”先在当前位置查找再到标准位置查找</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>相当于其他设备输入/出的缓冲区设备会根据这个缓冲区的内容进行对应操作<br>访问流时均用FILE*类型</p>
<p>stdin为标准输入流(键盘，即键盘输入后加上回车的所有内容)<br>stdout为标准输出流(屏幕)<br>stderr为标准错误流(屏幕)<br>还有文件io流</p>
<p>格式分为字符流，二进制流</p>
<p>EOF为结尾标志</p>
<p>fflush清空流(让对应流强制操作)<br>如输入流强制输入(无对象则丢失，可以用于丢掉回车(以免scanf跳过))<br>如输出流强制输出(用于多线程，stdout是行缓存即流遇到回车才输出，无换行此时fork则无输出)</p>
<h4 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h4><p>抽象数据类型(数据结构)<br>属性成员私有/static，操作函数公有/extern</p>
<p>操作包括：构造新对象(静态)，根据特定传入返回新对象，观察属性，修改属性</p>
<h5 id="关于RI和AF"><a href="#关于RI和AF" class="headerlink" title="关于RI和AF"></a>关于RI和AF</h5><ol>
<li><p>ADT实现者关注表示空间R(表示值rep)，使用者关注抽象空间A(抽象值) 。</p>
</li>
<li><p>R与A满足映射特点，即满足抽象值是满射但未必单射，同时表示值未必存在映射</p>
</li>
<li><p>抽象函数(AF)：R映射到A<br>AF : R → A</p>
</li>
<li><p>表示不变量(RI)：将rep值映射到布尔值</p>
<p>RI : R → boolean</p>
<ul>
<li>对于rep，当且仅当rep被AF映射到了A，RI(rep)为真</li>
<li>相当于符合了条件描述(符合AF映射条件)即合法的表示值</li>
</ul>
</li>
<li><p>AF与RI即条件都不会展示给用户</p>
</li>
</ol>
<h4 id="转跳"><a href="#转跳" class="headerlink" title="转跳"></a>转跳</h4><p>do{break;}while(0)可以用来跳出到想要的位置<br>缺点是可读性下降和增加缩进<br>goto可以避免上述用法，底层是jmp<br>goto常用于转跳到逐步处理程序中具体的一步</p>
<h1 id="—————————————————"><a href="#—————————————————" class="headerlink" title="—————————————————"></a>—————————————————</h1><h4 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h4><h5 id="K-amp-R-C"><a href="#K-amp-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h5><p>C语言由Dennis M.Ritchie在1973年设计和实现。从那以后使用者逐渐增加。到1978年Ritchie和Bell实验室的另一位程序专家Kernighan合写了著名的《TheC ProgrammingLanguage》，将C语言推向全世界，许多国家都出了译本，国内有一些C语言书就是这本书的翻译或者编译，由这本书定义的C语言后来被人们称作K&amp;R C</p>
<h5 id="ANSI-C"><a href="#ANSI-C" class="headerlink" title="ANSI C"></a>ANSI C</h5><p>由于C语言被各大公司所使用(包括当时处于鼎盛时期的 IBM PC)</p>
<p>因此到了 1989 年，C语言由美国国家标准协会(ANSI)进行了标准化，此时C语言又被称为ANSI C</p>
<h5 id="C89-C90"><a href="#C89-C90" class="headerlink" title="C89/C90"></a>C89/C90</h5><p>ANSI C 被国际标准化组织 ISO 给采纳，C语言在 ISO 中有了一个官方名称——ISO/IEC 9899: 1990，简称为C89/C90<br>中国国家标准GB/T 15272-94是国际ISO标准的中文翻译<br>9899 是C语言在 ISO 标准中的代号，像 C++在 ISO 标准中的代号是14882，冒号后面表示当前修订好的版本</p>
<p>ISO C与ANSI C标准内容基本相同，主要是格式组织不一样，所以对于C标准，可以称为ANSI C，也可以说是ISO C，或者ANSI/ISO C<br>C89/C90为 K&amp;R C 的一个超集(即K&amp;R C是此标准C的一个子集)，把后来引入的许多非官方特性也一起整合了进去，不过K&amp;R的语法形式仍然兼容</p>
<p>更新内容<br>指向 void 的指针<br>定义了 C 标准库<br>新的预处理命令和特性<br>函数原型(prototype)<br>新关键字：const、volatile、signed<br>宽字符、宽字符串和多字节字符(国际字符集)<br>转化规则、声明、类型检查的改变</p>
<h5 id="C95"><a href="#C95" class="headerlink" title="C95"></a>C95</h5><p>对C89/C90的修订和扩充，不属于真正的标准C95 的主要改动</p>
<p>更新内容<br>新标准头文件(iso646.h、wctype.h、wchar.h)<br>新标记(token)和宏(macro<br>新的 printf/scanf 系列函数的格式符<br>增加了大量的宽字符和多字节字符函数、常数和类型</p>
<h5 id="C99"><a href="#C99" class="headerlink" title="C99"></a>C99</h5><p>ISO/IEC 9899: 1999，简称为 C99</p>
<p>到目前为止，很少有C语言编译器是完整支持 C99 的。像主流的 <a href="http://c.biancheng.net/gcc/">GCC</a> 以及 Clang 编译器都能支持高达90%以上，而微软的 Visual Studio 2015 中的C编译器只能支持到 70% 左右</p>
<p>更新内容<br>复数<br>内联函数<br>指定成员的初始化器<br>支持不定参数个数的宏定义<br>整数类型扩展(长整型)<br>变长数组<br>Boolean 类型<br>非英语字符集的更好支持(复合字面量)<br>浮点类型的更好支持(对IEEE754浮点数的改进)<br>提供全部类型的数学函数<br>C++ 风格注释(//)</p>
<h5 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h5><p>2007 年，C语言标准委员会又重新开始修订C语言，到了 2011 年正式发布了 ISO/IEC 9899: 2011，简称为C11</p>
<p>更新内容<br>字节对齐说明符<br>泛型机制(generic selection)<br>对多线程的支持<br>静态断言<br>原子操作<br>对 Unicode 的支持</p>
<h5 id="C17-C18"><a href="#C17-C18" class="headerlink" title="C17/C18"></a>C17/C18</h5><p>ISO/IEC 9899:2018，简称为C17/C18</p>
<p>更新内容<br>C17 没有引入新的语言特性，只对 C11 进行了补充和修正</p>
<h5 id="C2x"><a href="#C2x" class="headerlink" title="C2x"></a>C2x</h5><p>下一个版本的 C 标准，预计将于2022年12月1日完成。</p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/2022/03/19/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-与C的区别"><a href="#C-与C的区别" class="headerlink" title="C++与C的区别"></a>C++与C的区别</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>创建源文件是.cpp 文件，头文件依旧是.h文件</p>
<p>包含头文件的方式<br>自己的头文件：没有任何区别<br>库目录：可以采用原来方式，也可以去掉.h 在前面加个c，如#include \<cstring\></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>C语言同一个作用域下不允许定义相同的标识符，C++引入命名空间可以增加<strong>标识符</strong>的使用率</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.基本创建空间方法</span></span><br><span class="line"><span class="keyword">namespace</span> 空间名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.访问命名空间中的东西</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//作用域分辨符::用于标识空间名和类名，默认标识全局变量</span></span><br><span class="line">	空间名::a=<span class="number">1001</span>;</span><br><span class="line">    空间名::<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.using语法</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 空间名;   <span class="comment">//可以省略当前的空间名，但只在当前作用域下有效且再用using只能更换无法取消</span></span><br></pre></td></tr></table></figure>
<p>空间名的嵌套与其内容访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> aa=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> bb=<span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">A::B::bb=<span class="number">1001</span>;		</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A::B;</span><br><span class="line">bb=<span class="number">1002</span>;</span><br></pre></td></tr></table></figure>
<h2 id="基本输入和输出"><a href="#基本输入和输出" class="headerlink" title="基本输入和输出"></a>基本输入和输出</h2><p>iostream C++标准输入输出流的头文件为#include \<iostream\><br>输出: cout&lt;&lt; 做输出，支持C语言的<strong>格式控制字符</strong><br>输入: cin&gt;&gt;做输入<br>注意：对象cout,cin和重载运算符&lt;&lt;,&gt;&gt;在std空间中，需要using namespace std;或者加上std::前缀<br>由于C++标准库中的标准函数与标准类都在std中定义，所以一般使用using语法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;  一般都是写在这里，避免std的前缀使用</span></span><br><span class="line"><span class="comment">//输出特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testCinCout</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="comment">//1.基本变量打印不需要占位符</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ILoveyou\n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;ILoveyou\n&quot;</span>;	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">	cout &lt;&lt; a;</span><br><span class="line">	<span class="comment">//2.一次性打印多个数据</span></span><br><span class="line">	cout &lt;&lt; (<span class="type">double</span>)a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="comment">//C语言运算符的隐式转换相同</span></span><br><span class="line">	<span class="type">int</span> aa = <span class="number">1.111</span>;</span><br><span class="line">	<span class="comment">//3.C++换行  endl替换\n</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//4.避免隐式转换的后缀</span></span><br><span class="line">	<span class="type">float</span> fNum = <span class="number">0.0f</span>;  <span class="comment">//默认小数是double</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> uNum = <span class="number">1u</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> lNum = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入特性(字符串输入空格问题)</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">testStr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	cin &gt;&gt; str;			<span class="comment">//不带空格的输入</span></span><br><span class="line">	cout &lt;&lt; str;</span><br><span class="line">	<span class="comment">//fflush(stdin)					//强制清空流，已被淘汰</span></span><br><span class="line">	<span class="comment">//setbuf(stdin,NULL);			//设置流</span></span><br><span class="line">    	<span class="comment">//方法一，先判断</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>);		</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">    	<span class="comment">//方法二，使用成员函数</span></span><br><span class="line">	cin.<span class="built_in">getline</span>(str, <span class="number">10</span>);		<span class="comment">//gets_s(str, 10);</span></span><br><span class="line">	cout.<span class="built_in">write</span>(str, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h2><ul>
<li><p>bool类型</p>
<p>大小为1Byte<br>值只为0或1或称false和true<br>若用不为0的数赋值，则均保存为1</p>
</li>
<li><p>引用类型</p>
<p>理解为起别名<br>一般用于：<br>函数参数类型(防止拷贝产生)<br>函数返回值(增加左值使用频率)<br>不能返回局部变量引用</p>
<p>底层通过指针实现</p>
<p>左值（Lvalue）是C++中的一个基本概念，指可寻址的非只读表达式<br>反之即为右值(临时量，不可取地址)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本引用(左值引用)</span></span><br><span class="line">类型名&amp; 别名=要起别名的东西;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; b=a;  <span class="comment">//a有另一个名字叫b ，a就是b，b就是a</span></span><br><span class="line"><span class="comment">//常引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; x=<span class="number">1</span>;<span class="comment">//延长了1的声明周期</span></span><br><span class="line"><span class="comment">//右值引用 C++11</span></span><br><span class="line">类型名&amp;&amp; 别名=右值</span><br><span class="line"><span class="type">int</span>&amp;&amp; a=<span class="number">1</span>;   <span class="comment">//1就是a ，a就是1，可以进行修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动推断类型auto</p>
<p>对有赋值的变量推断类型</p>
<p>C++中淘汰了C语言用法，只有自动推断用法</p>
</li>
</ul>
<h2 id="函数思想-！！！"><a href="#函数思想-！！！" class="headerlink" title="函数思想 ！！！"></a><strong>函数思想</strong> ！！！</h2><ul>
<li><p>内敛思想 inline关键字：类似于宏，用函数直接替换调用的位置</p>
<p>短小精悍可以inline</p>
<p>在<strong>结构体或类</strong>中<strong>定义</strong>的函数默认内敛</p>
</li>
<li><p>函数重载： C++允许同名不同参数的函数存在！！！！！！！！！！</p>
<p>参数数目不同<br>参数类型不同<br>参数类型顺序不同<br>模板不同(显式调用时，一定只能调用对应的模板函数)</p>
<p>隐式使用时，优先调用类型匹配度高的<br>普通函数&gt;模板函数&gt;不适配普通函数&gt;不适配模板函数<br>注意在不适配的函数中可能存在多个可能的转换，需要自行转换</p>
</li>
<li><p>函数缺省： C++中允许给函数形参初始化</p>
<p>缺省顺序必须从右往左缺省，缺省必须连续<br>没有输入参数，使用默认的值<br>缺省类似于重载的一种综合写法</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//内联</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span>  <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int,char&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺省</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">2</span>, <span class="type">int</span> c=<span class="number">3</span>, <span class="type">int</span> d=<span class="number">4</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b + c + d &lt;&lt; endl;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="结构体区别"><a href="#结构体区别" class="headerlink" title="结构体区别"></a>结构体区别</h2><p>定义时不再需要struct关键字，直接用结构体名即可</p>
<p>C++结构体中允许函数存在<br>在结构体中声明在结构体外通过类名限定实现，也可以直接在结构体中实现</p>
<p>结构体中函数是可以直接访问数据<br>结构体中函数的调用和使用数据成员方式一样</p>
<p>在不设置权限时同C的使用方式一样<br>权限有public(默认)，protected，private</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span></span>;		<span class="comment">//在结构体中声明，在外面实现</span></span><br><span class="line">	<span class="comment">//通过外部函数修改数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">getAge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;<span class="comment">//不限制则默认当前空间MM下的age（即直接访问）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体名限定，就是告诉别人这个函数来自哪里</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::printData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态内存申请"><a href="#动态内存申请" class="headerlink" title="动态内存申请"></a>动态内存申请</h2><p>new(申请)和delete(释放)<br>注意：仍需改为空指针</p>
<p>于C对比：<br>malloc 内存是在堆区<br>new 内存是自由存储区</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//一般申请</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testOneMemory</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//申请不做初始化</span></span><br><span class="line">	<span class="type">int</span>* pInt = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	<span class="comment">//申请内存做初始化  ()给单个数据初始化</span></span><br><span class="line">	<span class="type">int</span>* pNum = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">134</span>);</span><br><span class="line">	cout &lt;&lt; *pNum &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">delete</span> pChar;</span><br><span class="line">	pChar = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">delete</span> pNum;</span><br><span class="line">	pNum = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组申请</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testArrayMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不带初始化</span></span><br><span class="line">	<span class="type">int</span>* pInt = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];		<span class="comment">//等效产生了int pInt[3]的数组，3可以用变量代替</span></span><br><span class="line">	<span class="comment">//带初始化的  一堆数据用 &#123;&#125;</span></span><br><span class="line">	<span class="type">int</span>* pNum = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="comment">//数组的释放 要[]不需要大小</span></span><br><span class="line">	<span class="keyword">delete</span>[] pNum;</span><br><span class="line">	<span class="keyword">delete</span>[] pInt;  </span><br><span class="line">	pInt = <span class="literal">nullptr</span>;</span><br><span class="line">    pNum = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MM</span> &#123;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体申请</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStructMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不带初始化</span></span><br><span class="line">	MM* pMM = <span class="keyword">new</span> MM;</span><br><span class="line">    <span class="keyword">delete</span> pMM;</span><br><span class="line">    <span class="comment">//带初始化则类似数组，因为也是一堆数据</span></span><br><span class="line">    pMM = <span class="keyword">new</span> MM&#123;&#125;;</span><br><span class="line">	<span class="comment">//结构体中指针要做二次申请，才能strcpy，或者赋值</span></span><br><span class="line">	pMM-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">strcpy_s</span>(pMM-&gt;name,<span class="number">20</span>, <span class="string">&quot;丽丝&quot;</span>);</span><br><span class="line">	<span class="comment">//多次申请的顺序和释放顺序是相反</span></span><br><span class="line">	<span class="keyword">delete</span>[] pMM-&gt;name;</span><br><span class="line">	<span class="keyword">delete</span> pMM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>先申请一段内存，后续再分配内存则从这里分配，便于综合管理内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMemory</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* memorySum = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">//之后申请的所有内存源自于memorySum</span></span><br><span class="line">	<span class="type">int</span>* pNum = <span class="built_in">new</span>(memorySum) <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="comment">//char* pstr = new(pNum + 3) char[20]&#123; &quot;ILoveyou&quot; &#125;;//和下面是等效的</span></span><br><span class="line">	<span class="type">char</span>* pstr = <span class="built_in">new</span>(memorySum + <span class="number">12</span>) <span class="type">char</span>[<span class="number">20</span>]&#123; <span class="string">&quot;ILoveyou&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//释放只用delete内存池</span></span><br><span class="line">	memorySum = <span class="literal">nullptr</span>;</span><br><span class="line">    pstr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] memorySum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>C++的\<string\>库区别于与C语言\<string.h\><br>string是一个类，在std空间中</p>
<p>string类包含的函数</p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/basic-string-class?view=msvc-170">basic_string 类 | Microsoft Docs</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>	<span class="comment">//string.h和cstring是一样</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;ILoveyou&quot;</span>; </span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;ILoveyou&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> string cstr;<span class="comment">//设置为不可修改</span></span><br><span class="line">    <span class="comment">//一般没有长度限定，在你使用范围下</span></span><br><span class="line">	string str = <span class="string">&quot;2333333333333333333333333333333333333333333333333333333333333&quot;</span>;</span><br><span class="line">    <span class="comment">//可以使用基本输入输出</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//部分操作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">operatorString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">	string str2 = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">	string str3 = str2;<span class="comment">//拷贝内容赋值</span></span><br><span class="line">	cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	string str4 = str1 + str2;<span class="comment">//等效: string str4=str1.append(str2);</span></span><br><span class="line">	<span class="comment">//可以使用&gt;  &lt; != ==直接比较</span></span><br><span class="line">	<span class="comment">//或者使用str1.compare(str2)  0 -1 1</span></span><br><span class="line">    str1.<span class="built_in">c_str</span>();<span class="comment">//转化为c风格字符串</span></span><br><span class="line">    str1.<span class="built_in">data</span>();<span class="comment">//转为不带\0的字符串(c++11前,之和和上相同)</span></span><br><span class="line">    <span class="built_in">to_string</span>(<span class="number">1234</span>);<span class="comment">//把数字转换为相应的字符串</span></span><br><span class="line">    str.<span class="built_in">size</span>();<span class="comment">//长度</span></span><br><span class="line">    strEmpty.<span class="built_in">empty</span>();<span class="comment">//是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++类型转换，专人做专事，传闻中C++中的更为安全。</p>
<p>const_cast&lt;要转的类型&gt;</p>
<p>static_cast&lt;要转的类型&gt;：带编译时进行类型安全检查的类型转换</p>
<p>dynamic_cast&lt;要转的类型&gt;：带运行时进行类型安全检查的类型转换</p>
<p>reinterpret_cast&lt;要转的类型&gt;：和普通强制类型转换没多大区别，用于标准化代码，不改变参数const属性</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>空指针 NULL 修改为 nullptr</p>
<p>常引用左边的限定一定要比右边高，原因是底层const指针不能给普通指针赋值(初始化)</p>
<p>类型起别名除了typedef还可以使用using，即 using 新名=旧名</p>
<p>C++11新语法<strong>for(auto v : 容器)</strong>其中auto是value_type(可以加&amp;)，使用该语法的容器要有begin和end函数且重载了迭代器的!=和++操作，另外容器元素可以解引用</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类和其对象的  创建、定义、使用与结构体相同，只是默认权限不一样<br>类中存在默认的构造函数，拷贝构造函数，运算符(=,&amp;,const &amp;)重载函数，析构函数</p>
<p>空的类和结构体占用1字节</p>
<p><strong>权限限定的作用</strong></p>
<p>类外只能访问public属性下面的 东西，习惯把 public属性 叫做类外的接口<br>类外访问 类中的数据，只能通过对象访问，static成员除外<br>protected和private 类外不可以访问 ，需要通过接口间接访问<br>protected和private 在继承的时候有区别 </p>
<h2 id="权限下的成员访问-修改"><a href="#权限下的成员访问-修改" class="headerlink" title="权限下的成员访问(修改)"></a>权限下的成员访问(修改)</h2><p>公有接口传参的方式初始化数据</p>
<p>公有接口返回值的方式初始化数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//传参</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initData</span><span class="params">(string name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">		m_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回引用</span></span><br><span class="line">	<span class="function">string&amp; <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">getAge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_name=<span class="string">&quot;默认值&quot;</span>;<span class="comment">//默认初始化//不做初始化是一个垃圾值</span></span><br><span class="line">	<span class="type">int</span> m_age=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MM girl;</span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">	girl.<span class="built_in">initData</span>(<span class="string">&quot;girl&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	girl.<span class="built_in">print</span>();</span><br><span class="line">	<span class="comment">//修改数据</span></span><br><span class="line">	MM mm;</span><br><span class="line">	mm.<span class="built_in">getName</span>() = <span class="string">&quot;mm&quot;</span>;</span><br><span class="line">	mm.<span class="built_in">getAge</span>() = <span class="number">18</span>;</span><br><span class="line">	mm.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的构造和析构"><a href="#类的构造和析构" class="headerlink" title="类的构造和析构"></a>类的构造和析构</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数名和类名相同，无参数无返回值<br>任何类中都存在一个默认的构造函数，当我们自己写了构造函数，默认的构造函数就会废用，可以用default使其启用，可以用delete来手动弃用<br>构造函数在定义对象的时候自动调用，可以重载和缺省，并且允许构造函数调用另一个构造函数(必须使用参数初始化列表(构造函数特有))<br>C++11支持委托构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//初始化参数列表的写法</span></span><br><span class="line">string girlName = <span class="string">&quot;Baby&quot;</span>;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Student() = delete;     删掉默认的构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>()=<span class="keyword">default</span>;<span class="comment">//启用：默认的无参构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>(string mname=<span class="string">&quot;&quot;</span>, <span class="type">int</span> mage=<span class="number">18</span>) :<span class="built_in">name</span>(mname), <span class="built_in">age</span>(mage) &#123;&#125;<span class="comment">//初始化列表，可以换顺序</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">int</span> mage) :<span class="built_in">name</span>(girlName), <span class="built_in">age</span>(mage) &#123;&#125;<span class="comment">//缺省</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">int</span> mage=<span class="number">18</span>,string mname=<span class="string">&quot;&quot;</span>):<span class="built_in">Student</span>()&#123;&#125;<span class="comment">//委托构造</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>函数名: ~类名，无参数无返回值<br>任何类中都存在一个默认的析构函数，在该类对象的生命周期结束时自动调用(无需也禁止手动调用)，便于处理指针释放等问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(<span class="type">const</span> <span class="type">char</span>* pstr, <span class="type">int</span> age) :<span class="built_in">age</span>(age) </span><br><span class="line">	&#123;</span><br><span class="line">		str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(pstr) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy_s</span>(str,<span class="built_in">strlen</span>(pstr)+<span class="number">1</span>, pstr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//void freeMemory() </span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	delete[] str;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	~<span class="built_in">MM</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">char</span>* str;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">MM::~<span class="built_in">MM</span>()   </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我叫做析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造也是构造函数的一种，用来通过一个对象去创建另一个对象<br>任何类中都存在一个默认的拷贝构造函数，当我们自己写了拷贝构造函数，默认的拷贝构造函数就会废用，特点是引用传入的参数<br>当存在匿名对象(右值)赋值操作的时候，必须要const修饰</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MM</span>(<span class="type">const</span> MM&amp; mm)			 <span class="comment">//MM girl(mm);这个就是默认的拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		name = mm.name;  <span class="comment">//girl.name=mm.name</span></span><br><span class="line">		age = mm.age;	 <span class="comment">//girl.age=mm.age</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MM <span class="title">mm</span><span class="params">(<span class="string">&quot;mm&quot;</span>, <span class="number">18</span>)</span></span>;	<span class="comment">//普通构造</span></span><br><span class="line">	<span class="function">MM <span class="title">girl</span><span class="params">(mm)</span></span>;        <span class="comment">//拷贝构造</span></span><br><span class="line">	MM girl2 = mm;		<span class="comment">//拷贝构造的隐式调用(同理普通构造也有隐式转换)</span></span><br><span class="line">	MM girl3;</span><br><span class="line">	girl3 = mm;			<span class="comment">//拷贝构造的隐式调用的运算符重载		</span></span><br><span class="line">	MM temp;</span><br><span class="line">	temp = <span class="built_in">MM</span>(<span class="string">&quot;匿名&quot;</span>, <span class="number">18</span>);<span class="comment">//拷贝构造传入常量，类必须有const限定</span></span><br><span class="line">	MM temp2 = <span class="built_in">MM</span>(<span class="string">&quot;匿名&quot;</span>, <span class="number">199</span>);<span class="comment">//同上</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝: 默认的拷贝构造叫做浅拷贝</p>
<p>深拷贝: 拷贝构造函数中做了new内存操作，并且做拷贝赋值的操作<br>深拷贝用于针对指针，由于是赋值操作，浅拷贝直接复制指针(地址)不是复制其内容，所以需要申请内存然后再拷贝内容，注意析构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(<span class="type">const</span> <span class="type">char</span>* mname, <span class="type">int</span> age) :<span class="built_in">age</span>(age)</span><br><span class="line">	&#123;</span><br><span class="line">		name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(mname) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy_s</span>(name, <span class="built_in">strlen</span>(mname) + <span class="number">1</span>, mname);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MM</span>(<span class="type">const</span> MM&amp; object) <span class="comment">//深拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">		name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(object.name) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy_s</span>(name, <span class="built_in">strlen</span>(object.name) + <span class="number">1</span>, object.name);</span><br><span class="line">		age = object.age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MM</span>() </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造和析构顺序问题"><a href="#构造和析构顺序问题" class="headerlink" title="构造和析构顺序问题"></a>构造和析构顺序问题</h2><p>普通对象的构造顺序和析构顺序是相反</p>
<p>new出来的对象，delete相当于立刻结束生命周期所以会直接调用析构函数</p>
<p>static对象，当程序关闭的时候，生命周期才结束，所以是最后释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name=<span class="string">&quot;x&quot;</span>) :<span class="built_in">name</span>(name) &#123;</span><br><span class="line">		cout &lt;&lt; name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MM</span>()&#123;</span><br><span class="line">		cout &lt;&lt; name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">MM <span class="title">mm1</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;			<span class="comment">//A</span></span><br><span class="line">		<span class="function"><span class="type">static</span> MM <span class="title">mm2</span><span class="params">(<span class="string">&quot;B&quot;</span>)</span></span>;		<span class="comment">//B   程序关闭时候才自动死亡，最后析构</span></span><br><span class="line">		MM* p3 = <span class="keyword">new</span> <span class="built_in">MM</span>(<span class="string">&quot;C&quot;</span>);	<span class="comment">//C</span></span><br><span class="line">		MM mm4[<span class="number">4</span>];				<span class="comment">//xxxx</span></span><br><span class="line">		<span class="keyword">delete</span> p3;				<span class="comment">//C  delete 直接调用析构</span></span><br><span class="line">		p3 = <span class="literal">nullptr</span>;						</span><br><span class="line">	&#125;<span class="comment">//xxxxAB 离开生命周期空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//ABCxxxxCxxxxAB 程序结束</span></span><br></pre></td></tr></table></figure>
<h1 id="特殊成员"><a href="#特殊成员" class="headerlink" title="特殊成员"></a>特殊成员</h1><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><ul>
<li><p>const数据成员</p>
<p>const类型变量表示创建一个只读模式<br>初始化常数据成员必须采用初始化参数列表</p>
</li>
<li><p>const成员函数</p>
<p>const写在函数()后面<br>常成员函数表示不能够修改数据成员<br>同名常成员函数可以与普通函数同时存在<br>普通对象优先调用普通函数</p>
</li>
<li><p>const对象</p>
<p> const修饰的对象<br>常对象只能调用常成员函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> num) :<span class="built_in">num</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		MM::name = name;  <span class="comment">//可以用，也可以不用初始化列表</span></span><br><span class="line">		<span class="comment">//MM::num = 1001;  必须要用初始化参数列表方式初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = <span class="string">&quot;修改&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//常成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span><span class="type">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//name = &quot;修改&quot;;   错误，常成员函数不能修改数据</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> num;		<span class="comment">//const数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MM <span class="title">mm</span><span class="params">(<span class="string">&quot;对象&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	mm.<span class="built_in">print</span>();				<span class="comment">//普通对象调用普通函数</span></span><br><span class="line">	<span class="function"><span class="type">const</span> MM <span class="title">cmm</span><span class="params">(<span class="string">&quot;常对象&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cmm.<span class="built_in">print</span>();			<span class="comment">//常对象调用常成员函数</span></span><br><span class="line">	<span class="comment">//cmm.printData();		//错误!,常对象只能调用普通函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h2><p>static成员是不属于对象，是属于类的，意味着是所有对象共有的，调用可以不需要对象(当然可以用对象调用)<br>static成员依旧受权限限定</p>
<ul>
<li><p>static数据成员</p>
<p><strong>必须在类外初始化且只初始化一次</strong>，不再需要static修饰，但是需要类名限定</p>
</li>
<li><p>static成员函数</p>
<p>static写在函数类型前面即可<br>调用非静态成员 必须要指定对象 因为类共用无法确定指定空间</p>
</li>
<li><p>static对象</p>
<p>最后释放的</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name=<span class="string">&quot;&quot;</span>):<span class="built_in">name</span>(name) </span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printMM</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//必须类外初始化，且不再需要static修饰，但是需要类名限定</span></span><br><span class="line"><span class="type">int</span> MM::num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::printMM</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//调用非静态数据成员，必须要指定对象</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; name &lt;&lt; endl;  当这个函数不采用对象去调用，name没有来源</span></span><br><span class="line">	<span class="comment">//静态调用静态，没什么要求</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态数据成员访问，可以不需要对象</span></span><br><span class="line">	cout &lt;&lt; MM::num &lt;&lt; endl;	 <span class="comment">//此时num等于1</span></span><br><span class="line">	<span class="function">MM <span class="title">mm</span><span class="params">(<span class="string">&quot;mm&quot;</span>)</span></span>;				 <span class="comment">//此时num等于2</span></span><br><span class="line">	<span class="comment">//静态数据成员可以通过空间限制或者对象去访问     </span></span><br><span class="line">	MM array[<span class="number">3</span>];			     <span class="comment">//5</span></span><br><span class="line">	MM* p = <span class="keyword">new</span> <span class="built_in">MM</span>(<span class="string">&quot;newMM&quot;</span>);	 <span class="comment">//6</span></span><br><span class="line">	cout &lt;&lt; MM::num &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p-&gt;num &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; mm.num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//静态成员函数</span></span><br><span class="line">	MM::<span class="built_in">printMM</span>();</span><br><span class="line">	mm.<span class="built_in">printMM</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元表示占据空间，赋予对象具有打破类的权限定(无视权限)</p>
<ul>
<li><p>友元函数，函数占据空间</p>
<p>友元函数不属于任何类(类内或类外外都可定义)，但是占据类空间可以打破权限<br>注意友元函数占据的类A是另外一个类B的友元(即该类A有占据了类B)，友元函数不可以直接类B，可以通过A间接访问B</p>
</li>
<li><p>友元类 ，该类占据空间</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//友元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GG</span>;<span class="comment">//表示GG占据MM空间，即可以无视MM权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">hi</span><span class="params">()</span></span>;<span class="comment">//占据MM空间</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GG</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printMM</span><span class="params">(MM&amp; mm)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; mm.name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; mm.age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="title">hi</span><span class="params">()</span></span>;<span class="comment">//占据GG空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hi</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//互为友元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	cout &lt;&lt; b.data &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//占据B空间</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string data=<span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		A a;</span><br><span class="line">		cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">	&#125;<span class="comment">//占据A空间</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string data = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="this指针与explicit"><a href="#this指针与explicit" class="headerlink" title="this指针与explicit"></a>this指针与explicit</h2><ul>
<li><p>explicit修饰构造函数使用，表示<strong>禁止隐式转换构造</strong></p>
</li>
<li><p>this指针</p>
<ul>
<li>避免形参名和数据成员同名，特指对象的地址(空间)</li>
<li>充当函数返回值，返回对象自身，用*this表示对象本身</li>
<li>静态成员函数中不能使用this指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">MM</span><span class="params">(<span class="type">int</span> age)</span> :age(age) &#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;<span class="comment">//禁止了MM a=5;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GG</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GG</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">initData</span><span class="params">(string name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//类名限定 帮助计算机去识别</span></span><br><span class="line">		GG::name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;<span class="comment">//这里不加限定默认优先当前空间下</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">GG&amp; <span class="title">returnGG</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>让运算符可以操作自定义类型数据，操作符重载本质是调用函数</p>
<p>写法：返回类型   operator需重载运算符(函数参数)</p>
<h2 id="友元-类成员-函数重载运算符"><a href="#友元-类成员-函数重载运算符" class="headerlink" title="友元/类成员 函数重载运算符"></a>友元/类成员 函数重载运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>) :<span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">	<span class="comment">//友元函数重载：重载操作可以突破权限(参数个数就是操作数据)</span></span><br><span class="line">	<span class="keyword">friend</span> Complex  <span class="keyword">operator</span>+ (Complex one, Complex two);</span><br><span class="line">	<span class="comment">//类成员函数重载，参数(个数等于需要的个数减一)</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt; (Complex object) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;; </span><br><span class="line">Complex  <span class="keyword">operator</span>+ (Complex one, Complex two) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(one.a + two.a, one.b + two.b);<span class="comment">//突破权限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">one</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">two</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	Complex three;</span><br><span class="line">	three = one + two;    <span class="comment">//友元函数重载的隐式调用</span></span><br><span class="line">	Complex result;</span><br><span class="line">	result = <span class="keyword">operator</span>+(one, two);<span class="comment">//显式调用</span></span><br><span class="line">	one &gt; two;<span class="comment">//类成员函数重载的隐式调用</span></span><br><span class="line">	one.<span class="keyword">operator</span>&gt;(two);<span class="comment">//显式调用，本质是类对象调用函数成员所以少一个参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊运算符重载"><a href="#特殊运算符重载" class="headerlink" title="特殊运算符重载"></a>特殊运算符重载</h2><p>>>  &lt;&lt;  重载<br>cin类型是istream类的对象，所以要采用该返回类型<br>cout类型是ostream类的对象，所以要采用该返回类型<br>因此必须采用友元函数形式重载(为了破坏封装性，建议创建类外的使用接口的普通重载)</p>
<p>++ —运算符重载<br>在()中的int表示当前运算符重载是后置操作</p>
<p>文本重载(新标准)</p>
<p>其他运算符<br>= () -&gt; [] 只能采用类的成员函数形式重载<br>.  .*  ?:   :: 不能重载</p>
<p>new重载，尽量用原生的即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> istream&amp;  <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MM&amp; mm);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp;  <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MM&amp; mm);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name ,<span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MM&amp; mm)</span><br><span class="line">	&#123;</span><br><span class="line">		in &gt;&gt; mm.name &gt;&gt; mm.age;</span><br><span class="line">		<span class="keyword">return</span> in;<span class="comment">//返回流对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp;  <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MM&amp; mm) </span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; mm.name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; mm.age &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> out;<span class="comment">//返回流对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	MM <span class="keyword">operator</span>++(<span class="type">int</span>)	<span class="comment">//int充当标记，无用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MM</span>(name,age++);<span class="comment">//注意返回的是右值</span></span><br><span class="line">	&#125;</span><br><span class="line">	MM <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MM</span>(name, ++age);<span class="comment">//注意返回的是右值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载对象的隐式转换</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//文本重载</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>  <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _h(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num) <span class="comment">//1_h换成秒</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">60</span> * <span class="number">60</span>*num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>  <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _min(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num)<span class="number">1</span>_min换成秒</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">60</span> * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h1><h2 id="其中一个类的对象为数据成员"><a href="#其中一个类的对象为数据成员" class="headerlink" title="其中一个类的对象为数据成员"></a>其中一个类的对象为数据成员</h2><p>构造函数必须采用初始化参数列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boy</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string boyName, <span class="type">int</span> boyAge, string mmName) :<span class="built_in">boy</span>(boyName, boyAge) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mmName = mmName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MM</span>(string mmName) :<span class="built_in">mmName</span>(mmName), <span class="built_in">boy</span>(<span class="string">&quot;默认&quot;</span>, <span class="number">18</span>) </span><br><span class="line">	&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string mmName;</span><br><span class="line">	Boy boy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MM <span class="title">mm</span><span class="params">(<span class="string">&quot;boy&quot;</span>, <span class="number">18</span>, <span class="string">&quot;mm&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类中类"><a href="#类中类" class="headerlink" title="类中类"></a>类中类</h2><p>类(A)中类(B)，声明(公有)类B的变量需要类A空间名限定<br>意义在于，空间的封装性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	Node* next;</span><br><span class="line">	Node()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;next = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	Node(<span class="type">int</span> data) </span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;next = nullptr;</span><br><span class="line">		this-&gt;data = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	List() </span><br><span class="line">	&#123;</span><br><span class="line">		headNode = new Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span> data)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		Node* newNode = new Node(data);</span><br><span class="line">		newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">		headNode-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	Node* headNode;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">public:</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">iterator</span> </span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	public:</span><br><span class="line">		iterator(Node* pMove=nullptr) :pMove(pMove) &#123;&#125;	</span><br><span class="line">		<span class="type">void</span> operator=(Node* pMove) </span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;pMove = pMove;</span><br><span class="line">		&#125;</span><br><span class="line">		iterator operator++()</span><br><span class="line">		&#123;</span><br><span class="line">			pMove = pMove-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> iterator(pMove);</span><br><span class="line">		&#125;</span><br><span class="line">		Node*&amp; operator*() </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> pMove;</span><br><span class="line">		&#125;</span><br><span class="line">	protected:</span><br><span class="line">		Node* pMove;</span><br><span class="line">	&#125;;</span><br><span class="line">	Node* <span class="title function_">begin</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	Node* <span class="title function_">end</span><span class="params">()</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类中枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">time</span> &#123;</span>first,second&#125;;</span><br><span class="line">protected:</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">date</span> &#123;</span>mon,sur,tus&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	List <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>.push_front(i);</span><br><span class="line">	&#125;</span><br><span class="line">	List::iterator iter;</span><br><span class="line">	<span class="keyword">for</span> (iter = <span class="built_in">list</span>.begin(); iter != <span class="built_in">list</span>.end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter)-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; A::date::mon &lt;&lt; endl;//不可访问 //类中的枚举类型受权限限定</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; A::time::first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的继承和派生"><a href="#类的继承和派生" class="headerlink" title="类的继承和派生"></a>类的继承和派生</h1><p>继承：子类中没有产生新的属性或者行为<br>派生：派生类中有新的属性和行为产生</p>
<h2 id="继承方式与权限问题"><a href="#继承方式与权限问题" class="headerlink" title="继承方式与权限问题"></a>继承方式与权限问题</h2><p>单继承: 只有一个父类<br>多继承: 两个或者两个以上的父类</p>
<p>继承的实质：父类的全部数据和成员在子类中都有一份<br>子类内存分别   由父类和子类自己的成员  的连续内存组成(细看构造顺序)<br>注意权限，看上去有4种权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类   基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parent</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//子类   派生类</span></span><br><span class="line"><span class="comment">//公有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span>:<span class="keyword">public</span> parent&#123;&#125;;</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son2</span>:<span class="keyword">protected</span> parent&#123;&#125;;</span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son3</span>:<span class="keyword">private</span> parent&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>权限问题: 继承方式用于增强父类属性在子类中的权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">原权限</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public继承后</td>
<td>public</td>
<td>protected</td>
<td>不可直接访问</td>
</tr>
<tr>
<td style="text-align:left">protected继承后</td>
<td>protected</td>
<td>protected</td>
<td>不可直接访问</td>
</tr>
<tr>
<td style="text-align:left">private继承后</td>
<td>private</td>
<td>private</td>
<td>不可直接访问</td>
</tr>
</tbody>
</table>
</div>
<h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p>父类的属性是通过父类的构造函数初始化<br>没有自行调用时，自动调用父类无参构造<br>自行调用时，父类必须采用初始化参数列表的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Parent</span>(string FName, string SName):<span class="built_in">FName</span>(FName), <span class="built_in">SName</span>(SName)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string FName;</span><br><span class="line">	string SName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;&#125;<span class="comment">//自动调用无参    </span></span><br><span class="line">	<span class="built_in">Son</span>(string FName, string SName, string sonSName) :<span class="built_in">Parent</span>(FName,SName)<span class="comment">//自行初始化列表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;sonFName = FName;</span><br><span class="line">		<span class="keyword">this</span>-&gt;sonSName = sonSName;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string sonFName;</span><br><span class="line">	string sonSName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="继承中同名问题"><a href="#继承中同名问题" class="headerlink" title="继承中同名问题"></a>继承中同名问题</h2><p>数据成员或成员函数同名：没有限定，在空间中就近原则</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;dad&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> :<span class="keyword">public</span> MM </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Girl</span>(string name, <span class="type">int</span> age) :<span class="built_in">MM</span>(<span class="string">&quot;dad&quot;</span>, <span class="number">28</span>), <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;son&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Girl  <span class="title">girl</span><span class="params">(<span class="string">&quot;girl&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	girl.<span class="built_in">print</span>();</span><br><span class="line">	<span class="function">MM <span class="title">mm</span><span class="params">(<span class="string">&quot;mm&quot;</span>, <span class="number">28</span>)</span></span>;</span><br><span class="line">	mm.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了避免孙类重复继承父类<br>解决：浪费空间和二义性问题<br>底层原理和编译器有关，一般通过指向虚基类表的虚基类指针实现</p>
<p>虚继承的构造了指针，内容在子类成员后面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a) :<span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b) :<span class="built_in">A</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> c) :<span class="built_in">A</span>(a),<span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> C, <span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>() :<span class="built_in">B</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">C</span>(<span class="number">3</span>, <span class="number">4</span>) ,<span class="built_in">A</span>(<span class="number">999</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//只有一个a 只有一份</span></span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; C::a &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">printC</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造顺序问题"><a href="#构造顺序问题" class="headerlink" title="构造顺序问题"></a>构造顺序问题</h2><p>如果一个类含有多个基类，则按照它们在派生列表中出现的顺序从左向右进行检查<br>遇到虚基类则构造，直到没有虚基类才开始构造实基类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>:<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="keyword">public</span>:<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="keyword">public</span>:<span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123; <span class="keyword">public</span>:<span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;D&quot;</span>; &#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> :<span class="keyword">public</span> A, <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123; <span class="keyword">public</span>:<span class="built_in">E</span>() &#123; cout &lt;&lt; <span class="string">&quot;E&quot;</span>; &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> :<span class="keyword">public</span> C, <span class="keyword">virtual</span> <span class="keyword">public</span> D &#123; <span class="keyword">public</span>:<span class="built_in">F</span>() &#123; cout &lt;&lt; <span class="string">&quot;F&quot;</span>; &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> :<span class="keyword">public</span> E, <span class="keyword">virtual</span> <span class="keyword">public</span> F &#123; <span class="keyword">public</span>:<span class="built_in">G</span>() &#123; cout &lt;&lt; <span class="string">&quot;G&quot;</span>; &#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G g;<span class="comment">//BDCFAEG</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h1><h2 id="虚函数和虚函数表"><a href="#虚函数和虚函数表" class="headerlink" title="虚函数和虚函数表"></a>虚函数和虚函数表</h2><p>用 virtual 修饰的成员函数叫做虚函数<br>增加一个指向虚函数表首地址的指针</p>
<p>虚函数表：<br>同一个类的所有对象共有同一张虚函数表<br>虚函数表由编译器在编译时生成，保存在可执行文件的只读数据段.rodata中(全局数据区)(静态区)</p>
<p>当子类中实现了一个与父类的成员函数原型完全相同的函数时，即重写了该函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;虚函数1&quot;</span>&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;虚函数2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::print3</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;虚函数3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MM mm;</span><br><span class="line">	<span class="comment">//虚函数表 </span></span><br><span class="line">	<span class="type">int</span>** vptr = (<span class="type">int</span> **)&amp;mm;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PF)</span><span class="params">()</span></span>;<span class="comment">//命名PF为 void返回值，无传参的 函数指针类型</span></span><br><span class="line">	PF func = (PF)vptr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">func</span>();		<span class="comment">//调用第一个虚函数</span></span><br><span class="line">	func = (PF)vptr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">func</span>();		<span class="comment">//调用第二个虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态与非正常指针"><a href="#多态与非正常指针" class="headerlink" title="多态与非正常指针"></a>多态与非正常指针</h2><p>多态: 同一种行为(调用)导致的不同的结果</p>
<p>多态的必要性原则：<br>必须父类存在虚函数<br>子类必须采用public继承<br>必须存在指针的引用(使用)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WC1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;男人A上厕所&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WC2</span><span class="params">()</span><span class="comment">//父类必须要有virtual</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;男人B上厕所&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span>:<span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WC1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;女人A上厕所&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WC2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;女人B上厕所&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//正常访问不存在多态</span></span><br><span class="line">	Man man;</span><br><span class="line">	man.<span class="built_in">WC1</span>();</span><br><span class="line">	man.<span class="built_in">WC2</span>();</span><br><span class="line">	Woman woman;</span><br><span class="line">	woman.<span class="built_in">WC1</span>();</span><br><span class="line">	woman.<span class="built_in">WC2</span>();</span><br><span class="line">	Man* pm = <span class="keyword">new</span> Man;</span><br><span class="line">	pm-&gt;<span class="built_in">WC1</span>();</span><br><span class="line">	pm-&gt;<span class="built_in">WC2</span>();</span><br><span class="line">	Woman* pw = <span class="keyword">new</span> Woman;</span><br><span class="line">	pw-&gt;<span class="built_in">WC1</span>();</span><br><span class="line">	pw-&gt;<span class="built_in">WC2</span>();</span><br><span class="line">	<span class="comment">//非正常指针:</span></span><br><span class="line">    <span class="comment">//1.子类对象初始化父类指针</span></span><br><span class="line">	Man* MAN = <span class="keyword">new</span> Woman;</span><br><span class="line">	<span class="comment">//有virtual看对象类型，没有virutal看指针类型</span></span><br><span class="line">	MAN-&gt;<span class="built_in">WC1</span>();			<span class="comment">//man.WC1()</span></span><br><span class="line">	MAN-&gt;<span class="built_in">WC2</span>();			<span class="comment">//woman.WC2();</span></span><br><span class="line">    <span class="comment">//2.父类对象初始化子类指针，不安全会报错</span></span><br><span class="line">    <span class="comment">//Man* WOMAN = new Man;		错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用途</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统一接口</span></span><br><span class="line"><span class="comment">//降低因为变化而要修改代码，只需采用增加代码即可满足新需求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;绘制过程&quot;</span> &lt;&lt; endl;&#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> :<span class="keyword">public</span> Shape &#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;画矩形&quot;</span> &lt;&lt; endl;&#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;画圆&quot;</span> &lt;&lt; endl;&#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span> &#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(Shape* parent)</span> </span>&#123;parent-&gt;<span class="built_in">Draw</span>();&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tool* pTool = <span class="keyword">new</span> Tool;</span><br><span class="line">	pTool-&gt;<span class="built_in">draw</span>(<span class="keyword">new</span> Circle);</span><br><span class="line">	pTool-&gt;<span class="built_in">draw</span>(<span class="keyword">new</span> Rect);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="纯虚函数和ADT"><a href="#纯虚函数和ADT" class="headerlink" title="纯虚函数和ADT"></a>纯虚函数和ADT</h2><p>纯虚函数也是虚函数只是纯虚函数是没有函数体的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">virutal <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>=<span class="number">0</span>;     <span class="comment">//在类中函数 这样写</span></span><br></pre></td></tr></table></figure>
<p>抽象类： 具有至少一个纯虚函数的类，叫做抽象类</p>
<p>抽象类不能构建对象<br>抽象类可以构建对象指针<br>纯虚函数没有被重写，无论被继承多少次，都是纯虚函数，虚函数无论被继承多少次都是虚函数</p>
<p>纯虚函数是做ADT(abstract data type 抽象数据类型)过程<br>子类想要创建对象，必须重写父类的纯虚函数<br>具有强迫性，所有子类重写的函数名必须和父类的一模一样<br>具有拓展性，可以增加别的函数和成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>= <span class="number">0</span>;&#125;;<span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testAbstract</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Parent object;  不能构建对象</span></span><br><span class="line">	Parent* parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arrayStack</span> :<span class="keyword">public</span> stack </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span>* array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚析构函数,不存在虚构造函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">parent</span>() </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;父类析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> parent </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">son</span>() </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在用子类对象初始化父类指针，父类需要虚析构函数做内存释放</span></span><br><span class="line">	parent* p = <span class="keyword">new</span> son;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;<span class="comment">//确保用的是~son()来析构</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="流！！"><a href="#流！！" class="headerlink" title="流！！"></a>流！！</h1><p>若干字节数据从一端到另一端叫做流<br>需要流对象和流操作符</p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p>需要#include \<iostream\>和using namespace std;</p>
<p>ostream类对象：<br>cout标准输出，clog标准错误输出，cerr标准错误输出(不可重定向)</p>
<p>istream类对象：<br>cin标准输入</p>
<p>字符(串)类型(不可以string)的处理方式：<br>标准输入输出流<br>cout.put()和cin.get()处理字符<br>cout.write(“”,)和cin.getline(,)处理字符串</p>
<p>流控制字符(都有对应的函数)<br>需要#include\<iomanip\>在<br>setprecision(n)设置有效位数<br>fixed结合setprecision设置精度<br>等等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testiomanip</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//格式控制  </span></span><br><span class="line">	<span class="comment">//设置格式</span></span><br><span class="line">	<span class="type">double</span> pi = <span class="number">34.12343</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;设置有效位数是:&quot;</span> &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;有效小数位:&quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout.precision(4); 所有的流控制符都会对应一个成员函数的方式</span></span><br><span class="line">	<span class="comment">//进制输出</span></span><br><span class="line">	cout &lt;&lt; hex &lt;&lt; <span class="number">32</span> &lt;&lt; endl;  <span class="comment">//十六进制</span></span><br><span class="line">	cout &lt;&lt; oct &lt;&lt; <span class="number">15</span> &lt;&lt; endl;  <span class="comment">//8进制输出</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setbase</span>(<span class="number">10</span>) &lt;&lt; <span class="number">15</span> &lt;&lt; endl; <span class="comment">//8-16</span></span><br><span class="line">    <span class="comment">//设置宽度</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;12344&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;3444&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;12344&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;3444&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//默认右对齐</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left);	<span class="comment">//ios::right</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; resetiosflags &lt;&lt; endl;取消格式控制字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>需要#include \<sstream\><br>其中包括了istringstream类和ostringstream类<br>一般用stringstream类对象</p>
<p>操作字符流<br>str();//获取字符流数据且变为string类型<br>str(const string&amp; str);//设置字符流对象的数据</p>
<p>注意：以变量类型决定流出的数据</p>
<p>用途<br>字符串转换<br>字符串分割</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//构建字符流对象</span></span><br><span class="line">	<span class="function">stringstream <span class="title">sso</span><span class="params">(string(<span class="string">&quot;ILoveyou&quot;</span>))</span></span>;</span><br><span class="line">    <span class="comment">//字符流流动到标准流对象</span></span><br><span class="line">	cout &lt;&lt; sso.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//设置字符流对象数据</span></span><br><span class="line">	sso.<span class="built_in">str</span>(<span class="string">&quot;ILoveyou&quot;</span>);</span><br><span class="line">	<span class="comment">//清除字符流对象</span></span><br><span class="line">    sso.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">//注意：以上的流操作都只是改变了流指针</span></span><br><span class="line">	<span class="comment">//而字符流在流出前，字符流指针还是会回到流的开头</span></span><br><span class="line">    <span class="comment">//同一个流多次做数据转换操作，一定做clear操作，用于覆盖数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//字符串与数字之间转换</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">1234</span>;</span><br><span class="line">	<span class="type">char</span> input[<span class="number">20</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="function">stringstream <span class="title">transs</span><span class="params">(input)</span></span>;</span><br><span class="line">	transs &lt;&lt; num;<span class="comment">//默认以字符类型流进</span></span><br><span class="line">	transs &gt;&gt; input;</span><br><span class="line">	cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//分割</span></span><br><span class="line">	<span class="function">stringstream <span class="title">sData</span><span class="params">(<span class="string">&quot;23,132,3443,54,54,65&quot;</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> numData[<span class="number">6</span>];</span><br><span class="line">	<span class="type">char</span> cData[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">			sData &gt;&gt; numData[i];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			sData &gt;&gt; numData[i] &gt;&gt; cData[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; numData[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>需要#include \<fstream\><br>其中包括了ifstream类和ofstream 类<br>一般用fstream类对象</p>
<p>打开/关闭文件:<br>open(const char* URL,ios::openmode mode);//打开<br>close();//关闭</p>
<p>读写方法<br>ios::in  读的方式打开文件<br>ios::out  写方式打开文件  具有创建功能<br>ios::app  追加模式 具有创建功能呢<br>ios::ate 追加模式，文件指针指向末尾<br>ios::trunc  具备创建功能<br>ios::nocreate  不具备创建<br>ios::noreplace 不替换  (想想C语言 w方式)<br>ios::binary 二进制的形式<br>组合<br>可读可写可创建：ios::in|ios::out|ios::trunc<br>二进制的可读可写可创建： ios::in|ios::out|ios::trunc|ios::binary</p>
<p>对于二进制方式把string写到文件需要先转换为char*<br>对于流方式，回车和换行会被忽略</p>
<p>操作<br>eof()表示指针在文件末尾<br>get()读取一个字符<br>put()写入一个字符<br>read(,)读出设定字节量<br>write(,)写入固定字节量</p>
<p>文件流出流出的指针定位<br>ifstream类的对象<br>istream&amp; seekg(long int pos);<br>istream&amp; seekg(long int pos,ios_base::seekdir position);<br>ofstream类的对象<br>ostream&amp; seekp(long int pos);<br>ostream&amp; seekp(long int pos,ios_base::seekdir position);<br>ios_base::seekdir<br>ios::beg   文件开始位置<br>ios::end   文件结束位置<br>ios::cur  文件当前位置</p>
<p>更多：<a href="https://blog.csdn.net/HPP_CSDN/article/details/108017917">(98条消息) 【C++ primer】第8章 IO库 —— iostream，fstream，stringstream_今岁成蹊的博客-CSDN博客</a></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="基本的异常处理"><a href="#基本的异常处理" class="headerlink" title="基本的异常处理"></a>基本的异常处理</h2><p>用于暂缓问题的处理，不在当前函数中处理，在他调用者中处理<br>异常一旦被抛出，不做处理，会调用默认abort终止程序</p>
<p>捕获和处理异常<br>throw 抛出异常，(可以理解为返回值，值是任何类型都可以，使我们处理异常一个参照)<br>try(检查，捕获)和catch(处理异常)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">0</span>;<span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//try 与catch必须是一起出现，并且他们&#123;&#125;不能省略</span></span><br><span class="line"><span class="comment">//一个try可以对应多个catch，但只能执行一个匹配项</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//用于检查的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">int</span>*a)&#123;&#125;&#123;</span><br><span class="line">	 <span class="comment">//用于处理的代码  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>*a)&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">void</span>*a)&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123;&#125;<span class="comment">//删减符 ...  捕获任何类型异常</span></span><br></pre></td></tr></table></figure>
<p>不存在异常的标识<br>throw ()<br>noexcept</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数必定不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>写一个类  描述异常  并  继承标准库中的异常类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//继承标准库中的异常类</span></span><br><span class="line"><span class="comment">//重写what方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myException</span> :<span class="keyword">public</span> exception </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myException</span>(string str) :<span class="built_in">exception</span>(str.<span class="built_in">c_str</span>()) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertArray</span><span class="params">(<span class="type">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">myException</span>(<span class="string">&quot;数组满了!&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteArray</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">myException</span>(<span class="string">&quot;数组为空，无法删除&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;删除成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准库中的异常继承关系"><a href="#标准库中的异常继承关系" class="headerlink" title="标准库中的异常继承关系"></a>标准库中的异常继承关系</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fv1-www.xuetangx.com%2Fasset-v1%3Axuetangx%2Bcppxly%2B2018_T2%2Btype%40asset%2Bblock%2F12-3.png&amp;refer=http%3A%2F%2Fv1-www.xuetangx.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664592415&amp;t=ee9272d390aaa6c628c3043ef04d2d05" alt="img"></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p> 把类型当做变量</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>写法<br>在函数声明和定义前加上template <class _Ty1, class _Ty2></p>
<p>函数模板包括<br>普通函数<br>类的成员函数</p>
<p>特殊写法<br>缺省<br>传常量</p>
<p>调用<br>隐式调用：正常的函数传参即可调用<br>显示调用：函数名&lt;类型名&gt;(参数)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>, <span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(_Ty1 one,_Ty2 two)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; two &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(_Ty data)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">(_Ty data)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;<span class="comment">//在类外实现不能省略template</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::printData</span><span class="params">(_Ty data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺省写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>, <span class="keyword">class</span> <span class="title class_">_Ty2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printData</span>(_Ty1 one, _Ty2 two) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; one&lt;&lt;<span class="string">&quot;\t&quot;</span> &lt;&lt; two &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传常量写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span> ,<span class="type">size_t</span> size=<span class="number">3</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printArray</span>(_Ty1 array)		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printData</span>(<span class="string">&quot;string&quot;</span>, <span class="number">1234</span>);<span class="comment">//隐式调用</span></span><br><span class="line">	<span class="built_in">printData</span>&lt;string&gt;(<span class="string">&quot;ILoveyou&quot;</span>, <span class="number">12344</span>);<span class="comment">//显式调用</span></span><br><span class="line">	<span class="type">int</span> array[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="built_in">printArray</span>&lt;<span class="type">int</span>*,<span class="number">3</span>&gt;(array);<span class="comment">//存在常量传参且没有做缺省则必须显示调用</span></span><br><span class="line">	<span class="built_in">printArray</span>(array);<span class="comment">//做了缺省可以隐式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>写法<br>在类声明和定义前加上template <class _Ty1, class _Ty2><br>声明和实现必须在一起</p>
<p>使用类名<br>必须绑定模板类型</p>
<p>注意：<br>可以传入  自定义类型  当做模板参数<br>要记得重载运算符<br>使用模板类一般不用new，new一定要有无参构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;<span class="comment">//在类外实现不能省略template</span></span><br><span class="line"><span class="type">void</span> MM&lt;_Ty&gt;::<span class="built_in">print</span>()&#123;&#125; <span class="comment">//需要显式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> :<span class="keyword">public</span> MM&lt;_Ty&gt; <span class="comment">//需要显式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Girl</span>(string name) :<span class="built_in">MM</span>&lt;_Ty&gt;()&#123;&#125; <span class="comment">//需要显式</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//必须绑定模板类型</span></span><br><span class="line">	MM&lt;<span class="type">int</span>&gt; mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板嵌套"><a href="#类模板嵌套" class="headerlink" title="类模板嵌套"></a>类模板嵌套</h2><p>就是向类模板传入的参数是一个模板类<br>注意：传入的类，一定需要无参构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>,<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(_Ty1 one, _Ty2 two) :<span class="built_in">one</span>(one), <span class="built_in">two</span>(two) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_Ty1 one;</span><br><span class="line">	_Ty2 two;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>,<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>(_Ty1 one, _Ty2 two) :<span class="built_in">one</span>(one), <span class="built_in">two</span>(two) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_Ty1 one;</span><br><span class="line">	_Ty2 two;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">//_Ty1类型是:MM&lt;string,int&gt;</span></span><br><span class="line">	<span class="comment">//_Ty2类型是:MM&lt;double,double&gt;</span></span><br><span class="line">	Data&lt;MM&lt;string, <span class="type">int</span>&gt;, MM&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; <span class="built_in">data1</span>(<span class="built_in">MM</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;小芳&quot;</span>,<span class="number">18</span>), <span class="built_in">MM</span>&lt;<span class="type">double</span>, <span class="type">double</span>&gt;(<span class="number">89</span>,<span class="number">56</span>));</span><br><span class="line">	<span class="comment">//起别名简化代码</span></span><br><span class="line">	<span class="keyword">using</span> MMType1 = MM&lt;string, <span class="type">int</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> MMType2 = MM&lt;<span class="type">double</span>, <span class="type">double</span>&gt;;</span><br><span class="line">	Data&lt;MMType1，MMType2&gt;<span class="built_in">data2</span>(<span class="built_in">MMType1</span>(<span class="string">&quot;小芳&quot;</span>,<span class="number">18</span>), <span class="built_in">MMType2</span>(<span class="number">89</span>,<span class="number">56</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h2><p>局部特化：确定类型数量(不可能比原生多)<br>完全特化：确定具体类型</p>
<p>类重载(相当于函数重载)<br>优先使用模板匹配度高的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//原生模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>,<span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(_Ty1 one, _Ty2 two) :<span class="built_in">one</span>(one), <span class="built_in">two</span>(two) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//局部特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span>&lt;_Ty,_Ty&gt;     </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(_Ty one, _Ty two) :<span class="built_in">one</span>(one), <span class="built_in">two</span>(two) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//完全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span>&lt;string, string&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string one, string two) :<span class="built_in">one</span>(one), <span class="built_in">two</span>(two) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//原生模板</span></span><br><span class="line">	<span class="function">MM&lt;string, <span class="type">int</span>&gt; <span class="title">mm1</span><span class="params">(<span class="string">&quot;小芳&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//局部特化模板</span></span><br><span class="line">	<span class="function">MM&lt;Data, Data&gt; <span class="title">dMM</span><span class="params">(Data(<span class="number">1</span>,<span class="number">2</span>),Data(<span class="number">3</span>,<span class="number">4</span>))</span></span>;</span><br><span class="line">	<span class="comment">//完全特化的模板</span></span><br><span class="line">	<span class="function">MM&lt;string, string&gt;  <span class="title">mm2</span><span class="params">(<span class="string">&quot;小丽&quot;</span>, <span class="string">&quot;小美&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL-一"><a href="#STL-一" class="headerlink" title="STL(一)"></a>STL(一)</h1><h2 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h2><p>需要#include\<array\><br>所有的容器都属于模板类，所以为STL标准模板库(Standard Template Library)<br>对象的创建和初始化：<br>array<int, 4>c0//创建空白数组<br>array<int, 4>c1={0,1,2,3};//创建并初始化数组<br>array<int, 4>c1(c0);//创建拷贝数组<br>对象使用：myarray[下标]      <strong>注意</strong>此处不是指针，是重载了运算符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">const_iterator</td>
<td style="text-align:left">常量迭代器</td>
<td>begin</td>
<td>返回指向第一个元素的迭代器</td>
<td>assign或fill(c++11)</td>
<td>用指定元素覆盖整个数组</td>
</tr>
<tr>
<td style="text-align:left">const_pointer</td>
<td style="text-align:left">元素常量指针</td>
<td>end</td>
<td>返回指向最后一个元素后一位的迭代器</td>
<td>max_size</td>
<td>返回最多元素数量</td>
</tr>
<tr>
<td style="text-align:left">const_reference</td>
<td style="text-align:left">元素常量引用</td>
<td>cbegin</td>
<td>返回指向第一个元素的常量迭代器</td>
<td>size</td>
<td>返回当前元素数量</td>
</tr>
<tr>
<td style="text-align:left">const_reverse_iterator</td>
<td style="text-align:left">常量反向迭代器</td>
<td>cend</td>
<td>返回指向最后一个元素后一位的常量迭代器</td>
<td>empty</td>
<td>是否存在元素</td>
</tr>
<tr>
<td style="text-align:left">difference_type</td>
<td style="text-align:left">表示元素之间的位移(元素数)</td>
<td>rbegin</td>
<td>返回指向第一个元素的反向迭代器</td>
<td>swap</td>
<td>交换两个等长数组的元素</td>
</tr>
<tr>
<td style="text-align:left">iterator</td>
<td style="text-align:left">迭代器</td>
<td>rend</td>
<td>返回指向最后一个元素后一位的反向迭代器</td>
<td>data</td>
<td>第一个元素的地址</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">元素指针</td>
<td>crbegin</td>
<td>返回指向第一个元素的常量反向迭代器</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">元素引用</td>
<td>crend</td>
<td>返回指向第一个元素前一位的常量反向迭代器</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">reverse_iterator</td>
<td style="text-align:left">反向迭代器</td>
<td>at</td>
<td>返回对应位置元素的引用</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">size_type</td>
<td style="text-align:left">表示元素之间的距离(元素数)</td>
<td>front</td>
<td>返回第一个元素的引用</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">value_type</td>
<td style="text-align:left">元素类型</td>
<td>back</td>
<td>返回最后一个元素的引用</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>需要#include\<vector\><br>除 std::array 外的所有 C++ 标准库容器都具有一个类型为 allocator\<Type>的模板参数，其中 Type表示容器元素的类型<br>对象的创建和初始化：<br>vector\<int,可选的分配器类型\>v0;//创建空白向量<br>vector\<int\>v1(3);//创建3个元素的向量<br>vector\<int\>v2(3,1);//创建3个元素为1的向量<br>vector\<int\>v3(3,1,v2.get_alloctor());//创建3个元素为1的向量，且使用v2的内存分配器<br>vector\<int\>v4(v2);//创建和v2内容相同的向量<br>vector\<int\>v5(v2.begin,v2.end-2);//创建向量包含[first, last)的元素<br>vector\<int>v6(move(v2));//创建和v2内容相同的向量  move用于强制转换为右值<br>vector\<int>v7({1,2,3,4});//创建向量初始化<br>vector\<int>v8={1,2,3,4};//创建向量初始化<br>对象使用：myvector[下标]      <strong>注意</strong>此处不是指针，是重载了运算符<br>注意：任何改变向量长度的操作都会使当前迭代器失效<br>内存分配原则：每次内存扩张为之前容量的两倍</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">const_iterator</td>
<td style="text-align:left">常量迭代器</td>
<td>begin</td>
<td>返回指向第一个元素的迭代器</td>
<td>assign</td>
<td>用指定元素覆盖整个数组</td>
<td>emplace</td>
<td>在指定位置生成指定元素</td>
</tr>
<tr>
<td style="text-align:left">const_pointer</td>
<td style="text-align:left">元素常量指针</td>
<td>end</td>
<td>返回指向最后一个元素后一位的迭代器</td>
<td>max_size</td>
<td>返回最多元素数量</td>
<td>emplace_back</td>
<td>在末尾生成指定元素</td>
</tr>
<tr>
<td style="text-align:left">const_reference</td>
<td style="text-align:left">元素常量引用</td>
<td>cbegin</td>
<td>返回指向第一个元素的常量迭代器</td>
<td>size</td>
<td>返回当前元素数量</td>
<td>insert</td>
<td>将指定元素(范围)插入到指定位置</td>
</tr>
<tr>
<td style="text-align:left">const_reverse_iterator</td>
<td style="text-align:left">常量反向迭代器</td>
<td>cend</td>
<td>返回指向最后一个元素后一位的常量迭代器</td>
<td>capacity</td>
<td>返回当前最多元素数量</td>
<td>pop_back</td>
<td>删除末尾元素</td>
</tr>
<tr>
<td style="text-align:left">difference_type</td>
<td style="text-align:left">表示元素之间的位移(元素数)</td>
<td>rbegin</td>
<td>返回指向第一个元素的反向迭代器</td>
<td>empty</td>
<td>是否存在元素</td>
<td>push_back</td>
<td>末尾插入元素</td>
</tr>
<tr>
<td style="text-align:left">iterator</td>
<td style="text-align:left">迭代器</td>
<td>rend</td>
<td>返回指向最后一个元素后一位的反向迭代器</td>
<td>swap</td>
<td>交换两个等长数组的元素</td>
<td>erase</td>
<td>删除指定位置或范围的元素</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">元素指针</td>
<td>crbegin</td>
<td>返回指向第一个元素的常量反向迭代器</td>
<td>data</td>
<td>第一个元素的地址</td>
<td>clear</td>
<td>清除所有元素</td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">元素引用</td>
<td>crend</td>
<td>返回指向第一个元素前一位的常量反向迭代器</td>
<td>reserve</td>
<td>重新分配size长度保存当前数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">reverse_iterator</td>
<td style="text-align:left">反向迭代器</td>
<td>at</td>
<td>返回对应位置元素的引用</td>
<td>resize</td>
<td>指定长度并初始化</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">size_type</td>
<td style="text-align:left">表示元素之间的距离(元素数)</td>
<td>front</td>
<td>返回第一个元素的引用</td>
<td>shrink_to_fit</td>
<td>返回多于容量</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">value_type</td>
<td style="text-align:left">元素类型</td>
<td>back</td>
<td>返回最后一个元素的引用</td>
<td>get_allocator</td>
<td>返回当前分配器对象的副本</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="vector的bool特化"><a href="#vector的bool特化" class="headerlink" title="vector的bool特化"></a>vector的bool特化</h2><p>它具有专用的基础类型的内存分配器，该分配器通过存储每位一个 bool值来提供空间优化<br>注意CPP无对位引用，此处特化为vector\<bool>::reference类实现的模拟引用，但是模拟并不完整<br>只可以用于filp，bool的隐式转化，=赋值</p>
<p>特化导致的差异</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>const_pointer</td>
<td>相当于const_iterator</td>
<td>flip</td>
<td>所有位取反</td>
<td>at</td>
<td>返回对应位置位的引用</td>
</tr>
<tr>
<td>const_reference</td>
<td>不会对原始值进行更新</td>
<td>swap</td>
<td>交换两个位</td>
<td>front</td>
<td>返回第一个位的引用</td>
</tr>
<tr>
<td>pointer</td>
<td>相当于iterator</td>
<td>operator[]</td>
<td>返回对应位的引用</td>
<td>back</td>
<td>返回最后一个位的引用</td>
</tr>
</tbody>
</table>
</div>
<h1 id="STL-二-！"><a href="#STL-二-！" class="headerlink" title="STL(二)！"></a>STL(二)！</h1><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>需要#include\<list><br>对象的创建和初始化：同vector<br>成员与函数：同vector</p>
<p>额外函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove</td>
<td>清除列表中与指定值匹配的元素</td>
<td>sort</td>
<td>按升序或其他顺序关系排列列表中的元素</td>
</tr>
<tr>
<td>remove_if</td>
<td>将满足指定谓词的元素从列表中消除</td>
<td>reverse</td>
<td>反转列表中元素的顺序</td>
</tr>
<tr>
<td>splice</td>
<td>将元素从自变量列表中删除或将它们插入目标列表</td>
<td>swap</td>
<td>交换两个列表的元素</td>
</tr>
<tr>
<td>unique</td>
<td>对排序好的列表去重</td>
<td>pop_front</td>
<td>开头插入元素</td>
</tr>
<tr>
<td>emplace_front</td>
<td>在开头生成指定元素</td>
<td>push_front</td>
<td>删除开头元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>需要#include\<stack><br>对象的创建和初始化：<br>stack&lt;元素类型,容器类型(可选,默认deque)&gt; mystack;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">empty</td>
<td style="text-align:left">测试 是否为空</td>
</tr>
<tr>
<td style="text-align:left">pop</td>
<td style="text-align:left">删除顶部元素</td>
</tr>
<tr>
<td style="text-align:left">push</td>
<td style="text-align:left">添加元素到顶部</td>
</tr>
<tr>
<td style="text-align:left">size</td>
<td style="text-align:left">返回元素数</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">返回顶部元素的引用</td>
</tr>
</tbody>
</table>
</div>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>需要#include\<queue><br>对象的创建和初始化：<br>queue&lt;元素类型,容器类型(可选,默认deque)&gt; myqueue;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">back</td>
<td style="text-align:left">返回最后一个元素的引用</td>
<td>pop</td>
<td>删除第一个元素</td>
</tr>
<tr>
<td style="text-align:left">empty</td>
<td style="text-align:left">测试是否为空</td>
<td>push</td>
<td>添加元素到后部</td>
</tr>
<tr>
<td style="text-align:left">front</td>
<td style="text-align:left">返回第一个元素的引用</td>
<td>size</td>
<td>返回元素数量</td>
</tr>
</tbody>
</table>
</div>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>需要#include\<queue><br>对象的创建和初始化：<br>priority_queue&lt;元素类型,容器类型(可选,默认deque),排列函数(可选,默认大在前)&gt; myPqueue;<br>函数使用同stack只是会自动排序<br>排序方法：有great&lt;&gt;,less&lt;&gt;<br>自定义cmp1排序：<br>struct cmp1{<br>bool operator()(int x,int y){return x&gt;y;//小的优先级高 ,从小到大排 }<br>};</p>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><p>需要#include\<deque><br>对象的创建和初始化：同vector<br>成员与函数：同vector</p>
<p>额外函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pop_front</td>
<td>开头插入元素</td>
<td>push_front</td>
<td>删除开头元素</td>
</tr>
<tr>
<td>emplace_front</td>
<td>在开头生成指定元素</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="C-STL容器篇-三"><a href="#C-STL容器篇-三" class="headerlink" title="C++STL容器篇(三)"></a>C++STL容器篇(三)</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>set/multiset</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	set:集合</span></span><br><span class="line"><span class="comment">	1.数据自带排序</span></span><br><span class="line"><span class="comment">	2.数据唯一性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MM&amp; object)<span class="type">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name &lt; object.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; setData;					<span class="comment">//默认方式 从小到大</span></span><br><span class="line">	set&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; setData2;		<span class="comment">//和默认方式一样</span></span><br><span class="line">	set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; setData3;	<span class="comment">//从大到小</span></span><br><span class="line">	<span class="type">int</span> array[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">		array[i] = temp;</span><br><span class="line">		setData.<span class="built_in">insert</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : array) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator iter = setData.<span class="built_in">begin</span>(); iter != setData.<span class="built_in">end</span>(); iter++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUserData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;MM&gt; mmData;   <span class="comment">//less&lt;int&gt; &lt;</span></span><br><span class="line">	mmData.<span class="built_in">insert</span>(<span class="built_in">MM</span>(<span class="string">&quot;name3&quot;</span>, <span class="number">19</span>));</span><br><span class="line">	mmData.<span class="built_in">insert</span>(<span class="built_in">MM</span>(<span class="string">&quot;name2&quot;</span>, <span class="number">28</span>));</span><br><span class="line">	mmData.<span class="built_in">insert</span>(<span class="built_in">MM</span>(<span class="string">&quot;name3&quot;</span>, <span class="number">188</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mmData) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">char</span>&gt; cData;</span><br><span class="line">	set&lt;string&gt; strData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重集合: 只具有排序功能，不具有去重功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testmultiset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; mulData;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		mulData.<span class="built_in">insert</span>(<span class="built_in">rand</span>() % <span class="number">10</span>);</span><br><span class="line">		<span class="comment">//rand()%26+&#x27;A&#x27;;</span></span><br><span class="line">		<span class="comment">//rand()%26+&#x27;a&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mulData) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testSet</span>();</span><br><span class="line">	<span class="built_in">testUserData</span>();</span><br><span class="line">	<span class="built_in">testmultiset</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bitset</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,<span class="type">size_t</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//多个二进制位</span></span><br><span class="line">	<span class="function">bitset&lt;8&gt; <span class="title">bData</span><span class="params">(<span class="string">&quot;11110000&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; bData &lt;&lt; endl;</span><br><span class="line">	bData.<span class="built_in">flip</span>();</span><br><span class="line">	cout &lt;&lt; bData &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; bData.<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; bData.<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; bData.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;bData.<span class="built_in">none</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">bitset&lt;8&gt; <span class="title">num</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul>
<li>map/multiset</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty1</span>, <span class="keyword">class</span> <span class="title class_">_Ty2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> </span><br><span class="line">&#123;</span><br><span class="line">	_Ty1 first;</span><br><span class="line">	_Ty2 second;</span><br><span class="line">	<span class="built_in">MyPair</span>(_Ty1 first, _Ty2 second) :<span class="built_in">first</span>(first), <span class="built_in">second</span>(second) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//map存储的数据是一个数对类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPair</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">pData</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;string&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">MyPair&lt;<span class="type">int</span>, string&gt; <span class="title">myPData</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;string&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; pData.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pData.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="comment">//1.自带排序，默认是从小到大</span></span><br><span class="line"><span class="comment">//2.数据唯一性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMap</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt; mapData;</span><br><span class="line">	map&lt;<span class="type">int</span>, string, less&lt;<span class="type">int</span>&gt;&gt; mapData1; <span class="comment">//和上面创建方式一样，从小到大</span></span><br><span class="line">	map&lt;<span class="type">int</span>, string, greater&lt;<span class="type">int</span>&gt;&gt; mapData2; <span class="comment">//从大到小</span></span><br><span class="line">	<span class="comment">//1.insert插入</span></span><br><span class="line">	mapData.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;string&quot;</span>));</span><br><span class="line">	<span class="comment">//2.make_pair构建数对插入</span></span><br><span class="line">	mapData.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;string3&quot;</span>));</span><br><span class="line">	<span class="comment">//3.单映射，可以直接采用数组下标方式进行插入</span></span><br><span class="line">	<span class="comment">//数组在一定程序上来说或可以说数组</span></span><br><span class="line">	<span class="comment">//map[first]=second;</span></span><br><span class="line">	<span class="comment">//相比数组来说，这个下标是没有任何要求</span></span><br><span class="line">	mapData[<span class="number">-1</span>] = <span class="built_in">string</span>(<span class="string">&quot;string-1&quot;</span>);  <span class="comment">//等效插入一个数对类型</span></span><br><span class="line">	<span class="comment">//上面代码等效：mapData.insert(pair&lt;int,string&gt;(-1,&quot;string-1&quot;))</span></span><br><span class="line">	mapData[<span class="number">1</span>] = <span class="string">&quot;string1&quot;</span>;		<span class="comment">//相同键 采用的是覆盖方式</span></span><br><span class="line">	<span class="comment">//遍历:</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = mapData.<span class="built_in">begin</span>(); iter != mapData.<span class="built_in">end</span>(); iter++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//*iter指的是pair类型</span></span><br><span class="line">		cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mapData) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v.first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; v.second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//map&lt;string, IMAGE*&gt; img;</span></span><br><span class="line">	<span class="comment">//img[&quot;墙&quot;] = new IMAGE;</span></span><br><span class="line">	<span class="comment">//img[&quot;路&quot;] = new IMAGE;</span></span><br><span class="line">	<span class="comment">//putimage(0, 0, img[&quot;墙&quot;]);</span></span><br><span class="line">	<span class="comment">//putimage(0, 0, img[&quot;路&quot;]);</span></span><br><span class="line">	cout &lt;&lt; mapData[<span class="number">1</span>] &lt;&lt; endl;    <span class="comment">//用的时候直接使用即可</span></span><br><span class="line">	mapData.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mapData)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v.first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; v.second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">MM</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MM&amp; object)<span class="type">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name &lt; object.name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boy</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Boy</span>(string name, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUserData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;MM, Boy&gt; mbData;</span><br><span class="line">	mbData[<span class="built_in">MM</span>(<span class="string">&quot;小美&quot;</span>, <span class="number">19</span>)] = <span class="built_in">Boy</span>(<span class="string">&quot;小张&quot;</span>, <span class="number">29</span>);</span><br><span class="line">	mbData[<span class="built_in">MM</span>(<span class="string">&quot;小美&quot;</span>, <span class="number">19</span>)].<span class="built_in">print</span>();</span><br><span class="line">	mbData[<span class="built_in">MM</span>(<span class="string">&quot;小丽&quot;</span>, <span class="number">20</span>)] = <span class="built_in">Boy</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;配对信息：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mbData) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//容器管理自定义类型数据</span></span><br><span class="line">		<span class="comment">//v:pair&lt;MM,Boy&gt;</span></span><br><span class="line">		<span class="comment">//v.frist:MM</span></span><br><span class="line">		<span class="comment">//v.second:Boy</span></span><br><span class="line">		v.first.<span class="built_in">print</span>();</span><br><span class="line">		v.second.<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testmultimap</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//多重映射，没有什么限制，什么样对应关系都可以插入到映射中</span></span><br><span class="line">	<span class="comment">//因为存在相同的键，所以不能采用下标法</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, string&gt;  mulData;</span><br><span class="line">	mulData.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;string&quot;</span>));</span><br><span class="line">	mulData.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;string1&quot;</span>));</span><br><span class="line">	mulData.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;string&quot;</span>));</span><br><span class="line">	mulData.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;string&quot;</span>));</span><br><span class="line">	mulData.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;string&quot;</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : mulData) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v.first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; v.second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testMap</span>();</span><br><span class="line">	<span class="built_in">testUserData</span>();</span><br><span class="line">	<span class="built_in">testmultimap</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>initializer_list</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MM</span>(string a, string b, string c) :<span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">	<span class="built_in">MM</span>(<span class="type">const</span> initializer_list&lt;string&gt;&amp; list) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); iter++) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string a;</span><br><span class="line">	string b;</span><br><span class="line">	string c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	array&lt;<span class="type">int</span>, 3&gt; arrData = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecData1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecData2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	MM mm1 = &#123; <span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span>,<span class="string">&quot;string3&quot;</span> &#125;;</span><br><span class="line">	MM mm2 = &#123; <span class="string">&quot;string1&quot;</span> &#125;;</span><br><span class="line">	MM mm3 = &#123; <span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span> &#125;;</span><br><span class="line">	initializer_list&lt;<span class="type">int</span>&gt; listOne = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	initializer_list&lt;<span class="type">int</span>&gt; listTwo = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="built_in">print</span>(&#123; <span class="number">1</span> &#125;);</span><br><span class="line">	<span class="built_in">print</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">	<span class="built_in">print</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;);</span><br><span class="line">	<span class="built_in">print</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li>tuple</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testTuple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//把任何类型的一系列数据当做一组处理</span></span><br><span class="line">	tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, string&gt; mmInfo = &#123;<span class="string">&quot;MM&quot;</span>,<span class="number">18</span>,<span class="number">1001</span>,<span class="string">&quot;123445&quot;</span>&#125;;</span><br><span class="line">	tuple&lt;<span class="type">double</span>, <span class="type">double</span>, <span class="type">double</span>&gt; mmscore = <span class="built_in">make_tuple</span>(<span class="number">98</span>, <span class="number">98</span>, <span class="number">88</span>);</span><br><span class="line">	tuple&lt;string, string&gt; value = forward_as_tuple(<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;小美&quot;</span>);</span><br><span class="line">	tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, string&gt; array[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visitedData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, string&gt; mmInfo = &#123; <span class="string">&quot;MM&quot;</span>,<span class="number">18</span>,<span class="number">1001</span>,<span class="string">&quot;123445&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//get方法,不能用for循环</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mmInfo) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mmInfo) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(mmInfo) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(mmInfo) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//tie的方式访问数据</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	string tel;</span><br><span class="line">	<span class="built_in">tie</span>(name, age, num, tel) = mmInfo;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; tel &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exoperator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, string&gt; mmInfo = &#123; <span class="string">&quot;MM&quot;</span>,<span class="number">18</span>,<span class="number">1001</span>,<span class="string">&quot;123445&quot;</span> &#125;;</span><br><span class="line">	tuple&lt;<span class="type">double</span>, <span class="type">double</span>, <span class="type">double</span>&gt; mmscore = <span class="built_in">make_tuple</span>(<span class="number">98</span>, <span class="number">98</span>, <span class="number">88</span>);</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="built_in">tuple_cat</span>(mmInfo, mmscore);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">visitedData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="折叠参数-拓展"><a href="#折叠参数-拓展" class="headerlink" title="折叠参数(拓展)"></a>折叠参数(拓展)</h2><ul>
<li>折叠参数:  …</li>
<li>可增长模板参数 模板函数</li>
<li>可增长模板参数 类模板</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><ul>
<li><p>迭代器辅助函数</p>
<ul>
<li>移动:advance(iterator iter,n); </li>
<li>间距:distance(iterator begin,iterator end);</li>
<li>交换:iter_swap(iterato first,iterator end);</li>
</ul>
</li>
<li><p>拓展内容:特殊迭代器 流型迭代器—&gt;一般用在辅助打印</p>
<ul>
<li>输出流型<ul>
<li>ostream_iterator<_Ty>  iter(ostream&amp; out);</li>
<li>ostream_iterator<_Ty>  iter(ostream&amp; out,char* str);</li>
<li>输出流型迭代做赋值运算，意味着就是打印数据到屏幕上</li>
</ul>
</li>
<li>输入流型<ul>
<li>istream_iterator<_Ty>  iter； //构造无参对象，是一个错误流 end_of_ostream</li>
<li>istream_iterator<_Ty>  iter(istream&amp; in);</li>
<li>*iter   等效cin&gt;&gt;操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li>Lambda: 就是一个返回函数指针的表达式，它定义和返回值函数指针在一起的</li>
<li>Lambda表达式的组成部分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [捕获方式](函数参数)mutable exception-&gt;函数返回值类型&#123;函数体;&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Max的Lambda表达式写法</span></span><br><span class="line">	<span class="built_in">int</span>(*pMax)(<span class="type">int</span>,<span class="type">int</span>)=[](<span class="type">int</span> a,<span class="type">int</span> b)<span class="keyword">mutable</span> <span class="keyword">noexcept</span>-&gt;<span class="type">int</span>&#123; <span class="keyword">return</span> a&gt;b?a:b;&#125;;  </span><br><span class="line">    <span class="comment">//省略写法: 中间描述此都可以省略</span></span><br><span class="line">    <span class="keyword">auto</span> ppMax=[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;reutrn a&gt;b?a:b;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//捕获方式--&gt;函数使用外部的变量的方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	[=]   //值的方式捕获</span></span><br><span class="line"><span class="comment">	[&amp;]	  //引用的方式捕获</span></span><br><span class="line"><span class="comment">	[this]//this指针方式捕获</span></span><br><span class="line"><span class="comment">	[]    //不捕获任何变量</span></span><br><span class="line"><span class="comment">	[=,&amp;x];//x用引用方式捕获，其他变量用值的方式捕获</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>(*pMax)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		[<span class="keyword">this</span>] &#123;cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl; &#125;();		<span class="comment">//定义和调用一步到位</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name=<span class="string">&quot;默认&quot;</span>;</span><br><span class="line">	<span class="type">int</span> age=<span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">int</span>(*pMax)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//完整版:Lambad 表达式</span></span><br><span class="line">	<span class="comment">//final override</span></span><br><span class="line">	pMax = [](<span class="type">int</span> a, <span class="type">int</span> b)<span class="keyword">mutable</span> <span class="keyword">noexcept</span>-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//省略版本的，写代码越简单越好</span></span><br><span class="line">	<span class="keyword">auto</span>  pp = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pp</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//实际使用可以一步到位---&gt;短暂性局部使用的的函数</span></span><br><span class="line">	cout &lt;&lt; [](<span class="type">int</span> a, <span class="type">int</span> b)<span class="keyword">mutable</span> <span class="keyword">noexcept</span>-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b ? b : a; &#125;, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a+b; &#125;, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">//捕获方式的区别</span></span><br><span class="line">	<span class="comment">//用值的捕获: 在Lambad中不能把值当做左值使用,函数调用不会因为值的改变而改变</span></span><br><span class="line">	<span class="type">int</span> data = <span class="number">101010</span>;</span><br><span class="line">	<span class="keyword">auto</span> pFunc = [=] &#123;  cout &lt;&lt; data &lt;&lt; endl; &#125;;  <span class="comment">//无参() 可以省略</span></span><br><span class="line">	<span class="keyword">auto</span> pFunc2 = [&amp;] &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;;</span><br><span class="line">	<span class="built_in">pFunc</span>();</span><br><span class="line">	<span class="built_in">pFunc2</span>();</span><br><span class="line">	data = <span class="number">808080</span>;</span><br><span class="line">	<span class="built_in">pFunc</span>();</span><br><span class="line">	<span class="built_in">pFunc2</span>();</span><br><span class="line">	MM  mm;</span><br><span class="line">	mm.<span class="built_in">print</span>();</span><br><span class="line">	<span class="comment">//特殊的东西--&gt;结合auto使用</span></span><br><span class="line">	<span class="keyword">auto</span> pAuto = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt;<span class="keyword">auto</span>&#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pAuto</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;				<span class="comment">//[](auto a, auto b) -&gt;auto&#123;return a &gt; b ? a : b; &#125;(1,3)</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">pAuto</span>(<span class="string">&quot;stringa&quot;</span>, <span class="string">&quot;stringb&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//[] (auto a, auto b) -&gt;auto&#123;return a &gt; b ? a : b; &#125;(&quot;stringa&quot;, &quot;stringb&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><ul>
<li>什么仿函数? 类模仿函数调用行为，实质是无名对象调用重载的()函数<ul>
<li>所以仿函数的关键点在于重载()</li>
</ul>
</li>
<li>一般情况仿函数是做排序准则，或者一些算法的计算准则</li>
<li>标准库中的仿函数<ul>
<li>算术类</li>
<li>关系类</li>
<li>逻辑类</li>
<li>选择，证同，投射</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>		<span class="comment">//仿函数所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的()的调用方式</span></span><br><span class="line">	Sum s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;显式调用:&quot;</span> &lt;&lt; s.<span class="built_in">operator</span>()(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;		<span class="comment">//显式调用重载函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;隐式调用:&quot;</span> &lt;&lt; <span class="built_in">s</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//用&#123;&#125;和()帮助编译器去做解析</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;无名调用:&quot;</span> &lt;&lt; Sum&#123;&#125;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;			<span class="comment">//类模仿函数调用行为---&gt;仿函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;无名调用:&quot;</span> &lt;&lt; <span class="built_in">Sum</span>()(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;			<span class="comment">//类模仿函数调用行为---&gt;仿函数</span></span><br><span class="line">	<span class="comment">//算术</span></span><br><span class="line">	cout &lt;&lt; plus&lt;<span class="type">int</span>&gt;&#123;&#125;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//关系</span></span><br><span class="line">	cout &lt;&lt; equal_to&lt;<span class="type">int</span>&gt;&#123;&#125;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	map&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; map1;</span><br><span class="line">	map&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; map3;</span><br><span class="line">	<span class="comment">//逻辑类</span></span><br><span class="line">	cout &lt;&lt; logical_and&lt;<span class="type">int</span>&gt;&#123;&#125;(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//求大于3 小于10的数字</span></span><br><span class="line">	<span class="comment">//没必要的做的事情</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">if</span> (logical_and&lt;<span class="type">int</span>&gt;&#123;&#125;(a &gt; <span class="number">3</span>, a &lt; <span class="number">10</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;大于3 小于10的数字&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><ul>
<li>什么是函数适配器: 用来绑定函数调用时候的参数，让函数适应其他调用的用法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//老版本bind1st bind2nd</span></span><br><span class="line"><span class="comment">//新版本: bind函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>(*pMax)(<span class="type">int</span>,<span class="type">int</span>), <span class="type">int</span> a,<span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax</span>(a,b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testClassFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test test;</span><br><span class="line">	<span class="keyword">auto</span> testFunc = <span class="built_in">bind</span>(&amp;Test::print, &amp;test, std::placeholders::_1, std::placeholders::_2, <span class="number">99</span>);</span><br><span class="line">	<span class="built_in">testFunc</span>(<span class="number">1</span>, <span class="number">3</span>);		<span class="comment">//调用，直接调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">(<span class="type">int</span> one, Test two, string str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过占位符，所以调整参数位置，形成不同的调用形态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testExUser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//占位符代表原函数的参数 在调用形态 的第二个位置</span></span><br><span class="line">	<span class="keyword">auto</span> testFunc = <span class="built_in">bind</span>(printData,std::placeholders::_3, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">	<span class="built_in">printData</span>(<span class="number">1</span>, <span class="built_in">Test</span>(), <span class="string">&quot;ILoveyou&quot;</span>);</span><br><span class="line">	<span class="built_in">testFunc</span>(<span class="built_in">Test</span>(), <span class="string">&quot;ILoveyou&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//基本用法</span></span><br><span class="line">	<span class="comment">//std::placeholders::_1占位符</span></span><br><span class="line">	<span class="keyword">auto</span> pMax = <span class="built_in">bind</span>(Max, std::placeholders::_1, <span class="number">100</span>);  <span class="comment">//把第二个参数置为100</span></span><br><span class="line">	<span class="comment">//只是增加调用行为，并没有真正改变了这个函数指针类型</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax</span>(<span class="number">34</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax</span>(<span class="number">13</span>, <span class="number">44</span>) &lt;&lt; endl;  <span class="comment">//绑定后的函数指针，不再支持传参的，第二个参数无效</span></span><br><span class="line">	<span class="comment">//语法上没问题，但是尽量别这样做</span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line">	<span class="keyword">auto</span> pMax2 = <span class="built_in">bind</span>(Max, _1, <span class="number">100</span>);  <span class="comment">//把第二个参数置为100</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">pMax2</span>(<span class="number">34</span>) &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecData = &#123; <span class="number">19</span>,<span class="number">43</span>,<span class="number">89</span>,<span class="number">89</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">67</span>,<span class="number">54</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vecData.<span class="built_in">begin</span>(), vecData.<span class="built_in">end</span>(),<span class="built_in">bind</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(),std::placeholders::_1,<span class="number">60</span>)) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count_if</span>(vecData.<span class="built_in">begin</span>(), vecData.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a &gt; <span class="number">60</span>; &#125;) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">testClassFunc</span>();</span><br><span class="line">	<span class="built_in">testExUser</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数包装器"><a href="#函数包装器" class="headerlink" title="函数包装器"></a>函数包装器</h2><ul>
<li><p>函数包装器是什么？就是把函数指针包装成一个对象。通过这个对象调用函数</p>
<ul>
<li>一旦函数指针被函数包装器包装了，那这个包装器对象可以直接替换函数指针的用法去调用函数</li>
</ul>
</li>
<li><p>函数包装器类的实力例化传参: function&lt;函数返回值类型(参数类型)&gt; </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;包装普通函数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span>    <span class="comment">//void print(int a, MM* mm);</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;包装成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printStatic</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;包装静态的函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMMFunc</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MM mm;</span><br><span class="line">	<span class="function">function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">func</span><span class="params">(bind(&amp;MM::print,&amp;mm,std::placeholders::_1))</span></span>;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">(<span class="type">int</span> a, MM mm, string str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind和function&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFuncBind</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	function&lt;<span class="type">void</span>(string, <span class="type">int</span>, MM)&gt; pf = <span class="built_in">bind</span>(printData,</span><br><span class="line">		std::placeholders::_2, std::placeholders::_3, std::placeholders::_1 );</span><br><span class="line">	<span class="built_in">pf</span>(<span class="string">&quot;string&quot;</span>, <span class="number">1</span>, <span class="built_in">MM</span>());</span><br><span class="line">	<span class="comment">//3  1  2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">function&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">funcMax</span><span class="params">(Max)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">funcMax</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcMax2=Max;</span><br><span class="line">	<span class="function">function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">funcS</span><span class="params">(MM::printStatic)</span></span>;</span><br><span class="line">	<span class="built_in">funcS</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//仿函数包装</span></span><br><span class="line">	Test test;</span><br><span class="line">	function&lt;<span class="type">void</span>(string)&gt; func = test;</span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&quot;包装仿函数&quot;</span>);</span><br><span class="line">	<span class="built_in">TestFuncBind</span>();</span><br><span class="line">	<span class="comment">//包装成员函数</span></span><br><span class="line">	<span class="built_in">testMMFunc</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.整理笔记，写好第一篇博客 </p>
<h1 id="C-STL算法篇"><a href="#C-STL算法篇" class="headerlink" title="C++STL算法篇"></a>C++STL算法篇</h1><h2 id="STL查找算法"><a href="#STL查找算法" class="headerlink" title="STL查找算法"></a>STL查找算法</h2><ul>
<li><p>基本查找</p>
<ul>
<li>find:区间查找</li>
<li>find_if:条件查找</li>
<li>find_firt_of: 查找区间第一次出现值</li>
<li>adjacent_find: 查找第一次重复的数</li>
<li>search:子序列查找</li>
<li>search_n: 子序列查找出现次数</li>
</ul>
</li>
<li><p>统计查找</p>
<ul>
<li><p>count: 区间统计</p>
</li>
<li><p>count_if: 条件统计个数</p>
</li>
<li><p>equal:比较    </p>
</li>
</ul>
</li>
<li><p>有序查找</p>
<ul>
<li>binary_search：二分查找</li>
<li>upper_bound: 查找最后一个大于查找的值</li>
<li>lower_bound: 大于等于查找的值</li>
<li>equal_range:区间比较—-有序序列</li>
</ul>
</li>
</ul>
<h2 id="STL排序通用算法"><a href="#STL排序通用算法" class="headerlink" title="STL排序通用算法"></a>STL排序通用算法</h2><ul>
<li>merge: 归并排序，存于新容器</li>
<li>inplace_merge: 归并排序，覆盖原区间</li>
<li>sort: 排序，更改原容器顺序</li>
<li>stable_sort: 排序，保存原容器数据顺序</li>
<li>nth_element: 关键字排序</li>
<li>partition:范围排序</li>
<li><p>partial_sort:范围排序</p>
</li>
<li><p>partial_sort_copy:范围排序外加复制操作</p>
</li>
<li><p>stable_partition: 范围排序，保存原容器顺序</p>
</li>
<li><p>random_shuffle: 随机排序</p>
</li>
<li>reverse:逆序原容器</li>
<li><p>reverse_copy: 逆序容器保存到新容器</p>
</li>
<li><p>rotate:移动元素到容器末尾</p>
</li>
<li>rotate_copy:移动元素到新容器</li>
</ul>
<h2 id="STL删除替换算法"><a href="#STL删除替换算法" class="headerlink" title="STL删除替换算法"></a>STL删除替换算法</h2><ul>
<li>copy: 拷贝函数</li>
<li>copy_backward: 逆序拷贝</li>
<li>iter_swap: 交换</li>
<li>remove: 删除</li>
<li>remove_copy: 删除元素复制到新容器</li>
<li>remove_if:条件删除</li>
<li>remove_copy_if:条件删除拷贝到新容器</li>
<li>replace:替换</li>
<li>replace_copy: 替换，结果放到新容器</li>
<li>replace_if: 条件替换</li>
<li>replace_copy_if:条件替换，结果另存</li>
<li>swap: 交换</li>
<li>swap_range:区间交换</li>
<li>unique:去重</li>
<li>unique_copy:去重，结果另存</li>
</ul>
<h2 id="STL排列组合算法"><a href="#STL排列组合算法" class="headerlink" title="STL排列组合算法"></a>STL排列组合算法</h2><ul>
<li><p>next_permutation:下一个排序序列的组合</p>
</li>
<li><p>prev_permutation:上一个排序序列的组合</p>
</li>
</ul>
<h2 id="STL-算术算法"><a href="#STL-算术算法" class="headerlink" title="STL 算术算法"></a>STL 算术算法</h2><ul>
<li><p>accumulate:区间求和</p>
</li>
<li><p>partial_sum:相邻元素的和</p>
</li>
<li><p>inner_product:序列内积运算</p>
</li>
<li><p>adjacent_difference:相邻元素的差</p>
</li>
</ul>
<h2 id="STL-生成异变算法"><a href="#STL-生成异变算法" class="headerlink" title="STL 生成异变算法"></a>STL 生成异变算法</h2><ul>
<li><p>for_each:迭代访问</p>
</li>
<li><p>fill:填充方式初始容器</p>
</li>
<li><p>fill_n:指定长度填充容器</p>
</li>
<li><p>generate_n:填充前n个位置</p>
</li>
<li><p>transform:一元转换和二元转换</p>
</li>
</ul>
<h2 id="STL-关系算法"><a href="#STL-关系算法" class="headerlink" title="STL 关系算法"></a>STL 关系算法</h2><ul>
<li><p>equal:两容器元素是否都相同</p>
</li>
<li><p>includes:是否是包含关系</p>
</li>
<li><p>lexicographical_compare:比较两个序列</p>
</li>
<li><p>max:求最大值</p>
</li>
<li><p>max_element:返回最大值的iterator</p>
</li>
<li><p>min:求最小值</p>
</li>
<li><p>min_element:求最小值的iterator</p>
</li>
<li><p>mismatch:找到第一个不同的位置</p>
</li>
</ul>
<h2 id="STL-集合算法"><a href="#STL-集合算法" class="headerlink" title="STL 集合算法"></a>STL 集合算法</h2><ul>
<li><p>set_union:差集</p>
</li>
<li><p>set_intersection:并集</p>
</li>
<li><p>set_difference:保存第一个中有第二个没有的元素</p>
</li>
<li><p>set_symmetric_difference:对称差集</p>
</li>
</ul>
<h2 id="STL堆算法"><a href="#STL堆算法" class="headerlink" title="STL堆算法"></a>STL堆算法</h2><ul>
<li><p>make_heap:生成一个堆</p>
</li>
<li><p>pop_heap:出堆</p>
</li>
<li><p>push_heap:入堆</p>
</li>
<li><p>sort_heap:堆排序</p>
</li>
</ul>
<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>智能指针其实本质是一个模板类，一般使用是用的这个类的对象，而不是指针</li>
<li>智能指针体现在内存释放问题。用智能指针管理new的对象， 将不在需要手动delete</li>
</ul>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><ul>
<li>get() 函数: 返回数据的指针的引用</li>
<li>use_count(): 返回的是管理对象的智能指针对象数</li>
<li>swap():交换管理对象</li>
<li>reset():重置管理对象</li>
</ul>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul>
<li>弱引用指针，不会累计计数</li>
<li>weak_ptr只能通过shared_ptr或者weak_ptr来构造</li>
<li>主要应用场景： 为了解决shared_ptr 循环引用内存导致无法释放问题</li>
<li>不可使用* 取值，能使用-&gt;取值 </li>
<li>通过成员函数lock获取shared_ptr对象 然后再访问数据</li>
</ul>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul>
<li>禁止拷贝和赋值，独占型</li>
<li>任何时候unqiue_ptr操作管理对象，永远都只有一个有效<ul>
<li>可以通过move函数转交所有权 </li>
<li>reset函数结合release函数移交所有权</li>
</ul>
</li>
</ul>
<h1 id="C-正则表达式"><a href="#C-正则表达式" class="headerlink" title="C++正则表达式"></a>C++正则表达式</h1><p>正则是一种规则，它用来匹配（进而捕获、替换）字符串。这种规则需要“模式”、“字符串”这两样东西，“模式”根据正则规则，来处理“字符串”。这种规则被许多语言支持，C++11以后才支持正则。</p>
<h2 id="具有特殊意义的元字符"><a href="#具有特殊意义的元字符" class="headerlink" title="具有特殊意义的元字符"></a>具有特殊意义的元字符</h2><p>\：\字符能够改变字符原本的含义</p>
<p>^：^字符指示字符串的头，且要求字符串以字符开头，不占位。\^表示一个真正的^符号。</p>
<p>$：$字符指示字符串的尾，且要求字符串以字符结尾，不占位。\$表示一个真正的$符号。</p>
<p>()：分组，大正则中包含小正则。可以改变默认的优先级。在模式中可以使用\1来表示第一组已然捕获到的东西。</p>
<p>\b：指示字符串的边界（头/尾/空格左/空格右），字符\b要求边界的左边是字符，\b字符要求边界的右边是字符。</p>
<p>.：表示一个除了\n以外的任意一个字符。\.表示一个真正的.符号。</p>
<p>|：a|b  a或b之一</p>
<p>[abc]：abc之中的任意一个</p>
<p>[^abc]:  abc之外的</p>
<p>[a-z]:    任意小写字母</p>
<p>[^a-z]:  除了小写字母之外的</p>
<p>\w：任意一个字母数字下划线，等价于[(0-9)(a-z)(A-Z)(_)]</p>
<p>\W：字母数字下划线之外的，等价于[]</p>
<p>\d:    任意一个数子</p>
<p>\D:    除了数字之外的</p>
<p>\s:    空白符（空格、制表符、换页符）</p>
<h2 id="量词元字符"><a href="#量词元字符" class="headerlink" title="量词元字符"></a>量词元字符</h2><p>*：字符*要求字符出现0到多次   {0,}</p>
<p>+：字符+要求字符出现1到多次     (\w)  {1,} </p>
<p>?：字符?要求字符出现0次或1次    {0,1}</p>
<p>{n}：字符{n}要求字符出现n次</p>
<p>{n,}：字符{n,}要求字符出现n到多次  {0,}</p>
<p>{n,m}：字符{n,m}要求字符出现n到m次、</p>
<p>所以含有<code>\</code>的元字符，在C++定义时，都要写成<code>\\</code></p>
<h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><p>数字：^ [0 - 9] <em> $<br>n位的数字：^ \d{ n }$<br>至少n位的数字：^ \d{ n, }$<br>m - n位的数字： ^ \d{ m,n }$<br>零和非零开头的数字： ^ (0 | [1 - 9][0 - 9] </em>)$<br>非零开头的最多带两位小数的数字： ^ ([1 - 9][0 - 9] <em>) + (.[0 - 9]{ 1,2 }) ? $<br>带1 - 2位小数的正数或负数： ^ (\ - ) ? \d + (.\d{ 1,2 }) ? $<br>正数、负数、和小数： ^ (\ - | \ + ) ? \d + (.\d + ) ? $<br>有两位小数的正实数： ^ [0 - 9] + (.[0 - 9]{ 2 }) ? $<br>有1~3位小数的正实数： ^ [0 - 9] + (.[0 - 9]{ 1,3 }) ? $<br>非零的正整数： ^ [1 - 9]\d </em> $ 或 ^ ([1 - 9][0 - 9] <em>) { 1, 3 }$ 或^ \ + ? [1 - 9][0 - 9] </em> $<br>非零的负整数： ^ \ - [1 - 9][]0 - 9”<em>$ 或 ^-[1-9]\d</em>$<br>非负整数： ^ \d + $ 或 ^ [1 - 9]\d <em> | 0$<br>非正整数： ^ -[1 - 9]\d </em> | 0$ 或 ^ ((-\d + ) | (0 + ))$<br>非负浮点数： ^ \d + (.\d + ) ? $ 或 ^ [1 - 9]\d <em> .\d </em> | 0.\d <em> [1 - 9]\d </em> | 0 ? .0 + | 0$<br>非正浮点数： ^ ((-\d + (.\d + ) ? ) | (0 + (.0 + ) ? ))$ 或 ^ (-([1 - 9]\d <em> .\d </em> | 0.\d <em> [1 - 9]\d</em>)) | 0 ? .0 + | 0$<br>正浮点数： ^ [1 - 9]\d <em> .\d </em> | 0.\d <em> [1 - 9]\d </em> $ 或 ^ (([0 - 9] + .[0 - 9] <em> [1 - 9][0 - 9] </em>) | ([0 - 9] <em> [1 - 9][0 - 9] </em> .[0 - 9] + ) | ([0 - 9] <em> [1 - 9][0 - 9] </em>))$<br>负浮点数： ^ -([1 - 9]\d <em> .\d </em> | 0.\d <em> [1 - 9]\d</em>)$ 或 ^ (-(([0 - 9] + .[0 - 9] <em> [1 - 9][0 - 9] </em>) | ([0 - 9] <em> [1 - 9][0 - 9] </em> .[0 - 9]) | ([0 - 9] <em> [1 - 9][0 - 9] </em>)))$<br>浮点数： ^ (-? \d + )(.\d + ) ? $ 或 ^ -? ([1 - 9]\d <em> .\d </em> | 0.\d <em> [1 - 9]\d </em> | 0 ? .0 + | 0)$</p>
<h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><p>汉字： ^ [\u4e00 - \u9fa5]{ 0, }$<br>英文和数字： ^ [A - Za - z0 - 9] + $ 或 ^ [A - Za - z0 - 9]{ 4,40 }$<br>长度为3 - 20的所有字符： ^ .{3, 20}$<br>由26个英文字母组成的字符串： ^ [A - Za - z] + $<br>由26个大写英文字母组成的字符串： ^ [A - Z] + $<br>由26个小写英文字母组成的字符串： ^ [a - z] + $<br>由数字和26个英文字母组成的字符串： ^ [A - Za - z0 - 9] + $<br>由数字、26个英文字母或者下划线组成的字符串： ^ \w + $ 或 ^ \w{ 3,20 }$<br>中文、英文、数字包括下划线： ^ [\u4E00 - \u9FA5A - Za - z0 - 9_] + $<br>中文、英文、数字但不包括下划线等符号： ^ [\u4E00 - \u9FA5A - Za - z0 - 9] + $ 或 ^ [\u4E00 - \u9FA5A - Za - z0 - 9]{ 2,20 }$<br>可以输入含有 ^ %&amp;’,;=?$\”等字符：[^%&amp;’, ; = ? $\x22] + 12 禁止输入含有~的字符：[^ ~\x22] +</p>
<h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><p>Email地址： ^ \w + ([-+.]\w + ) <em> @\w + ([-.]\w + ) </em> .\w + ([-.]\w + ) <em> $<br>域名：[a - zA - Z0 - 9][-a - zA - Z0 - 9]{ 0,62 }(/ .[a - zA - Z0 - 9][-a - zA - Z0 - 9]{ 0,62 }) + / . ?<br>InternetURL：[a - zA - z] + ://<sup><a href="#fn_\s" id="reffn_\s">\s</a></sup></em> 或 ^<a href="http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$">http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</a><br>手机号码： ^ (13[0 - 9] | 14[5 | 7] | 15[0 | 1 | 2 | 3 | 5 | 6 | 7 | 8 | 9] | 18[0 | 1 | 2 | 3 | 5 | 6 | 7 | 8 | 9])\d{ 8 }$<br>电话号码(0511 - 4405222、021 - 87888822)：\d{ 3 } - \d{ 8 } | \d{ 4 } - \d{ 7 }<br>身份证号(15位、18位数字)： ^ \d{ 15 } | \d{ 18 }$<br>短身份证号码(数字、字母x结尾)： ^ ([0 - 9]) { 7, 18 }(x | X) ? $ 或 ^ \d{ 8,18 } | [0 - 9x]{ 8,18 } | [0 - 9X]{ 8,18 } ? $<br>帐号：(字母开头，允许5 - 16字节，允许字母数字下划线)： ^ [a - zA - Z][a - zA - Z0 - 9_]{ 4,15 }$<br>密码:(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： ^ [a - zA - Z]\w{ 5,17 }$<br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8 - 10之间)：<em> ^ (? = .</em>\d)(? = .<em>[a - z])(? = .</em>[A - Z]).{8, 10}$<br>日期格式： ^ \d{ 4 } - \d{ 1,2 } - \d{ 1,2 }<br>一年的12个月(01～09和1～12)： ^ (0 ? [1 - 9] | 1[0 - 2])$<br>一个月的31天(01～09和1～31)： ^ ((0 ? [1 - 9]) | ((1 | 2)[0 - 9]) | 30 | 31)$<br>xml文件： ^ ([a - zA - Z] + -? ) + [a - zA - Z0 - 9] + \.[x | X][m | M][l | L]$<br>中文字符的正则表达式：[\u4e00 - \u9fa5]<br>双字节字符：[^ \x00 - \xff](包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>空白行的正则表达式：\n\s <em> \r(可以用来删除空白行)<br>HTML标记的正则表达式：&lt;(\S</em> ? )<sup><a href="#fn_ > " id="reffn_ > "> > </a></sup> <em>&gt;.</em> ? &lt; / \1&gt; | &lt;.<em> ? / &gt; (复杂的嵌套标记依旧无能为力)<br>首尾空白字符的正则表达式： ^ \s </em> | \s <em> $或(^ \s</em>) | (\s * $) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等))<br>腾讯QQ号：[1 - 9][0 - 9]{ 4, } (腾讯QQ号从10000开始)<br>中国邮政编码：[1 - 9]\d{ 5 }(? !\d) (中国邮政编码为6位数字)<br>IP地址：\d + .\d + .\d + .\d + (提取IP地址时有用)<br>IP地址：((? : (? : 25[0 - 5] | 2[0 - 4]\\d | [01] ? \\d ? \\d)\.) { 3 }(? : 25[0 - 5] | 2[0 - 4]\\d | [01] ? \\d ? \\d))</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows</title>
    <url>/2022/07/25/Windows/</url>
    <content><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以前的配置信息依赖于ini文件，如今在windows文件夹下有win.ini和system.ini</p>
<p>这种方式读写慢，容易被用户误操作</p>
<p>windows NT开始用数据库来存储配置信息，这个数据库称为注册表，在windows/system32/config文件夹下</p>
<p>注册表不能文本打开，只可以用windows文件夹下的regedit.exe或者cmd输入regedit打开</p>
<p>注册表和文件管理同，只是名称改为：项key-子项subkey（-n个子项）-值value<br>且值有三个属性（名称，类型，数据）</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>HKEY_CLASSES_ROOT/*/shell/子项/command/值<br>该子项1是鼠标右键时出现的选项的名称<br>command（不区分大小写，不可以改变）<br>command下名称为默认，类型为REG_SZ为字符串，数据为打开方式（如notepad.exe %1）<br>子项下名称为icon，类型为REG_SZ，数据为全路径（如c:\windows\system32\notepad.exe）</p>
<p>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced<br>找到或者新建，名称为ShowSecondsInSystemClock，类型为Dword的值，数据改为1<br>此时时间显示秒数</p>
<p>python的import winreg可以修改注册表？<br>在指定目录下创建项<br>key=winreg.CreateKey(项名,”子项目录”)<br>在项下创建子项和设置值<br>winreg.SetValue(项,”子项名”,winreg.类型,”数据”)</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言汇总</title>
    <url>/2022/09/09/c%E8%AF%AD%E8%A8%80%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="C-的历史"><a href="#C-的历史" class="headerlink" title="C 的历史"></a>C 的历史</h1><h2 id="早期-C"><a href="#早期-C" class="headerlink" title="早期 C"></a>早期 C</h2><p>1969　:基于 BCPL 创建 B ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器</p>
<p>1971 ：于将 B 移植到 PDP-11 时创建 NB （新“ B ”）</p>
<p>1972 ：语言更名为 C</p>
<p>1973 ：以 C 重写</p>
<p>1978 ： The C Programming Language ，第1版</p>
<h2 id="标准-C"><a href="#标准-C" class="headerlink" title="标准 C"></a>标准 C</h2><p>1983 ： ANSI 建立 X3J11 委员会</p>
<p>1988 ： The C Programming Language ，第2版</p>
<p>1989 ： <strong>C89</strong>，ANSI C 标准出版</p>
<ol>
<li>代码化的既存实践</li>
<li>新特性 ：volatile 、 enum 、有符号整数 、 void 、本地环境</li>
<li>来自 C++ ： const 、函数原型</li>
</ol>
<p>1990 ： <strong>C90</strong> ，ANSI C 标准被接纳为 ISO/IEC 9899-1990</p>
<p>1995 ： <strong>C95</strong> （ ISO/IEC 9899 AM1 ）（<a href="http://infostore.saiglobal.com/store/Details.aspx?DocN=isoc000767513">在线商店</a>）</p>
<ol>
<li>极大扩充了宽和多字节字符支持（ wctype.h 、 wchar.h 、对流 I/O 的添加和更改等）</li>
<li>双标符、 iso646.h</li>
</ol>
<p>1995 ：技术勘误 1（ ISO/IEC 9899 TCOR1 ）</p>
<p>1996 ：技术勘误 2（ ISO/IEC 9899 TCOR2 ）</p>
<p>1999 ：<strong>C99</strong> （ ISO/IEC 9899:1999 ）</p>
<ol>
<li>新特性： _Bool 、 long long 、 stdint.h 、 inttypes.h 、 restrict 、复合字面量、变长度数组、伸缩数组成员、指派初始化器、 fenv.h 、变参数宏、复数、 __func__ 、十六进制浮点格式（ %a ）、 lconv 的货币格式化、 isblank 、窄与宽字符串字面量的连接、枚举的尾逗号、类函数宏的空参数、 STDC_* pragma 、 va_copy 、 tmpnam 的空返回、 setvbuf 中的空指针、 printf 的 hh 与 ll 长度指定符、 snprintf 、 _Exit 、 tgmath.h 、仿 POSIX strftime 说明符</li>
<li>来自 C++ ： inline 、声明与代码混合、 for 循环的 init 子句中的声明、  注释、源代码中的通用字符名</li>
<li>移除隐式函数声明和隐式 int</li>
</ol>
<p>2001 ：技术勘误 1 （ ISO/IEC 9899:1999/Cor.1:2001(E) ）</p>
<p>2004 ：技术勘误 2 （ ISO/IEC 9899:1999/Cor.2:2004(E) ）</p>
<p>2004 ：Unicode TR（ ISO/IEC TR 19769:2004 ）（<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1040.pdf">2013-11-07 草案</a>）</p>
<p>2007 ：技术勘误 3 （ ISO/IEC 9899:1999/Cor.3:2007(E) ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">2007-09-07草案</a>）</p>
<p>2007 ：边界检查接口 TR（ ISO/IEC TR 24731-1:2007 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1225.pdf">2007-03-28 草案</a>）</p>
<p>2008 ：嵌入式 TR （ ISO/IEC TR 18037:2008 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1021.pdf">2003-09-24 草案</a>）</p>
<p>2009 ：十进制浮点数 TR（ ISO/IEC TR 24732:2009 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1241.pdf">2007-07-05 草案</a>）</p>
<p>2009 ：特殊数学函数 TR（ ISO/IEC TR 24747:2009 ）（<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1182.pdf">2006-08-02 草案</a>）</p>
<p>2010 ：动态分配函数 TR（ ISO/IEC TR 24731-2:2010 ）<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1248.pdf">2007-08-15 草案</a>）</p>
<p>2011 ： <strong>C11</strong> （ ISO/IEC 9899:2011 ）（<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">2011-04-12 草案</a>）</p>
<ol>
<li>具线程的内存模型 、 stdatomic.h 、 threads.h 、泛型函数、 _Alignas/_Alignof 、 _Noreturn 、 _Static_assert 、可分析性扩展、对复数和虚数类型的扩展、匿名结构体与联合体、独占文件打开模式、 quick_exit</li>
<li>移除 gets</li>
<li>来自边界检查接口 TR ：边界检查接口</li>
<li>来自 Unicode TR ： char16_t 、 char32_t ，及 uchar.h</li>
</ol>
<p>2012 ：技术勘误 1 （ ISO/IEC 9899:2011/Cor 1:2012 ）</p>
<p>2013 ：安全代码规则 TS （ ISO/IEC TS 17961:2013 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1624.pdf">2012-12-26</a> 草案）</p>
<p>2014 ：FP TS 部分 1 ：二进制浮点算术（ ISO/IEC TS 18661-1:2014 ）（ <a href="http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1778.pdf">2013 草案</a>）</p>
<ol>
<li>提供对 C11 的更改（主要对附录 F ），以覆盖所有基本要求及一些 IEC 60559:2011 的推荐（ C11 构建于 IEC 60559:1989 ）</li>
</ol>
<p>2015 ：FP TS 部分 2 ：十进制浮点算术（ ISO/IEC TS 18661-2:2015 ）( <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1912.pdf">2015 草案</a>）</p>
<ol>
<li>提供对 C11 的更改，以支持所有要求，加上一些 IEC 60559:2011 对十进制浮点算术的基本推荐。它替代了 ISO/IEC TR 24732:2009 。</li>
</ol>
<p>2015 ：FP TS 部分 3 ：交换及扩展类型（ ISO/IEC TS 18661-3:2015 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1945.pdf">2015 草案</a>）</p>
<ol>
<li>提供对C11的更改，以支持IEC 60559:2011对扩展浮点格式及交换格式的推荐，包括算术和非算术。</li>
</ol>
<p>2015 ：FP TS 部分 4 ：补充的函数（ ISO/IEC TS 18661-4:2015 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1950.pdf">2015 草案</a>）</p>
<ol>
<li>提供对 C11 的更改，以支持所有 IEC 60559:2011 推荐的数学运算，包括 π 单位的三角函数、平方根倒数、复利等。</li>
</ol>
<p>2016 ：FP TS 部分 5 ：补充的属性（ ISO/IEC TS 18661-5:2016 ）（ <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2004.pdf">2016 草案</a>）</p>
<ol>
<li>提供对 C11 的更改，以支持所有 IEC 60559:2011 推荐的补充属性（求值模型、异常处理、可再现性等）</li>
</ol>
<p>2018: <strong>C17</strong> （ ISO/IEC 9899:2018 ）（ <a href="https://files.lhmouse.com/standards/ISO C N2176.pdf">最终草案</a>）</p>
<h3 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h3><p>并行 TS （草案 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2017.pdf">n2017</a> 2016-03-10 ）</p>
<p>事务性内存 TS （草案 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1961.pdf">n1961</a> 2015-09-23 ）</p>
<p><strong>C23</strong> （草案 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2731.pdf">n2731</a> 2021-10-18 ）</p>
<ol>
<li>C11 后缺陷报告列表（包含为 C2x 安排者）(<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm">n2396</a> 2019-04)</li>
</ol>
<h1 id="C语言内容"><a href="#C语言内容" class="headerlink" title="C语言内容"></a>C语言内容</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>映射源文件(通常是以某种多字节，例如UTF-8编码的文本文件)的单独字节为基础源字符集，特别注意要替换依赖OS的行尾指示符<br>基础源字符集(存储源代码用的字符集)：<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>0 1 2 3 4 5 6 7 8 9<br>_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ “ ‘<br>空白字符(空格 水平制表 垂直制表 换页 换行)</p>
<p>用对应的单字节表示替换三标符<br>??&lt;替换为{<br>??&gt;替换为}<br>??(替换为[<br>??)替换为]<br>??=替换为#<br>??/替换为\<br>??’替换为^<br>??!替换为|<br>??-替换为~<br>注意：现在编译器已经默认不作转义但是会给出提示</p>
<h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>凡反斜杠出现在行尾时，删除反斜杠和换行符，和下一行物理源码行组合成一个逻辑源码行<br>若此步骤后，非空源文件不以换行符结束，则行为未定义</p>
<h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>用空格代替注释，其他长空白是否用空格代替需要看编译器具体实现</p>
<p>将源文件分解为注释、空白字符和预处理记号<br>预处理记号包括：头文件，标识符，预处理数字(包括整数常量和浮点常量和一些非法记号)，字符常量，字符串字面量，运算符与标点，不属于任何其他类别的单独非空白字符</p>
<p>最大吞噬(maximal munch) (大嘴法、贪心法)：将下一个最长字符序列作为下个预处理记号(即下一个符号为从当前字符开始可能组成一个符号的最长字符串)</p>
<p>最大吞噬的例外：头文件名的预处理记号仅在#include和#pragma的实现定义位置处形成</p>
<h4 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h4><p>执行预处理器</p>
<h1 id="include指令所引入的每个文件都需要经历一到四阶段，并递归执行"><a href="#include指令所引入的每个文件都需要经历一到四阶段，并递归执行" class="headerlink" title="include指令所引入的每个文件都需要经历一到四阶段，并递归执行"></a>include指令所引入的每个文件都需要经历一到四阶段，并递归执行</h1><p>此阶段结束时，从源码移除所有预处理器指令</p>
<h4 id="第五阶段！！每次转换时的兼容性和方法"><a href="#第五阶段！！每次转换时的兼容性和方法" class="headerlink" title="第五阶段！！每次转换时的兼容性和方法"></a>第五阶段！！每次转换时的兼容性和方法</h4><p>将字符常量及字符串字面量中的所有字符及转义序列从源字符集转换成执行字符集(执行文件时文本信息用的字符集)(例UTF-8的多字节字符集)若转义序列所指定的字符不是执行字符集的成员，则结果需要看编译器具体实现，但保证不是空(宽)字符。</p>
<p>注意：某些编译器，能以命令行选项控制此阶段所进行的转换，如gcc和clang<br>用-finput-charset指定源字符集的编码<br>用-fexec-charset和-fwide-exec-charset指定<code>无编码前缀的(C11)</code>字符串字面量和字符常量中的执行字符集的编码</p>
<h4 id="第六阶段"><a href="#第六阶段" class="headerlink" title="第六阶段"></a>第六阶段</h4><p>连接相邻的字符串字面量</p>
<h4 id="第七阶段"><a href="#第七阶段" class="headerlink" title="第七阶段"></a>第七阶段</h4><p>编译：按照语法和语义分析记号，将每个文件作为翻译单元(.c)，依次编译为相应的对象文件(.o)</p>
<h4 id="第八阶段"><a href="#第八阶段" class="headerlink" title="第八阶段"></a>第八阶段</h4><p>链接：将翻译单元和程序所依赖的第三方库链接为镜像文件(可执行文件、静态库或动态库)它含有在其执行环境(操作系统)中执行所需的信息</p>
<h1 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————"></a>——————————————————</h1><h3 id="文件-基础源-执行-字符集"><a href="#文件-基础源-执行-字符集" class="headerlink" title="文件/基础源/执行 字符集"></a>文件/基础源/执行 字符集</h3><h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>语法：<br>/*注释*/    c语言风格<br><code>//注释        cpp风格(C99)</code></p>
<p>注意：</p>
<ul>
<li><p>因为注释在预处理器阶段前，宏不能用于组成注释，而不终止的 C 风格注释不会从被 #include 的文件中漏出</p>
</li>
<li><p>C99 中引入 // 注释，在一些场合是破坏性更改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = b <span class="comment">//*除数：*/ c</span></span><br><span class="line">+ d; </span><br><span class="line"><span class="comment">/* C89 编译为 a = b / c + d;C99 编译为 a = b + d; */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>ISO C 要求诊断是否有任何不列于此的字符出现于反斜杠之后<br><img src="E:\my_blog_luq\source\other\转义序列.png" alt="转义序列"></p>
<h4 id="ASCII数值转义码表"><a href="#ASCII数值转义码表" class="headerlink" title="ASCII数值转义码表"></a>ASCII数值转义码表</h4><p><img src="E:\my_blog_luq\source\other\ascii.png" alt="ascii"></p>
<h4 id="Unicode转义通用字符"><a href="#Unicode转义通用字符" class="headerlink" title="Unicode转义通用字符"></a>Unicode转义通用字符</h4><p><code>可用通用字符名的范围(C99)</code><br>若通用字符名对应<br>除0x24($),0x40(@),0x60(`)外的小于 0xA0 的码位<br>代理码位(0xD800-0xDFFF,含两端)<br><code>大于0x10FFFF(即不是Unicode码位)(C23)</code><br>则程序为非良构(程序无法编译)<br>换言之，基础源字符集与控制字符(0x0-0x1F与0x7F-0x9F中)不能以通用字符名表达</p>
<p>注意：</p>
<ul>
<li>\0 在八进制转义序列中最常用(警惕这里不是十进制，即\32不代表空格)，因为它表示空终止字符串中的空终止字符八进制转义序列拥有三个八进制位的长度限制，但若提前遇到不是合法八进制位的字符，则在首个这种字符处终止<br>换行符\n在用于文本模式I/O时有特殊含义，它被转换为 OS 限定的换行表示，通常是字节或字节序列，某些系统替而用长度域标记其文本行</li>
<li>十六进制转义序列无长度限制，并在首个不是合法十六进制位的字符处终止，若单个十六进制转义序列所表示的值不适于此字符串字面量或字符常量中使用的字符类型(char、char16_t、char32_t (C11)`或 wchar_t)则结果未指定</li>
<li>通用字符名可能映射到多于一个编码单元</li>
<li>问号转义序列\?用于阻止在字符串字面量内转译三标符(三字符组)</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是区分大小写的以拉丁字母、下划线<code>或Unicode非数字字符(C99)</code>开始的以数字、下划线、小写及大写拉丁字母和以<code>\u及\U指定的Unicode字符 (C99)</code>组成的有限长度序列<br><code>内部标识符或宏名中31/63个有效起始字符
外部标识符中6/31个有效起始字符
一个翻译单元中511/4095个外部标识符
一个块中声明127/511个拥有块作用域的标识符</code><br><code>一个预处理翻译单元中同时定义1024/4095个宏标识符(C99前/后)</code></p>
<p>宏名或宏形参名以外的每个标识符都拥有作用域，属于命名空间，并且可以拥有链接，相同的标识符可以在程序的相异点指代相异实体，或若实体在不同的命名空间中，则可在相同点指代相异实体</p>
<p>保留标识符(声明会产生未定义行为)：关键字，以下划线开始的外部标识符，以双下划线开始符或下划线随大写字母开始的标识符(保留标识符允许库使用大量幕后的非外部宏及函数)，标准库所提供的每个标识符，<a href="https://zh.cppreference.com/w/c/language/identifier"><code>潜保留标识符(C23可用)</code></a></p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>每个标识符都仅在一些可能不连续的部分可见(使用)，这些部分被称为该标识符的作用域，在作用域内，标识符仅若在不同命名空间中，才可以指代多于一个实体，作用域有四种：块作用域，文件作用域，函数作用域，函数原型作用域</p>
<p>一般标识符的作用域，在声明点开始，在声明于其中的块或语句的结尾结束<br>特殊：<br>声明于函数内部的标号有函数作用域，在该函数中的所有位置都在作用域内，但注意：任何语句前的冒号前的标识符，若不用于其他用途，则隐式声明为标号<br>结构体、联合体及枚举标签的作用域，在声明完该标签后(声明列表前)立即开始<br>枚举常量的作用域，在枚举项列表中其定义枚举项的出现后立即开始</p>
<p>若相同标识符所命名的不同实体，同一时刻都在同一作用域中，则内层作用域中的声明隐藏外层作用域中的声明<code>尽管若在语句中使用复合语句，则它拥有其通常的块作用域(C99前)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处的命名空间为通常标识符。</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//文件作用域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//块作用域，隐藏文件作用域</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a = <span class="number">2</span>;<span class="comment">//内层块作用域，隐藏外层块作用域</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);<span class="comment">//打印2</span></span><br><span class="line">    &#125;<span class="comment">//内层块作用域结束                    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);<span class="comment">//打印1</span></span><br><span class="line">&#125;<span class="comment">//外层块作用域结束                        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a)</span>;<span class="comment">//函数原型作用域，隐藏文件作用域</span></span><br></pre></td></tr></table></figure>
<h4 id="查找与命名空间"><a href="#查找与命名空间" class="headerlink" title="查找与命名空间"></a>查找与命名空间</h4><p>遇到标识符时，根据使用方式在所属的命名空间中查找该标识符<br>不同命名空间的同一标识符可以同时出现在同一作用域中</p>
<p>标号命名空间：所有声明为标号的标识符<br>标签命名空间：所有声明为struct ,union,enum名称的标识符(这三种标签共享同一命名空间)<br>成员命名空间：所有声明为struct或union成员的标识符(每个结构体和联合体引入它自己的这种命名空间)<br><code>全局属性命名空间：标准定义的属性记号或实现定义的属性前缀
非标准属性命名空间：属性前缀后的属性名(每个属性都有一个单独的名称空间用于引入的实现定义的属性)(C23)</code><br>通常标识符命名空间：所有其他标识符(函数名,对象名, typedef名,枚举常量)</p>
<p>作为goto语句运算数出现的标识符，会在标号命名空间中查找<br>struct,union,enum的标识符，会在标签命名空间中查找<br>成员访问的标识符，会在类型成员命名空间中查找(该类型由成员访问运算符左运算数确定)<br><code>直接出现于属性说明符[[...]]中的标识符，会在全局属性命名空间中查找
跟在::属性前缀后面的标识符，会在属性前缀所引入命名空间中查找(C23)</code><br>其他标识符，会在通常命名空间中查找</p>
<p>宏的名称不是任何名称空间的一部分，它们在语义分析之前被预处理器替换</p>
<p>通常的做法是使用typedef声明将结构/联合/枚举名称注入到普通标识符的名称空间中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span>; &#125; <span class="comment">//通常命名空间，文件作用域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span>      <span class="comment">//标签命名空间，文件作用域</span></span><br><span class="line">    <span class="type">int</span> foo;      <span class="comment">//struct foo类的的成员命名空间，文件作用域</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bar</span> &#123;</span>    <span class="comment">//标签命名空间，文件作用域</span></span><br><span class="line">        RED       <span class="comment">//通常命名空间，文件作用域</span></span><br><span class="line">    &#125; bar;        <span class="comment">//struct foo类的成员命名空间，文件作用域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>* <span class="title">p</span>;</span><span class="comment">//标签命名空间/文件作用域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bar</span> <span class="title">x</span>;</span> <span class="comment">//标签命名空间/文件作用域</span></span><br><span class="line"><span class="comment">//int foo; //查找通常命名空间/文件作用域已有foo报错</span></span><br><span class="line"><span class="comment">//union foo &#123; int a, b; &#125;; //查找标签命名空间/文件作用域已有foo报错</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> foo; <span class="comment">//查找标号命名空间/函数作用域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span> <span class="comment">//标签命名空间/块作用域，文件作用域隐藏</span></span><br><span class="line">       <span class="class"><span class="keyword">enum</span> <span class="title">bar</span> <span class="title">x</span>;</span> <span class="comment">//查找标签命名空间/文件作用域</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">foo</span>;</span> </span><br><span class="line">    <span class="comment">//查找标签命名空间/块作用域</span></span><br><span class="line">    <span class="comment">//通常命名空间，块作用域的，文件作用域隐藏</span></span><br><span class="line">    (foo)&#123;.x=RED&#125;; </span><br><span class="line">    <span class="comment">//查找通常命名空间/块作用域</span></span><br><span class="line">    <span class="comment">//查找通常命名空间/文件作用域</span></span><br><span class="line">foo:;<span class="comment">//标号命名空间，函数作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象是执行环境中数据储存的区域，其内容可以表示值(值是转译为特定类型时的内容)<br>每个对象的属性有：标识符，有效类型，大小，对齐要求，值，储存器，生存期<br>对象由声明、分配函数、字符串字面量、复合字面量、以及返回拥有数组类型的struct/union的非左值表达式创建</p>
<h5 id="对象表示"><a href="#对象表示" class="headerlink" title="对象表示"></a>对象表示</h5><p>除了位字段，对象由一个或多个字节的连续序列组成，每个字节由CHAR_BIT位组成，可以复制memcpy到一个类型的对象中unsigned char[n]，其中n为对象的大小，结果数组的内容被称为对象表示</p>
<p>若对象的对象表示相同，则它们比较时相等（除了它们是浮点数NaN的情况）。但比较时相等的对象，可以有不同的对象表示。因为并非对象表示的每一位都需要参与其值，这些位可以用于填充以满足对齐要求，等同性检测，指示陷阱表示等</p>
<h5 id="有效类型"><a href="#有效类型" class="headerlink" title="有效类型"></a>有效类型</h5><p>用于决定合法左值访问的方式，声明类型即为有效类型<br>对于分配的无有效类型对象，在第一次    写入非字符类型|复制内存|其他访问    时获得类型</p>
<h5 id="严格别名使用"><a href="#严格别名使用" class="headerlink" title="严格别名使用"></a>严格别名使用</h5><p>对象应仅由具有以下类型之一的左值表达式访问其存储值，否则结果未定义(大部分已经实现定义)<br>兼容类型,char,signed char,unsigned char,有效类型的有无符号类型,无限递归下去能包含有效类型的联和或聚合体!!!</p>
<p><a href="https://blog.csdn.net/ashjn2011/article/details/9627405?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=严格别名规则&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-9627405.142^v47^pc_rank_34_default_3,201^v3^control&amp;spm=1018.2226.3001.4187">类型双关(type punning)与严格别名(strict aliasing)_凄凉赤的博客-CSDN博客</a></p>
<h5 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h5><p>每个对象都有一个常量地址，用于保留其最后存储的值(除非该值不确定)<code>对于 VLA还要保留长度(C99)</code>；对于声明有自动、静态及线程存储期的对象，生存期等于其存储期，对于拥有分配存储期的对象，始于内存分配终于释放内存，注意分配的内存无类型，在首次访问时才成为有效类型</p>
<p>在生存期外访问对象是未定义行为，指向生存期结束的对象的指针拥有不确定值</p>
<p>非左值表达式指代的带有结构或联合类型中包含具有数组类型的成员拥有临时生存期，临时生存期始于求值指代该对象的表达式，<code>终于下一个序列点(C11前)包含它的完整表达式或完整声明器结束(C11)</code></p>
<p>任何修改临时生存期对象的尝试会导致未定义行为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span> <span class="type">double</span> a[<span class="number">4</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> T <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> (<span class="keyword">struct</span> T)&#123;<span class="number">3.15</span>&#125;; &#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">g1</span><span class="params">(<span class="type">double</span>* x)</span> &#123; <span class="keyword">return</span> *x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g2</span><span class="params">(<span class="type">double</span>* x)</span> &#123; *x = <span class="number">1.0</span>; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d = g1(f().a); </span><br><span class="line">    <span class="comment">// C99,UB,访问生存期结束于序列点</span></span><br><span class="line">    <span class="comment">// C11,OK,d为3.15</span></span><br><span class="line">    g2(f().a); </span><br><span class="line">    <span class="comment">//C99,UB,修改生存期结束于序列点</span></span><br><span class="line">    <span class="comment">//C11,UB,试图修改临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h5><p>每个完整类型拥有一个称作对齐要求的属性，它是一个size_t类型的整数值，表示此类型对象可以分配的    连续内存之间    的字节数，每个对象类型将其对齐要求强加于该类型的任何一个对象<br>所有类型中，最最大的基础对齐是max_align_t，最小的对齐是字符类型</p>
<p><code>类型的对齐要求可以通过_Alignof获得(C11)</code></p>
<p>为了满足结构体所有对象的对齐要求，一些成员后面可能会插入填充位</p>
<p>若用_Alignas令一个对象的对齐大于max_align_t，则它拥有扩展对齐要求<br>成员拥有扩展对齐的结构体或联合体是   过对齐类型<br>是否支持过对齐类型是实现定义的，而且对于每种存储期的支持可以不同</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="main函数！！！"><a href="#main函数！！！" class="headerlink" title="main函数！！！"></a>main函数！！！</h5><p>int main(void){body}<br>int main(int arg,char<em>argv[]){body}<br>`/</em>其他*/(C99)`</p>
<p>名称argc和argv表示参数计数和参数向量<br>argv有argc+1个，argv末元素是空字符串，argc&gt;0则argv[0]为程序运行的全路径名<br>main的常见实现定义形式是int main(int argc, char *argv[], char *envp[])<br>其中第三参数指向执行环境变量</p>
<p>main若return，则其返回值会作为隐式调用exit()的参数，0与EXIT_SUCCESS表示成功终止，EXIT_FAILURE表示不成功终止</p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><h4 id="结构体或联合体成员"><a href="#结构体或联合体成员" class="headerlink" title="结构体或联合体成员"></a>结构体或联合体成员</h4><h4 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h4><h4 id="typedef名"><a href="#typedef名" class="headerlink" title="typedef名"></a>typedef名</h4><h4 id="标号名"><a href="#标号名" class="headerlink" title="标号名"></a>标号名</h4><h4 id="宏名"><a href="#宏名" class="headerlink" title="宏名"></a>宏名</h4><h4 id="宏形参名"><a href="#宏形参名" class="headerlink" title="宏形参名"></a>宏形参名</h4><h3 id="常量与字面量"><a href="#常量与字面量" class="headerlink" title="常量与字面量"></a>常量与字面量</h3><p> [整数常量 integer_constant)<br> [浮点常量 floating_constant)<br> [字符常量 character_constant)<br> [<code>true</code>/<code>false</code> bool_constant)(C23)<br> [<code>nullptr</code> nullptr)(C23)<br> [字符串字面量 string_literal)<br> [复合字面量 compound_literal)(C99)</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h3 id="标点及其含义"><a href="#标点及其含义" class="headerlink" title="标点及其含义"></a>标点及其含义</h3><p>{ }<br>在struct或union定义中划分出结构体声明列表<br>在enum定义中划分出枚举列表<br>划分出复合语句，复合语句可以是函数定义的一部分<br>初始化时，划分出初始化器列表</p>
<p>[ ]<br>下标运算符<br>声明或类型标识中，数组声明符的一部分<br><code>初始化时，指派数组元素(C99)</code><br><code>属性说明符中，划分出属性(C23)</code></p>
<p>#<br>预处理指令起始标志<br>字符串化的预处理操作</p>
<p>##<br>用于连接字符串的预处理操作</p>
<p>( )<br>表达式分组，改变结合顺序<br>声明或类型标识中分组，改变结合顺序<br>函数声明中划分出参数列表<br>if、switch 、while、do或for语句中，划分出控制块<br>函数调用运算符<br>sizeof或<code>_Alignof(C11起)</code>表达式中划分出运算对象<br>显式类型转换中划分出类型标识<br><code>复合字面量中划分出标识(C99)</code><br>仿函数宏定义中，划分出宏参数<br>defined、<code>__has_include或__has_c_attribute预处理运算符的一部分(C23)</code>预处理运算符的一部分<br><code>泛型选择表达式 generic)的一部分(C11)</code><br><code>_Atomic类型说明符中,划分出类型标识(C11)</code><br><code>静态断言声明中，划分出操作对象(C11)</code><br><code>_Alignas说明符中，划分出操作对象(C11)</code><br><code>属性中, 划分出操作对象(C23)</code></p>
<p>;<br>语句和声明和声明列表的结束标志<br>分隔for的()中的第二和第三子句</p>
<p>:<br>条件运算符的一部分<br>标签声明的一部分<br>标志位域成员声明的宽度的起始<br><code>泛型关联中，分隔类型标识或default和待选表达式(C11)</code></p>
<p>…<br>函数声明的参数列表中, 标志变长参数<br><code>宏定义中, 标志变参数宏(C99)</code></p>
<p>?<br>条件运算符的一部分</p>
<p>::<br><code>在属性中指示属性作用域(C23)</code></p>
<p>.<br>成员访问运算符<br><code>在初始化时，标志struct/union成员指派符的起始(C99)</code></p>
<p>-&gt;<br>成员访问运算符</p>
<p>~<br>一元补运算符(又称逐位非运算符)</p>
<p>! + - / % ^ &amp; |<br> -= *= %= ^= &amp;= |= +=<br>&lt;&lt; >><br>== != &lt;= >= &lt;&lt;= >>=<br>&amp;&amp; ||<br>++ —<br>运算符</p>
<p>*<br>间接引用运算符(解引用运算符)<br>乘法运算符<br>声明符或类型标识中的指针运算符或成员指针运算符<br><code>函数声明的变长数组(参数)声明中的数组长度占位符(C99)</code></p>
<p>=<br>简单赋值运算符<br>在初始化中，分隔对象和初始化列表<br>在枚举定义中引入枚举常量的值</p>
<p>&lt;<br>小于运算符</p>
<h1 id="include指令中标志头文件名起始。"><a href="#include指令中标志头文件名起始。" class="headerlink" title="include指令中标志头文件名起始。"></a>include指令中标志头文件名起始。</h1><p>><br>大于运算符</p>
<h1 id="include指令中标志头文件名结束。"><a href="#include指令中标志头文件名结束。" class="headerlink" title="include指令中标志头文件名结束。"></a>include指令中标志头文件名结束。</h1><p>,<br>逗号运算符<br>以下列表的列表分隔符：<br>      声明中声明符列表<br>      <code>初始化，包括复合字面量中的初始化器列表(C99)</code><br>      函数调用中实参列表<br>      枚举声明中的枚举项列表<br>      仿函数宏定义中宏形参列表<br>      <code>泛型选择表达式)中泛型关联列表(C11)</code><br>     <code>属性列表(C23)</code><br><code>静态断言声明中分隔参数(C11)</code><br><code>泛型选择表达式中，分隔控制表达式和泛型关联列表(C11)</code></p>
<h3 id="其他预处理记号"><a href="#其他预处理记号" class="headerlink" title="其他预处理记号"></a>其他预处理记号</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li><p>void</p>
</li>
<li><p>基本类型</p>
<ul>
<li>char</li>
<li>有符号整型(signed char,short,int long,<code>long long与其他实现定义(C99)</code>)</li>
<li>无符号整型(unsigned char,unsigned short,unsigned int,unsigned long,<code>_Bool(C99),unsigned long long与其他实现定义</code>)</li>
<li>浮点类型<ul>
<li>实浮点类型(float,double,long double)</li>
<li><code>十进制实浮点类型(_Decimal32 、 _Decimal64 、 _Decimal128)(C23)</code></li>
<li><code>复数类型(float _Complex 、 double _Complex 、 long double _Complex)(C99)</code></li>
<li><code>虚数类型(float _Imaginary 、 double _Imaginary 、 long double _Imaginary)(C99)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>枚举类型</p>
</li>
<li><p>派生类型：数组，结构体，联合体，函数，指针，<code>原子(C11)</code></p>
</li>
</ul>
<p>对于以上类型，可以用const,volatile,restrict(的组合)进行限定</p>
<p>在不同翻译单元中涉及同一对象或函数的声明，不必拥有相同类型，只需要拥有相似的类型即可兼容：<br>同一类型(typedef引入的别名)，指向兼容类型的指针，元素兼容大小相同的数组类型，<code>VLA(C99)</code>，<code>同一标签声明的(C99)</code>同成员数和顺序且对应位域宽度相同的结构体类型，<code>同一标签声明的(C99)</code>同成员数且对应位域宽度相同的联合体类型，<code>同一标签声明的(C99)</code>同成员数和相同值且为另一枚举的底层类型的枚举类型，返回类型兼容参数数量和类型相同<br>char与signed char和unsigned char都不兼容<br>若涉及同一对象或函数的二个声明不使用兼容类型，则程序的行为未定义</p>
<p>合成类型可以由两种兼容的类型构成，它是与这两种类型兼容并满足以下条件的类型：<br>其中一个类型是已知常量大小的数组，则复合类型是该大小的数组，<code>否则：如果一种类型是 VLA，其大小由未计算的表达式指定，则行为未定义；如果一个类型是指定了其大小的 VLA，则该复合类型为该大小的 VLA；如果一个类型是未指定大小的 VLA，则该复合类型是未指定大小的VLA(C99)</code>，对于函数参数列表则是一 一复合后合并派生</p>
<p>未指定大小的VLA和未知内容的结构体为不完整类型，void不可以完整</p>
<p>类型说明符允许任意顺序：unsigned long long int和long int unsigned long相同，unsigned int和int unsigned相同</p>
<h6 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h6><p><code>_Bool非0即1(C99)</code></p>
<p>标准定义了typedef名wchar_t,<code>char16_t,char32_t(C11)</code>以表示宽字符</p>
<p>1==sizeof(char)&lt;=sizeof(short)&lt;=sizeof(int)&lt;=sizeof(long)&lt;=sizeof(long long)</p>
<p>若支持浮点数则匹配IEEE-754 binary32/84/128格式<br>若实现预定义宏常量__STDC_IEC_60559_DFP__则支持十进制浮点类型<br>浮点类型支持±INFINITY<br>浮点类型支持非数NaN(表示未定义或不可表示的值)</p>
<ul>
<li>至少有一个参数是NaN的运算</li>
<li>不定式(0:0型，∞:∞型，∞-∞型)</li>
<li>产生复数结果的实数运算</li>
</ul>
<p>一些浮点数上的运算会受到浮点环境的影响(注意舍入方向)<br>实浮点类型与整数、复数和虚数类型间的隐式转换有定义</p>
<p>复浮点类型可以写成    “%f%+(可选格式符)fi”,creal(z) + I*cimag(z)    即a+bi<br>数组的第一元素保有实部，第二个元素保有虚部<br><code>若实现定义了__STDC_NO_COMPLEX__则不提供复数类型(C11)</code><br>虚浮点类型同上<br><code>若定义__STDC_IEC_559_COMPLEX__ (C23 前)__STDC_IEC_60559_COMPLEX__(C23)则支持虚数</code></p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>main</p>
<p>内存模型，数据竞争</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><h1 id="——————————————————-1"><a href="#——————————————————-1" class="headerlink" title="——————————————————"></a>——————————————————</h1><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h2 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h2>]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/03/28/git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>windows版的下载地址<a href="https://git-scm.com/">Git (git-scm.com)</a></p>
<p>linux版<br>Fedora用前者，Ubuntu用后者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install git-core</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install git</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>右键桌面，选择git bash here</p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;这里写你的名字&quot;</span></span><br><span class="line">$ git config --global user.email 这里写你的邮箱</span><br></pre></td></tr></table></figure>
<h2 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h2><p>在需要备份的文件夹下，右键，选择git bash here</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h3 id="拷贝项目"><a href="#拷贝项目" class="headerlink" title="拷贝项目"></a>拷贝项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> 这里写你要克隆的仓库</span><br></pre></td></tr></table></figure>
<h3 id="项目保存到当地"><a href="#项目保存到当地" class="headerlink" title="项目保存到当地"></a>项目保存到当地</h3><p>在已经有git项目的文件夹下会有.git的隐藏文件，里面存储着本地的项目快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add 项目</span><br><span class="line">$ git commit -m <span class="string">&quot;备注信息&quot;</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;备注信息&quot;</span></span><br></pre></td></tr></table></figure>
<p>add相当于给文件夹拍照，commit相当于将照片保存</p>
<h3 id="项目上传云端和从云端更新"><a href="#项目上传云端和从云端更新" class="headerlink" title="项目上传云端和从云端更新"></a>项目上传云端和从云端更新</h3><p>设置原创仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add 这里自定义仓库名 网址</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push 这里写要上传到的仓库 这里写需要上传的分支</span><br><span class="line">$ git fetch 这里写需要下载的仓库</span><br></pre></td></tr></table></figure>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><p>……待跟新</p>
<h1 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h1><p><a href="http://git.oschina.net/progit/">Pro Git（中文版） (oschina.net)</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>nas的简介、制作、使用</title>
    <url>/2022/04/21/nas%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h1><p>！！！——————————分隔线——————————！！！</p>
<p>！！！——————————分隔线——————————！！！</p>
<p>！！！——————————分隔线——————————！！！</p>
<h1 id="NAS介绍"><a href="#NAS介绍" class="headerlink" title="NAS介绍"></a>NAS介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>NAS（Network Attached Storage：网络附属存储）</p>
<p>相当于一个有好几块硬盘的<strong>低功耗</strong>电脑，硬盘中装了文件服务器和备份用的软件等等，让电脑专门用于存储。</p>
<p>把这个电脑连到家里网上，相当于实现了一个(某度)云盘。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>作为家庭数据中心</p>
<p>将资料放进 NAS，透过网络可以随时存取在 NAS 中的文件，还可以精确地管理与控制 NAS 的访问权限</p>
<p>NAS 支持 RAID 资料保护，让资料备份更加安全</p>
<p>支持多人在线访问文件</p>
<p>作为下载机，虚拟机</p>
<p>架设私有 VPN，架设私有云</p>
<p>……</p>
<p>总的来说：NAS 实际上就是一个私有云服务器，可以自己增删功能</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h3><p>目前市面上有很多 NAS 服务可供选择，如 win10 或 win server 做系统服务器。但家用NAS主机的功能并不丰富。目前主流的 NAS 系统是基于 Linux 系统二度开发的群晖和威联通主机，这两者在国内的普及率较高，功能和APP适配也比较完善</p>
<h3 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h3><p>无论是闲置的主机还是笔记本都可以作为NAS主机</p>
<p>功耗-电费问题例子：30天 <em> 24小时 </em> 50瓦 <em> 0.6元/度 </em> 1度/千瓦时 = 21.6元/月<br>一般cpu待机功耗在25w左右</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>性价比超高<br>与其他各种功能集成<br>扩展性强</p>
<h4 id="NAS主机的选择"><a href="#NAS主机的选择" class="headerlink" title="NAS主机的选择"></a>NAS主机的选择</h4><p>如：蜗牛星际主机，J1900或华擎J3455集成主板，猫盘(学习，随便玩玩)</p>
<p>下面是推荐优先级</p>
<p>手工搭建 &gt; 套件(蜗牛星际主机) &gt; 自己家里闲置的</p>
<h4 id="NAS系统的选择"><a href="#NAS系统的选择" class="headerlink" title="NAS系统的选择"></a>NAS系统的选择</h4><p>入门的话，群晖和威联通是最好的选择<br>这两大系统界面友好，功能强大，所配的套件齐全<br>对于入门和家庭使用已经完全足够了</p>
<p>如果要实现更丰富功能，要用更专业的NAS系统，如：FreeNAS、UNRIAD 、OVM等</p>
<h4 id="NAS硬盘的选择"><a href="#NAS硬盘的选择" class="headerlink" title="NAS硬盘的选择"></a>NAS硬盘的选择</h4><p>硬盘是nas最大的开销，花钱越多容量越大</p>
<p>有条件，可以上西数红盘，希捷酷狼之类的NAS专用盘，企业级的黑盘也是好选择</p>
<h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>nas 是用来用的，尽量以自己的需求和能力进行选择，不要一味想着用最好的，想让性能拉满，也不要为了折腾而折腾，做好了要拿来用，不要吃灰，毕竟 nas 主要作为家庭数据中心，家人用着好才是真的好。</p>
<p>！！！——————————分隔线——————————！！！</p>
<p>！！！——————————分隔线——————————！！！</p>
<p>！！！——————————分隔线——————————！！！</p>
<h1 id="NAS制作与使用"><a href="#NAS制作与使用" class="headerlink" title="NAS制作与使用"></a>NAS制作与使用</h1><p>以下diy流程仅供参考</p>
<h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><h3 id="需要材料"><a href="#需要材料" class="headerlink" title="需要材料"></a>需要材料</h3><p><strong>cpu</strong></p>
<p>使用低功耗u，不考虑性能，因为是24小时低强度工作</p>
<p><strong>主板</strong></p>
<p>可以选择NAS的集成主板，如：J1900、J3160、J3355</p>
<p>如果使用其他主板时要注意：有千兆以上的网口/网卡，尽量多的sata3(理论传输速率达到了6Gbps)，使用itx或者matx，让nas体积尽量小</p>
<p><strong>内存</strong></p>
<p>4g即可，使用主板对应内存</p>
<p>如：</p>
<p>平台              型号      频率                                内存大小<br>台式/笔记本 ddr3/4 1333/1600/2133/2400 4G</p>
<p><strong>电源</strong></p>
<p>型号可选：dc-atx，itx电源(小1u)(模组)，atx(模组)</p>
<p>瓦数选择200w~400w</p>
<p><strong>机箱</strong></p>
<p>可以选择普通大机箱，itx机箱，开放式机箱，亚克力自制机箱</p>
<p>取决于你要装什么主板，什么电源，多少硬盘</p>
<p><strong>其他配件</strong></p>
<p>sata线，千兆网线，u盘(需要作为系统/引导盘一直使用)，机械/固态硬盘</p>
<h3 id="抄作业"><a href="#抄作业" class="headerlink" title="抄作业"></a>抄作业</h3><p>方案1(懒人款)：蜗牛星际，小白or懒得折腾选这个，建议换个风扇和电源</p>
<p>方案2(进阶款)：J3455ITX，两条ddr3 1600 2G，酷鱼MGP机箱，dc-atx电源150w，2个2.5寸机械盘(最多4个但要改电源)</p>
<p>方案3(垃圾佬看这里)：J1800 或者 星际魔盒(注意矿渣) 或者 随便淘个小主机 再或者 用猫盘吧 0^0  注意再注意！一定要控制功耗！</p>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>选择使用群晖</p>
<p>nas网线连接光猫或路由器然后开机</p>
<p>手机下载群晖管家app，让手机和nas处于同一网络下 ，打开app，设置新NAS，注册<strong>群晖账户</strong>，点击安装，设置<strong>nas账户密码</strong>和QuickConnectC<strong>ID</strong><br>或者<br>电脑下载Synology Assistant和DSM系统，让电脑和nas处于同一网络下，右键设备，点击安装，设置<strong>nas账户密码</strong>，不勾选SHR，手动设置<strong>nas的后台ip地址</strong>，网页输入<strong>nas的后台ip地址</strong>（用于内网访问），输入<strong>nas账户密码</strong>登录，选择手动安装，注册<strong>群晖账户</strong>，设置QuickConnectCID</p>
<p>其他：需要换主机选择迁移即可，硬盘坏了raid恢复即可</p>
<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>网页输入<strong>nas的后台ip地址</strong>，，输入<strong>nas账户密码</strong>登录，进入<strong>nas后台</strong></p>
<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>点击左上角可以展开查看全部应用<br>右侧隐藏栏是系统通知<br>套件中心相当于应用商店，其中的社群中还有许多个人分享的应用</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>找到存储空间管理员，点击存储池，点击新建，选择灵活度提高(不需备份选择性能改善)，设置名字，选择raid类别，后续为默认设置，点击应用等待显示正常</p>
<p>点击存储空间，点击新建，选择刚刚新建的存储池，保持默认设置，点击应用等待显示正常</p>
<p>quickconnect确认启用，记住<strong>ID和域名</strong>（用于外网访问）<br>如果是公网ip可以使用ddns</p>
<p>网络可以设置系统名字，建议启用手动配置dns服务器8.8.8.8和114.114.114.114</p>
<p>在上方选择网络界面，选择当前已联机网络，选择编辑，手动设置网络配置<strong>nas的外网ip地址</strong>(外网设备地址)192.168.1.x(0~255，注意避免和nas的ip冲突)，255.255.255.0，若有多条网线则可以多路聚合，新建bond即可</p>
<p>进入路由器后台(一般为192.168.1.1)，找到nat虚拟服务器，新增条目，wan接口选择ppp2.3，自定义服务名称，(lan侧服务器)ip地址输入<strong>nas的外网ip地址</strong>，设置外部端口(<strong>外网访问时填的端口号</strong>)，设置内部端口(nas提供的服务端口)，选择协议</p>
<p>新增-服务提供商选择Synology-输入<strong>nas主机名字</strong>-输入<strong>nas账户密码</strong>（外网可以通过 <strong>nas主机名字</strong>.synology.me:端口号访问）</p>
<h4 id="群晖端口号查询"><a href="#群晖端口号查询" class="headerlink" title="群晖端口号查询"></a>群晖端口号查询</h4><p><a href="https://www.synology.com/zh-cn/knowledgebase/DSM/tutorial/Network/What_network_ports_are_used_by_Synology_services">https://www.synology.com/zh-cn/knowledgebase/DSM/tutorial/Network/What_network_ports_are_used_by_Synology_services</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h3><p>手机或者电脑下载DS File使用，nas后台为File Station</p>
<h4 id="控制面板-文件服务"><a href="#控制面板-文件服务" class="headerlink" title="控制面板-文件服务"></a>控制面板-文件服务</h4><p>启用SMB,AFP,NFS服务-SMB协议设置最大为SMB3(SMB1有漏洞)加密模式设为自动-记住共享文件的访问地址</p>
<p>mac系统打开finder-前往-连接服务器-输入共享文件的访问地址<br>windows系统-此电脑-地址栏直接输入共享文件的访问地址</p>
<p>启用FTP,SFTP服务</p>
<p>高级设置中，启用文件快速克隆,Bonjour(如果有mac系统才启用),SSDP,WS-Discovery服务</p>
<h4 id="控制面板-共享文件"><a href="#控制面板-共享文件" class="headerlink" title="控制面板-共享文件"></a>控制面板-共享文件</h4><p>新增-输入名字-选择存储空间(文件夹在哪块硬盘)-启用回收站-只允许管理者访问-不需要加密(后续可以设置权限)-启用数据检查-启用文件压缩-应用即可-权限设置取消(后续有补充)</p>
<p>动作-创建回收站清空计划-输入名称-计划-设置以下日期运行-任务设置(自行设置)-应用即可</p>
<h4 id="控制面板-用户群组"><a href="#控制面板-用户群组" class="headerlink" title="控制面板-用户群组"></a>控制面板-用户群组</h4><p>这里会有3个系统默认的群组，建议不去管它，使用自己新建的群组</p>
<p>新增-输入名字-输入说明-设置文件权限-设置可使用空间限制(默认不限)-设置应用权限(注意有些软件相互依赖)-设置速度(nas到客户端是上传)(记得改为自定义范围)-应用即可</p>
<h4 id="控制面板-用户面板"><a href="#控制面板-用户面板" class="headerlink" title="控制面板-用户面板"></a>控制面板-用户面板</h4><p><strong>用户账户</strong>-新增-输入名字-输入说明-勾选两个通知-勾选群组-(后续的权限不建议设置容易乱)-应用即可</p>
<p>高级设置-启用步骤验证<br>高级设置-启用家目录(用于服务很多基础应用)</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>权限：禁止，只读，可读写，未分配(相当于禁止，但是不参与并集)<br>拿到权限后，所在所有群组的权限的并集为获得的权限</p>
<h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>File Station升级版为Synology Drive<br>(建议两者都下载，云盘\多人协作\文件同步使用Drive，复制/粘贴/文件操作用Station)</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>套件中心-设置<br>调整安装位置-选择信任层级为任何发行者<br>开启自动更新(建议打开)<br>添加套件来源：名 synocommunity 位置 <a href="http://packages.synocommunity.com">http://packages.synocommunity.com</a><br>安装Synology Drive,Synology Office,Universal Search,文本查看器,文本编辑器</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Synology Drive下载后会出现以下3个程序<br>Synology Drive，Synology Drive管理控制台，Synology Drive ShareSync</p>
<p>打开Synology Drive，按照提示(保持默认设置)安装<strong>drive客户端</strong>到我们的电脑上<br>运行<strong>drive客户端</strong>-立即开始-同步任务-输入<strong>ID或域名</strong>-输入<strong>用户账户密码</strong><br>选择nas和本地各一个文件夹(建议新建)，drive将同步两个文件夹<br>(相当于icloud或one drive)(home/drive/为个人私有云文件夹,homes/为所有私有云文件夹)<br>drive可以实现分享功能<br>控制台可以实现版本控制</p>
<h3 id="Video-Station"><a href="#Video-Station" class="headerlink" title="Video Station"></a>Video Station</h3><p>Video Station为媒体服务器升级版<br>支持quickconnect，ddns，软硬解码，转码，分类，用户权限，下载字幕<br>客户端下载DS Video使用</p>
<h4 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h4><p>下载Video Station，FFmpeg</p>
<p>控制面板-终端机-启用SSH服务-端口号为22</p>
<p>回到MAC终端，输入 ssh <strong>nas账户</strong>@<strong>nas的外网ip地址</strong> -p 22回车，输入密码回车，输入vi/etc/host回车，输入i，在最后一行输入13.224.161.90 api.themoviedb.org，点击esc键，输入:wq回车，输入 cd ~ &amp;&amp; wget -N —no-check-certificate <a href="https://maopan.cc/mp2020/hosts">https://maopan.cc/mp2020/hosts</a> &amp;&amp; chmod 644 hosts &amp;&amp; mv -f /root/hohsts /ect/回车<br>或<br>回到windows则下载打开Putty，在Host Name输入<strong>nas的外网ip地址</strong>，在port输入22，点击open，输入<strong>nas账户</strong>回车，输入密码回车，输入sudo -i回车，输入密码回车，输入vi/etc/host回车，输入i，在最后一行输入13.224.161.90 api.themoviedb.org，点击esc键，输入:wq回车，输入cd ~ &amp;&amp; wget -N —no-check-certificate <a href="https://maopan.cc/mp2020/hosts">https://maopan.cc/mp2020/hosts</a> &amp;&amp; chmod 644 hosts &amp;&amp; mv -f /root/hohsts /ect/回车</p>
<p>putty下载地址:<br><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>电影和电视剧要分开放(以便搜刮器搜索)</p>
<p>电影要命名为电影.年份.格式<br>子文件夹要命名为电影名系列(或者x部，这样才能识别到子文件夹内全部，当电影被分成多个可以直接将文件夹命名成文件格式)</p>
<p>电视剧要命名为电视剧名.年份.S季数.E集数<br>子文件夹要命名为电视剧名.S季数.E</p>
<h4 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h4><p>打开Video Station-设置-创建视频库-选择对应的文件夹</p>
<p>权限设置：DTV是电视录制权限，AirPlay/DLNA是无线投屏权限，公开是分享权限，离线转码是转码权限</p>
<p>高级：api需要申请，注册激活，账号设置，请求API密钥，Developer，填个人信息，拿到api粘贴到群晖即可<br>转码设置全部勾选，公开共享选择允许转码<br>封面，自动搜索字母，视频分析 全部都勾选，需要注册OpenSubtitles</p>
<p>选项：勾选自动字母分析下载和AC3音频编码</p>
<p>全部设置完毕后，视频库-每一个库都导出视频信息</p>
<h3 id="Moments-Photo-Station"><a href="#Moments-Photo-Station" class="headerlink" title="Moments/Photo Station"></a>Moments/Photo Station</h3><p>Moments为Photo Station升级版</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>DS Photo</th>
<th>Moments</th>
</tr>
</thead>
<tbody>
<tr>
<td>智能识别</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Livephoto</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>360度照片</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>权限和多人协同</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>TV客户端</td>
<td>√</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<p>可以通过共享文件夹，实现两者都使用即得到全部功能，但是会导致使用空间翻倍</p>
<h4 id="Moments"><a href="#Moments" class="headerlink" title="Moments"></a>Moments</h4><h5 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h5><p>下载Moments，分配权限和端口<br>打开Moments-头像-设置-常规-不勾选来源-按月查看-百度地图-如果是第一次则选择全部重建索引-相册和管理员要全部勾选</p>
<p>File Station-home-Drive-Mobile-Moments这里是你的每一个设备</p>
<h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><p>用户安装Moments<br>输入<strong>ID或域名</strong>，输入<strong>用户账户密码</strong>-登录即可</p>
<h4 id="Photo-Station"><a href="#Photo-Station" class="headerlink" title="Photo Station"></a>Photo Station</h4><h5 id="准备-3"><a href="#准备-3" class="headerlink" title="准备"></a>准备</h5><p>准备下载Photo Station，分配权限和端口<br>控制面板-用户账户-高级设置-设置家目录所在位置<br>控制面板-索引服务-缩略图品质一般-启用移动设备视频转换</p>
<h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><p>用户安装DS Photo<br>输入<strong>ID和域名</strong>，输入<strong>用户账户密码</strong>-登录即可</p>
<h3 id="Audio-Station"><a href="#Audio-Station" class="headerlink" title="Audio Station"></a>Audio Station</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>下载Audio Station<br>控制面板-索引服务-索引文件夹-新增-输入后等待完成即可<br>建议文件夹为music-歌手或者分类1-专辑或者分类2(可以在每个文件夹下放入cover.jpg来设置封面)</p>
<p>打开Audio Station-设置<br>下载歌词插件，下载好后，点击新增，选中你下载的aum后缀文件，好了后点击新增即可</p>
<p>QQ音乐歌词插件<br><a href="https://pan.baidu.com/s/1O0pThGs8C6fWOL9JdusyiQ">https://pan.baidu.com/s/1O0pThGs8C6fWOL9JdusyiQ</a><br>提取码:3m7g<br>网易云音乐歌词插件<br>netease_org.aum是原文歌词<br>netease_trans.aum 是带中文翻译<br>链接地址:<a href="https://github.com/LudySu/Synology-LrcPlugin/releases">https://github.com/LudySu/Synology-LrcPlugin/releases</a> </p>
<p>点击选项，选择转码MP3，选择支持DUE，选择个人音乐库</p>
<h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>用户安装DS Audio<br>输入<strong>ID或域名</strong>，输入<strong>用户账户密码</strong>-登录即可</p>
<h2 id="黑群晖"><a href="#黑群晖" class="headerlink" title="黑群晖"></a>黑群晖</h2><p>准备u盘为16GB</p>
<p>在电脑上下载固件和安装工具</p>
<p>使用 DiskGenius 删除u盘所有分区<br>新建1个分区，类型为MBR</p>
<p>使用 ChipGenis芯片无忧 记录u盘设备的VID和PID</p>
<p>使用 Win32Disklmager 设备选中u盘<br>镜像文件选择.img结尾的群晖固件，写入即可</p>
<p>使用 DiskGenius 找到u盘文件目录中的grub文件夹下的grub.cfg<br>右键复制到桌面，然后用记事本打开<br>往下找到set vid=0x和set pid=0x后面的数字改为刚刚记住的数字<br>sn和mac为序列号和网口编号建议修改<br>修改后拖回 DiskGenius 中的原文件夹下替换</p>
<p>拔下u盘插到nas上，连接网线硬盘<br>开机按Del键进入Bios,选择硬盘为第一启动项，保存退出后重启<br>显示happy hacking为引导完成</p>
<p>后续同白群晖操作</p>
<p>注意不要登陆quickconnect</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p> <a href="https://pan.baidu.com/s/10SeShlkCsWRmnO8eCYUQ9A#list/path=%2F">黑群晖_免费高速下载|百度网盘-分享无限制 (baidu.com)</a><br>6aba</p>
<h3 id="洗白"><a href="#洗白" class="headerlink" title="洗白"></a>洗白</h3><p>黑群晖不可以使用QC，预览图为黑色，无法调节码率等<br>半洗白不可以使用QC<br>洗白同白群晖</p>
<h4 id="半洗白方法"><a href="#半洗白方法" class="headerlink" title="半洗白方法"></a>半洗白方法</h4><p>套件中心安装virtual machine manager<br>映像-新增-从Synology下载<br>虚拟机-新增-Synology virtual DSM<br>虚拟机-开机-使用已有许可证<br>登录虚拟机后台-信息中心看序列号<br>替换u盘的引导程序里的sn即可 或者 ssh修改内核文件</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>可以参考</p>
<p><a href="https://blog.csdn.net/wxb915397070/article/details/111953722?ops_request_misc=%7B%22request%5Fid%22%3A%22165079147616782184650676%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165079147616782184650676&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-111953722.142^v9^control,157^v4^control&amp;utm_term=群辉NAS从入门到精通的所有&amp;spm=1018.2226.3001.4187">群晖NAS从入门到精通的所有帖子汇总，只要这一篇就够了!_酒醉疯子的博客-CSDN博客_群晖</a></p>
]]></content>
      <categories>
        <category>nas</category>
      </categories>
      <tags>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2022/07/20/vim/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vi为linux的文本编辑器<br>vim为vi的升级，支持代码补全，编译和错误转跳<br>如今vi已经是vim的软链接</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>没有图形界面<br>不支持鼠标操作<br>没有菜单<br>只有命令</p>
<h2 id="打开vim"><a href="#打开vim" class="headerlink" title="打开vim"></a>打开vim</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名</span><br></pre></td></tr></table></figure>
<p>如果路径下存在该文件则打开，否则新建后打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名 +行数</span><br></pre></td></tr></table></figure>
<p>打开文件并定位到对应行数<br>注意不加行数默认最后一行</p>
<h2 id="使用vim"><a href="#使用vim" class="headerlink" title="使用vim"></a>使用vim</h2><h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><p>打开文件后进入的是<strong>命令模式</strong></p>
<p><strong>命令模式</strong>下按下  <strong>:</strong>  进入<strong>末行模式</strong>，此时退出按下<strong>esc</strong>即可<br><strong>命令模式</strong>下按下  <strong>i</strong>  <strong>I</strong>  <strong>a</strong>  <strong>A</strong>  <strong>o</strong>  <strong>O</strong>分别是在当前光标的 前一个字符前，行首，后一个字符前，行尾，上方新开一行，下方新开一行进入<strong>编辑模式</strong><br><strong>命令模式</strong>下<strong>v</strong>,<strong>V</strong>,<strong>Ctrl+v</strong>变为<strong>可视(行，块)</strong>(相当于win右键选择，注意此时仍旧是命令模式)此时取消按下<strong>esc</strong>即可</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p><strong>命令模式</strong>下<strong>h</strong>,<strong>j</strong>,<strong>k</strong>,<strong>l</strong>分别对应光标向左下上右移动<br><strong>命令模式</strong>下<strong>w</strong>,<strong>b</strong>,<strong>^</strong>,<strong>0</strong>,<strong>$</strong>分别对应光标向后一个词，前一个词，第一个词，行首，行尾移动<br><strong>命令模式</strong>下<strong>H</strong>,<strong>M</strong>,<strong>L</strong>分别是光标移动到屏幕顶部，中间，底部的行首<br><strong>命令模式</strong>下<strong>数字gg</strong>或<strong>数字G</strong>转跳到对应行数，gg不加数字则默认文件头，G不加数字则默认文件尾<br><strong>命令模式</strong>下<strong>{</strong>,<strong>}</strong>分别是光标跳转到上或下一段落(用空行隔开)上方的空行<br><strong>命令模式</strong>下<strong>Ctrl+b</strong>,<strong>Ctrl+f</strong>分别是向上和向下翻页<br><strong>命令模式</strong>下<strong>%</strong>用于光标在成对的括号间切换<br><strong>命令模式</strong>下<strong>m大写或小写字母</strong>进行标记行，<strong>‘大写或小写字母</strong>回到标记行</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p><strong>命令模式</strong>下<strong>u</strong>,<strong>Ctrl+r</strong>分别是撤销和重做<br><strong>命令模式</strong>下<strong>.</strong>则为重复操作</p>
<p><strong>命令模式</strong>下<strong>数字x</strong>删除数字个(默认1)字符</p>
<p><strong>命令模式</strong>下<strong>数字d</strong>删除可视内容<br><strong>命令模式</strong>下<strong>数字dd</strong>删除数字个(默认1)行<br><strong>命令模式</strong>下<strong>D</strong>删除到行尾<br><strong>命令模式</strong>下<strong>y</strong>为复制，用法完全同d<br><strong>命令模式</strong>下<strong>p</strong>为粘贴(注意是vim剪切板，不是系统剪切板)<br><strong>编辑模式</strong>下鼠标右键可以复制粘贴到系统剪切板</p>
<p><strong>命令模式</strong>下<strong>r</strong>后则可直接输入进行替换一个字符<br><strong>命令模式</strong>下<strong>R</strong>后则可一直修改，返回按下<strong>esc</strong>即可<br><strong>命令模式</strong>下<strong>&lt;&lt;</strong>,<strong>&gt;&gt;</strong>分别是行或可视行向左，右缩进</p>
<h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p><strong>命令模式</strong>下<strong>/内容</strong>则内容会被高亮此时<strong>n</strong>找到下一个，<strong>N</strong>找到上一个<br><strong>命令模式</strong>下<strong>*</strong>,<strong>#</strong>分别是向下和上高亮光标所在单词<br><strong>末行模式</strong>下<strong>%s/旧内容/新内容/g</strong>则为全局替换<br><strong>末行模式</strong>下<strong>s/旧内容/新内容/g</strong>则为可视内容替换<br><strong>末行模式</strong>下<strong>%s/旧内容/新内容/g</strong>则为全局选择性替换<br>y为替换，n为不替换，q为退出替换，\^E向下滚屏，\^Y向上滚屏</p>
<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p><strong>末行模式</strong>下<strong>w</strong>后回车进行保存<br><strong>末行模式</strong>下<strong>q</strong>后回车进行退出(必须已保存)<br><strong>末行模式</strong>下<strong>q!</strong>后回车进行强制退出<br><strong>末行模式</strong>下<strong>wq</strong>或者<strong>x</strong>后回车进行保存退出<br><strong>末行模式</strong>下<strong>数字</strong>后回车则光标到对应行首</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在使用时vim编辑器时，会有一个.文件名.swp的交换文件(实时备份)<br>保存退出时会用swp文件代替源文件<br>如果vim异常退出，再次打开文件时，会询问保留哪一个</p>
<p>根据提示选择即可，注意需要处在英文输入法</p>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>待完善……</p>
<h2 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h2><p><a href="https://yianwillis.github.io/vimcdoc/doc/usr_04.html#04.7">VIM 中文用户手册: 做小改动 (yianwillis.github.io)</a></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>win下 hexo架构+butterfly主题+live2d看板娘 博客搭建</title>
    <url>/2022/03/09/win%E4%B8%8B-hexo%E6%9E%B6%E6%9E%84-butterfly%E4%B8%BB%E9%A2%98-live2d%E7%9C%8B%E6%9D%BF%E5%A8%98-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要git<br>下载nodejs lts版本 nodejs.org/zh-cn/<br>安装时选择固定路径，勾选自动安装相关软件<br>cmd下： (或者git下用linux指令)<br>npm install -g cnpm —registry=<a href="http://registry.npm.taobao.org">http://registry.npm.taobao.org</a><br>cnpm install -g hexo-cli</p>
<h2 id="依次输入指令"><a href="#依次输入指令" class="headerlink" title="依次输入指令"></a>依次输入指令</h2><p>chdir查看当前目录<br>md blog或者mkdir E:\blog（最好不要blog，改个名字)<br>e:<br>cd e:\blog<br>进入根目录<br>hexo init<br>npm install<br>hexo s<br>hexo n “a”创建文件<br>cd source_posts<br>修改文件<br>cd..退回上一文件夹<br>hexo g本地静态保存<br>hexo s本地localhost:4000启动(在s后加  -p 改端口)</p>
<h2 id="静态网页实现"><a href="#静态网页实现" class="headerlink" title="静态网页实现"></a>静态网页实现</h2><p>在gitee(要ppage)或者github上创建公开仓库.io结尾<br>cnpm install —save hexo-deployer-git<br>编辑_config.yml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: 	</span><br><span class="line">	gitrepo: https://github.com/你的用户名.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<p>hexo d 推送博客到远端</p>
<h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/butterfly  下载主题<br>(没pug和stylus渲染器要下载)<br>编辑_config.yml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes:butterfly</span><br></pre></td></tr></table></figure>
<p>hexo clean清除缓存文件和已生成公开文件<br>hexo g</p>
<h2 id="添加live2d看板娘"><a href="#添加live2d看板娘" class="headerlink" title="添加live2d看板娘"></a>添加live2d看板娘</h2><p>npm uninstall —save hexo-helper-live2d(如果下载了官方的要卸载)<br>cd进入themes/butterfly/source<br>git clone <a href="https://github.com/stevenjoezhang/live2d-widget.git(443报错就等等再试">https://github.com/stevenjoezhang/live2d-widget.git(443报错就等等再试</a>)<br>修改live2d-widget的autoload.js的live2d_path改为下方那个<br>进入butterfly下layout下includes的head.pug末尾粘贴</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script(src=&#x27;live2d-widget/autoload.js&#x27;)</span><br></pre></td></tr></table></figure>
<p>最后在根目录下的config加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">	enable:true</span><br></pre></td></tr></table></figure>
<p>修改ive2d-widget的参数：<br>    waifu.css修改位置<br>    waifu-tips.js修改文本</p>
<h2 id="增加搜索"><a href="#增加搜索" class="headerlink" title="增加搜索"></a>增加搜索</h2><p>npm install hexo-generator-searchdb —save<br>vim source/_data/butterfly.yml<br>localsearch改true</p>
<h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><p>hexo手册<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><br>butterfly文档<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a><br>改网站搜索免费社交图标<a href="https://fontawesome.com/v5.15/icons?d=gallery&amp;p=1&amp;m=free">https://fontawesome.com/v5.15/icons?d=gallery&amp;p=1&amp;m=free</a><br>改网站顶置图片<a href="https://pic.netbian.com/4kdongman/">https://pic.netbian.com/4kdongman/</a><br>live2d内容网站：<br>api:github.com/fghrsh/live2d_api<br>模型:github.com/summerscar/live2dDemo<br>参考:<a href="https://www.fghrsh.net/post/123.html">https://www.fghrsh.net/post/123.html</a><br> waifu-tips.js 的详细设置说明，和 waifu-tips.json 节点说明，见<a href="https://github.com/fghrsh/live2d_demo">https://github.com/fghrsh/live2d_demo</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>不定积分</title>
    <url>/2022/03/31/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<p>f(x) + c = ∫f’(x)dx<br>运算法则类似导数运算</p>
<h2 id="求不定积分"><a href="#求不定积分" class="headerlink" title="求不定积分"></a>求不定积分</h2><p>从上到下检索变换规律，每次变化前检查是否能凑微分</p>
<h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><p>分情况讨论</p>
<h3 id="特定形式"><a href="#特定形式" class="headerlink" title="特定形式"></a>特定形式</h3><h4 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h4><p>对于两个初等函数乘积的积分(v=反对幂指三)(先后)<br>∫vdu = uv - ∫udv<br>注意：指三需要循环求</p>
<h4 id="猜测法"><a href="#猜测法" class="headerlink" title="猜测法"></a>猜测法</h4><p>∫g(x)/f(x)^2dx=F(x)+c<br>设F(x)=u(x)/f(x)<br>则g=u’f-uf’直接猜测法</p>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>假分数：<br>通过除法变为真分数</p>
<p>真分数：<br>分母裂项(因式分解，待定系数法求分子)<br>分子去和差<br>分子变化为常数(e^x除外)<br>对于三角则凑出类似下方格式来凑微分 即 [A(导数)+B(原函数)]/原函数</p>
<script type="math/tex; mode=display">
[a(sinx-cosx)+b(sinx+cos)]/(sinx+cosx)</script><p>分母配方(平方和)</p>
<h3 id="根式换元"><a href="#根式换元" class="headerlink" title="根式换元"></a>根式换元</h3><p>√((ax+b)/(cx+d)) 用 sin^2 + cos^2 = 1<br>√(ax+b)或√(e^x+b)直接换<br>√(ax^2+bx+c) 配方后三角换元</p>
<h3 id="三角处理"><a href="#三角处理" class="headerlink" title="三角处理"></a>三角处理</h3><p>三角变换<br>奇次凑微分<br>偶次降次<br>分母去和差<br>万能公式：u=tan(x/2) sinx=2u/u^2+1 cosx=(1-u^2)/(1+u^2)</p>
<h2 id="积分表"><a href="#积分表" class="headerlink" title="积分表"></a>积分表</h2><p>大部分积分表同导数表<br>重要积分/导数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>导数</th>
<th>原函数</th>
<th>导数</th>
<th>原函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1/(1+cosx)</td>
<td>tan(x/2)</td>
<td>sin2x</td>
<td>sin^2(x)</td>
</tr>
<tr>
<td>tanx</td>
<td>-In\</td>
<td>cosx\</td>
<td></td>
<td>cotx</td>
<td>In\</td>
<td>sinx\</td>
<td></td>
</tr>
<tr>
<td>secx</td>
<td>In\</td>
<td>secx+tanx\</td>
<td></td>
<td>cscx</td>
<td>In\</td>
<td>csc-cotx\</td>
<td></td>
</tr>
<tr>
<td>sec^2(x)</td>
<td>tanx</td>
<td>secx * tanx</td>
<td>sec(x)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三角变换"><a href="#三角变换" class="headerlink" title="三角变换"></a>三角变换</h2><p>cos2x = cos^2(x) - sin^2(x) = 1 -  2sin^2(x)<br>1 + tan^2 = sec^2<br>1 = cos^2 + sin^2<br>1-sinx=(sin2/x - cosx/2)^2<br>(1+sinx)/(1+cosx)=sec^2(x/2) /2 + tan(x/2)此条常用于e^x(f+f’)<br>tan(x/2)=sinx/(1+cosx)<br>1/(a+bcosx)=1/(m+kcos^2(x))此条常用于常数加三件作为分母<br>=sec^2(x)/(msec^2(x)+k)=dtanx/(mtanx+m+k)<br>积化和差，和差化积</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>中值定理、一元函数微分学应用</title>
    <url>/2022/03/20/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E3%80%81%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="中值定理、一元函数微分学应用"><a href="#中值定理、一元函数微分学应用" class="headerlink" title="中值定理、一元函数微分学应用"></a>中值定理、一元函数微分学应用</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>闭区间连续，开区间可导的函数满足以下性质</p>
<p>费马引理：<br>任意x属于u(x0)，满足f(x0)&gt;=f(x)，有f’(x0)=0</p>
<p>罗尔定理(根据费马引理+介值定理可得)：<br>f(a)=f(b)，有f’(x0)=0，其中x0属于(a,b)</p>
<p>拉格朗日中值定理(根据罗尔定理+辅助函数旋转坐标轴可得)：<br>f(b)-f(a)=f’(x0)*(b-a)，其中x0属于(a,b)</p>
<p>柯西中值定理(证明类似拉格朗日中值定理)：<br>(f(b)-f(a))/(g(b)-g(a))=f’(x0)/g’(x0)，其中x0属于(a,b)</p>
<h2 id="洛必达"><a href="#洛必达" class="headerlink" title="洛必达"></a>洛必达</h2><p>源于柯西中值定理<br>0/0 或 ∞/∞ 型分式 有f(x)/F(x)=f’(x)/F’(x)<br>得出结果必须存在或∞或0/0 或 ∞/∞</p>
<h2 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h2><p>f(x)=∑( fn(x0) <em> (x-x0)^n/n! )<br>x0=0时为麦克劳伦公式，此时σ可写为θx，其中θ属于(0,1)<br>余项：<br>拉格朗日型 fn+1(σ) </em> (x-x0)^(n+1)/(n+1)!<br>佩亚诺型 o(x^n)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>单调性(一阶导数)(驻点,极值点)，凹凸性(二阶导数)</p>
<p>曲率k = y’’/(1+y’)^(3/2) 曲率半径ρ = 1/k</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>对于已给定的极限，且为0/0型，有隐形条件 G(f(x))=0</p>
<p>对于已给定的极限，分式并且极限有正负，可根据保号性推断G(f(x))的正负</p>
<p>对于复合函数的差，外层函数相同，内层可差，可用拉格朗日</p>
<p>对于σ 等式的证明，可通过构造导数形式来证明</p>
<p>对于渐进线的求法，斜求limy/x=k和lim(y-kx)=b，垂找无穷间断点，平找x-&gt;∞</p>
<p>求极限时用到麦克劳伦展开，如(√(1+x) + √(1-x) - 2)/x^2<br>展开到o(x^2)即可</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>写博客简易快捷桌面脚本</title>
    <url>/2022/03/14/%E5%86%99%E5%8D%9A%E5%AE%A2%E5%BF%AB%E6%8D%B7%E6%A1%8C%E9%9D%A2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="写博客简易快捷桌面脚本"><a href="#写博客简易快捷桌面脚本" class="headerlink" title="写博客简易快捷桌面脚本"></a>写博客简易快捷桌面脚本</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>新建记事本.txt复制以下代码<br>修改代码中的  你博客所在的位置<br>另存为写博客.bat，编码改为ansi</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:_begin</span><br><span class="line">cls</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> 创建博客 输入0后回车</span><br><span class="line"><span class="built_in">echo</span> 打开博客 输入1后回车</span><br><span class="line"><span class="built_in">echo</span> 进入hexo模式 输入2后回车</span><br><span class="line"><span class="built_in">echo</span> 退出cmd 输入其他任意键后回车</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /p Info=</span><br><span class="line"><span class="keyword">if</span> %Info%==0 (</span><br><span class="line">goto _set</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> %Info%==1 (</span><br><span class="line">goto _open</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> %Info%==2 (</span><br><span class="line">goto _other</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">goto _end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:_set</span><br><span class="line"><span class="built_in">echo</span> 请输入新创建博客的名称</span><br><span class="line"><span class="built_in">set</span> /p name=</span><br><span class="line">e:</span><br><span class="line"><span class="built_in">cd</span> 你博客所在的位置</span><br><span class="line"><span class="keyword">if</span> exist %name%.md (</span><br><span class="line">start 你博客所在的位置\<span class="built_in">source</span>\_posts\%name%.md</span><br><span class="line"><span class="built_in">echo</span> %name%  文件已打开</span><br><span class="line">goto _check</span><br><span class="line">) </span><br><span class="line">hexo n <span class="string">&quot;%name%&quot;</span> &amp; rd 你博客所在的位置\<span class="built_in">source</span>\_posts\%name%  &amp; start E:\你博客所在的位置\<span class="built_in">source</span>\_posts\%name%.md &amp; start E:\my_blog_luq\<span class="built_in">source</span>\_posts &amp; cmd</span><br><span class="line"></span><br><span class="line">:_open</span><br><span class="line">e:</span><br><span class="line"><span class="built_in">cd</span> 你博客所在的位置\<span class="built_in">source</span>\_posts</span><br><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"><span class="built_in">dir</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> 请输入要打开博客的名称</span><br><span class="line"><span class="built_in">set</span> /p name=</span><br><span class="line"><span class="keyword">if</span> exist %name%.md (</span><br><span class="line">start 你博客所在的位置\<span class="built_in">source</span>\_posts\%name%.md</span><br><span class="line"><span class="built_in">echo</span> %name%  文件已打开</span><br><span class="line">goto _check</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">start 你博客所在的位置\<span class="built_in">source</span>\_posts</span><br><span class="line"><span class="built_in">echo</span> %name%  不存在，已打开文件夹</span><br><span class="line">goto _check</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:_check</span><br><span class="line"><span class="built_in">echo</span> 继续创建打开文件 输入0后回车</span><br><span class="line"><span class="built_in">echo</span> 进入hexo模式 输入1后回车</span><br><span class="line"><span class="built_in">echo</span> 退出cmd 输入其他任意键后回车</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /p a=</span><br><span class="line"><span class="keyword">if</span> %a%==0 (</span><br><span class="line">goto _begin</span><br><span class="line"><span class="keyword">if</span> %a%==1 (</span><br><span class="line">goto _other</span><br><span class="line"><span class="keyword">else</span> (</span><br><span class="line">goto _end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:_end</span><br><span class="line"><span class="keyword">else</span>(<span class="built_in">exit</span>)</span><br><span class="line">:_other</span><br><span class="line">cls</span><br><span class="line">e:</span><br><span class="line"><span class="built_in">cd</span> 你博客所在的位置</span><br><span class="line">cmd /k</span><br><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="修改图标并隐藏"><a href="#修改图标并隐藏" class="headerlink" title="修改图标并隐藏"></a>修改图标并隐藏</h2><p>右键.bat文件，创建快捷方式</p>
<p>右键.bat文件，打开属性</p>
<p>在常规中，勾选隐藏</p>
<p>右键单击快捷方式图标，打开属性</p>
<p>点击常规，修改为你想要的名字(重命名，这里可以不要后缀)</p>
<p>点击快捷方式，点击更改图标，修改为你想要的图标</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>函数、极限、连续</title>
    <url>/2022/03/14/%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/</url>
    <content><![CDATA[<h1 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="求极限技巧"><a href="#求极限技巧" class="headerlink" title="求极限技巧"></a>求极限技巧</h2><p>构造→无穷小替换→洛必达或重要极限(回绕使用)</p>
<h3 id="极限运算："><a href="#极限运算：" class="headerlink" title="极限运算："></a>极限运算：</h3><p>四则运算，幂运算可出入lim极限<br>注意，出入后的两个lim均存在，除法分母不低于0</p>
<h3 id="准则："><a href="#准则：" class="headerlink" title="准则："></a>准则：</h3><p>夹逼<br>f1 &lt; f2 &lt; f3<br>lim f1 = lim f3 = A<br>则有 lim f2  A</p>
<p>数列<br>单调，有界<br>则一定有极限</p>
<h3 id="构造技巧"><a href="#构造技巧" class="headerlink" title="构造技巧"></a>构造技巧</h3><p>1、和差化为分式，因式<br>2、x→∞化为x→0<br>3、x^y=e^(ylnx)<br>4、根号和差利用平方差<br>5、对于幂指函数，±1构造重要极限</p>
<h3 id="α为无穷小，有以下性质："><a href="#α为无穷小，有以下性质：" class="headerlink" title="α为无穷小，有以下性质："></a>α为无穷小，有以下性质：</h3><p>n <em> α = α<br>有界函数 </em> α = α<br>α ^ n = α</p>
<h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><p>精度最高</p>
<h3 id="无穷小替换"><a href="#无穷小替换" class="headerlink" title="无穷小替换"></a>无穷小替换</h3><p>条件：因式<br>精度中等<br>x ~ sinx ~ tanx ~ arcsinx ~ arctanx ~ e^x-1 ~ ln(x+1) ~ (a^x-1)/ln(a) ~ loga(x+1)ln(a) ~ ln(x+(x^2+1)^1/2) ~ x/(1+x)</p>
<h3 id="洛必达"><a href="#洛必达" class="headerlink" title="洛必达"></a>洛必达</h3><p>条件：分式，上下可导 或 0/0 或 ∞/∞<br>精度低</p>
<h3 id="重要极限-x→0"><a href="#重要极限-x→0" class="headerlink" title="重要极限(x→0)"></a>重要极限(x→0)</h3><p>(1+x)^(1/x)=e<br>sinx/x=1<br>(1-cosx)/x^2=1/2<br>(x-sinx)/x^3=1/6<br>(sec^2-1)/x^2=1</p>
<h2 id="连续、间断"><a href="#连续、间断" class="headerlink" title="连续、间断"></a>连续、间断</h2><p>定义一：存在dx则dy存在<br>定义二：f(x-)=f(x)=f(x+)即极限=函数值<br>(基本)初等函数在D中连续，四则，符合，反函数仍在D连续</p>
<p>第一类间断点：跳跃，可取<br>第二类间断点：无穷，震荡</p>
<p>零点定理 =&gt;  界值定理<br>一直连续性|f(x1)-f(x2)| &lt; σ</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>有界性，单调性，周期性，奇偶性</p>
<h2 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h2><p>唯一性，(局部)有界，(局部)保号性</p>
<p>保号性：极限保函数正负号(不带等号，反过来要等号)</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>向量代数与空间解析几何</title>
    <url>/2022/05/13/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h1 id="向量代数与空间解析几何"><a href="#向量代数与空间解析几何" class="headerlink" title="向量代数与空间解析几何"></a>向量代数与空间解析几何</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="方向角"><a href="#方向角" class="headerlink" title="方向角"></a>方向角</h3><p>cosA=x/|<strong>r</strong>|   cosB=y/|<strong>r</strong>|   cosC=z/|<strong>r</strong>|<br>cos^2(A)+cos^2(B)+cos^2(C)=1<br>{cosA，cosB，cosC}=<strong>r</strong>/|<strong>r</strong>|</p>
<h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><script type="math/tex; mode=display">
a·b = |a||b|cos<a,b> = a_xb_x+a_yb_y+a_zb_z = a*(b在a上的投影)</script><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><script type="math/tex; mode=display">
|a × b| = |a||b|sin<a,b>=\left|
\begin{array}{cccc} 
i&j&k \\ 
a_x&a_y&a_z\\ 
b_x&b_y&b_z
\end{array}
\right|=
a和b形成的平行四边形面积</script><p> 方向为右手食指由a绕向b时拇指方向 </p>
<h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3><script type="math/tex; mode=display">
[abc]=a×b·c=\left|\begin{array}{cccc} 
c_x&c_y&c_z\\ 
a_x&a_y&a_z\\ 
b_x&b_y&b_z
\end{array}
\right|=
a,b和c形成的平行六面体体积</script><h2 id="空间平面方程"><a href="#空间平面方程" class="headerlink" title="空间平面方程"></a>空间平面方程</h2><p>点法式：A(x-x0)+B(y-y0)+C(z-z0)=0，其中(x0,y0,z0)为面上一点，(A,B,C)为法线<br>利用叉乘可以求法线</p>
<p>截距式：x/a+y/b+z/c=1，其中a,b,c为面在x,y,z轴上的截距</p>
<p>一般式：由点法式化简括号得</p>
<h2 id="空间直线方程"><a href="#空间直线方程" class="headerlink" title="空间直线方程"></a>空间直线方程</h2><p>点向(对称)式：(x-x0)/m=(y-y0)/n=(z-z0)/p，其中(x0,y0,z0)为线上一点，(m,n,p)为与直线平行的方向向量</p>
<p>参数式：由点向式得 x=mt+x0 y=nt+y0 z=pt+z0</p>
<p>一般式：两个平面方程的交集<br>通过两个平面的法线叉乘可以的到与直线平行的向量，再通过解方程求出1点，即可转化为点向式</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h3><p>面面角(不大于90°)：cosθ=|n1·n2|/|n1||n2|，其中n1,n2分别为两个平面的法向量</p>
<p>线线角：cosθ=|s1·s2|/|s1||s2|，其中s1,s2分别为两条直线方向向量</p>
<p>线面角(不大于90°)：sin=|s1·n1|/|s1||n1|，其中s1,n1分别为直线方向向量和平面的法向量</p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>两到点：d=√((x2-x1)^2+(y2-y1)^2+(z2-z1)^2)</p>
<p>点到线：参数式设线上一点，求 两点最小值 或者 任一连线向量·方向向量 得到垂足点，求点到点距离即可(同下一条) </p>
<p>点到面：d=|M1M2 · n|/|n|，其中M1M2为点到面上的任一向量，n为平面的法向量</p>
<p>线到面：同点到面</p>
<p>面到面：同点到面，d=|D1-D2|/|n|，其中D1,D2为两个平面的方程同系数时的常数项(由方程带入n相减得) ，n为平面的法向量 </p>
<p>线到线：s1×s2·M1M2≠0异面，其中s1,s2分别为两条直线方向向量，M1M2为两直线上点形成的任一向量<br>做平行线使两直线在同一平面，取原直线一点，求点到面距离即可</p>
<h3 id="线面投影、平面束"><a href="#线面投影、平面束" class="headerlink" title="线面投影、平面束"></a>线面投影、平面束</h3><p>平面束(过L的所有平面)=面1+λ面2 </p>
<p>线面投影=过L与面垂直的面相交形成的交线<br>平面束法向量 · 面法向量 = 0 求得垂直面</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>定积分及应用</title>
    <url>/2022/04/14/%E5%AE%9A%E7%A7%AF%E5%88%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="定积分及应用"><a href="#定积分及应用" class="headerlink" title="定积分及应用"></a>定积分及应用</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>f(x)，积分限，x轴围成面积的代数和</p>
<script type="math/tex; mode=display">
S=\int_{b}^{a} f(x)dx
\\
\lim_{n\rightarrow+\infty} \sum_{n=i}^{n}f(ε)dx_i=
\int_{ε_i}^{ε_n}f(x)dx
\\
\lim_{n\rightarrow+\infty}\frac{1}{n}\sum_{n=i}^{n}f(\frac{i}{n})dx=
\int_{1}^{0}f(x)dx</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>连续 或 有界+有限个间断点  =&gt; 可积</p>
<p>例子：1/x不可积</p>
<script type="math/tex; mode=display">
\int_{a}^{b}f(x)dx=-\int_{b}^{a}f(x)dx => \int_{a}^{a}f(x)dx=0
\\
\int_{a}^{c}f(x)dx+\int_{c}^{b}f(x)dx=\int_{a}^{b}f(x)dx
\\
f(x)≤g(x) => \int_{a}^{b}f(x)dx≤\int_{a}^{b}g(x)dx
\\
f(x)_{min}(b-a)≤\int_{a}^{b}f(x)dx≤f(x)_{max}(b-a)
\\
\int_{-a}^{a}f(x)_奇dx=0  
\\
\int_{-a}^{a}f(x)_偶dx=2\int_{0}^{a}f(x)_偶dx</script><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>先分区间去绝对值<br>根据性质化简后计算同不定积分</p>
<h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><script type="math/tex; mode=display">
牛莱公式\\
\int_{a}^{b}f'(x)dx=[f(x)]_{a}^{b}\\
积分中值\\
\int_{a}^{b}f'(x)dx=f'(σ)(b-a) \, \; \space ~ 其中a≤σ≤b\\
华里士(火花)公式\\
\int_{0}^{\pi}xf(x)dx=\frac{\pi}{2}\int_{0}^{\pi}f(x)dx\\
I_n=\int_{0}^{\frac{\pi}{2}}sin^nxdx=\int_{0}^{\frac{\pi}{2}}cos^nxdx=\frac{n-1}{n}I_{n-2}\\
I_0=\frac{\pi}{2},I_1=1\\
I_偶=\frac{n-1}{n}*\frac{n-3}{n-2}……\frac{1}{2}*\frac{\pi}{2}\\
I_奇=\frac{n-1}{n}*\frac{n-3}{n-2}……\frac{2}{3}*1\\
区间再现公式\\
\int_{a}^{b}f(x)dx=\int_{a}^{b}f(a+b-x)dx\\
积分区间为(0,1)可以尝试x=\frac{1-t}{1+t}换元\\</script><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><script type="math/tex; mode=display">
分部积分
\\
\int_{a}^{b}udv=uv|_{a}^{b}-\int_{a}^{b}vdu</script><script type="math/tex; mode=display">
三角还原的隐形条件
\\
\int_{a}^{b}\sqrt{1-x^2}dx=\int_{a}^{b}cosxdsinx=\int_{a}^{b}sinxdcosx</script><h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><h3 id="广义积分"><a href="#广义积分" class="headerlink" title="广义积分"></a>广义积分</h3><p>区间无限，例</p>
<script type="math/tex; mode=display">
\lim_{b\rightarrow+\infty}\int_{a}^{b}f(x)dx</script><h4 id="Γ函数"><a href="#Γ函数" class="headerlink" title="Γ函数"></a>Γ函数</h4><script type="math/tex; mode=display">
Γ(α)=\int_{0}^{+\infty}x^{α-1}e^{-x}dx\\
Γ(α+1)=αΓ(α)\\
Γ(α)=α!\\
Γ(\frac{1}{2})=\sqrt{\pi}\\</script><h3 id="瑕积分"><a href="#瑕积分" class="headerlink" title="瑕积分"></a>瑕积分</h3><p>存在瑕点(无穷间断点)，例</p>
<script type="math/tex; mode=display">
\lim_{b\rightarrow t^-}\int_{a}^{b}f(x)dx\\其中t为瑕点即f(t)\rightarrow\infty</script><h3 id="审敛"><a href="#审敛" class="headerlink" title="审敛"></a>审敛</h3><h4 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h4><p>结果为无穷则发散，拆分积分限时，有一个发散则一定发散</p>
<h4 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h4><p>原理：放缩后可积则原来一定可积</p>
<h4 id="极限法"><a href="#极限法" class="headerlink" title="极限法"></a>极限法</h4><script type="math/tex; mode=display">
a>0\\
\int_{a}^{b}\frac{dx}{(x-a)^q}\,\,q<1收敛，q≥1发散\\
\int_{a}^{+\infty}\frac{dx}{x^q}\,\,q>1收敛，q≤1发散\\
\int_{0}^{\infty}\frac{dx}{xIn^qx}\,\,q>1收敛，q≤1发散\\</script><p>判断时利用同阶代换</p>
<p>0越高阶越收敛，∞越低阶越收敛</p>
<p>e^x最高阶，(Inx)^q最低阶</p>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>e^x出现均由其绝对</p>
<p>当In单独出现或者和x相乘出现时才起作用</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>微元法：找到每dx占的一小份，求出通式后积分</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>多元函数微分学</title>
    <url>/2022/05/22/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="极限、连续"><a href="#极限、连续" class="headerlink" title="极限、连续"></a>极限、连续</h2><p>平面邻域<br>u(M0,σ)={(x,y)|√((x-x0)^2+(y-y0)^2)&lt;σ}</p>
<p>极限定义<br>limx→0,y→0f(x,y)<br>注意：<br>各个方向都存在且相等时才存在极限   用于证明不存在<br>要同时取极限   求极限存在<br>使用夹逼定理   证明极限存在并求取</p>
<p>极限等于函数值时，该点连续</p>
<h2 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h2><p>将多元函数的其他元当作常数，对相关元求导</p>
<p>记作fx(x0,y0)=∂f/∂x|(x0,y0)=limx→x0 (f(x,y0)-f(x0,y0))/(x-x0)<br>分段函数分界点用定义求</p>
<p>高阶同理，对fx(x0,y0)再次求偏导，记作fxx(x0,y0)=∂^2f/∂x^2|(x0,y0)</p>
<p>连续不一定可偏导(同一元的原理)，可偏导不一定连续(此时只有两个方向连续)</p>
<h2 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h2><p>定义<br>dz=Adx+Bdy+o(ρ)=f(x,y)-f(x0,y0) 即连续且可偏导则可微<br>其中ρ=√((dx)^2+(dy)^2)为变化半径，A为fx，B为fy</p>
<p>(dz-Adx-Bdy)/ρ=o(ρ)/ρ=0  通过定义(即该式可以证明可微)<br>该式成立可以获取A和B</p>
<p>可微一定连续(极限等于函数值)<br>可微一定可偏导(A,B存在)<br>可微存在切平面</p>
<h2 id="多元复合函数求-偏-导"><a href="#多元复合函数求-偏-导" class="headerlink" title="多元复合函数求(偏)导"></a>多元复合函数求(偏)导</h2><p>关键在于从全微分入手<br>dz/dt=f’1<em> u’ +f’2 </em> v’</p>
<p>二阶<br>d^2 z/dt^2=f’1<em> u’’ +f’2 </em> v’’  +u’(f’11<em> u’ +f’’12 </em> v’) +v’(f’’12<em> u’ +f’’22 </em> v’)</p>
<h6 id="对于u-v与t-q有关"><a href="#对于u-v与t-q有关" class="headerlink" title="对于u,v与t,q有关"></a>对于u,v与t,q有关</h6><p>关键在于需求导函数的变量与给定的元是否存在关系<br>只有1个存在关系即求偏导，多个存在关系则是全导</p>
<h6 id="对于逆运算"><a href="#对于逆运算" class="headerlink" title="对于逆运算"></a>对于逆运算</h6><p>原函数要加上无关元的函数，如y的偏导的原函数要加上g(x)</p>
<h6 id="对于换元"><a href="#对于换元" class="headerlink" title="对于换元"></a>对于换元</h6><p>直接替换普通变量</p>
<p>再将给定条件求偏导再去替换</p>
<h2 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h2><h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>F=0<br>dy/dx=-Fx/Fy<br>注意Fy≠0</p>
<h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><p>等式两边同时求导，然后把需要的导数提出了即可</p>
<h3 id="全微分形式不变性"><a href="#全微分形式不变性" class="headerlink" title="全微分形式不变性"></a>全微分形式不变性</h3><p>dz=((∂z∂u)/(∂u∂x)+(∂z∂v)/(∂v∂x))dx+((∂z∂u)/(∂u∂y)+(∂z∂v)/(∂v∂y))dy=(∂zdu)/∂u+(∂zdv)/∂v</p>
<h2 id="方向导数、梯度"><a href="#方向导数、梯度" class="headerlink" title="方向导数、梯度"></a>方向导数、梯度</h2><p>对于任意变化方向的偏导数<br>记为∂f/∂l|(x0,y0)=limt→0 (f(x0,y0)-f(x0+tcosa,y0+tcosb))/t=fxcsoa+fycosb )= (fx,fy,yz) · (cosa,cosb,cosc)= |▽f(x,y,z)|cosθ</p>
<p>其中<br>a为l与x轴夹角，b为l与y轴夹角<br>方向向量(cosa,cosb,cosc)<br>其中θ为切线向量方向和梯度方向的夹角</p>
<p>(fx,fy,yz)称为梯度<br>可记为gradf(x,y,z)=▽f(x,y,z)<br>▽=∂/∂x +∂/∂y +∂/∂z</p>
<p>梯度在几何意义上相当于等高线<br>方向导数最大值=梯度</p>
<h2 id="极值、最值"><a href="#极值、最值" class="headerlink" title="极值、最值"></a>极值、最值</h2><h6 id="无条件极值流程"><a href="#无条件极值流程" class="headerlink" title="无条件极值流程"></a>无条件极值流程</h6><p>fx=0,fy=0<br>求出点驻点<br>fxx=A,fyy=C,fxy=fyx=B<br>求出拐点<br>B^2-AC<0极值存在
A>0极小值，A&lt;0极大值</p>
<p>存在时，将点带回原函数求取即可</p>
<h6 id="有条件极值流程"><a href="#有条件极值流程" class="headerlink" title="有条件极值流程"></a>有条件极值流程</h6><p>拉格朗日数乘法(原理自证)<br>令L=f(x,y)+λ*D(x,y)<br>求Lx=0,Ly=0,D(x,y)=0</p>
<p>求出各个λ对应的点</p>
<p>带入即可</p>
<p>法2：条件改为三角带回即可</p>
<h6 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h6><p>求最值分为范围内的无条件极值和边界上的有条件极值流程<br>选取最大和最小的即可</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微分方程</title>
    <url>/2022/04/29/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<p>方程最高阶=方程的阶=通解中任意常数的个数</p>
<p>y(n)+P(x)y(n-1)……Q(x)y(1)=f(x)<br>f(x)=0为齐次</p>
<p><strong>解的结构为：齐次通解 + 特解</strong></p>
<h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><h3 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h3><p>分离x和y在等式两边，然后两边同时积分，称分离变量</p>
<p>分式不能直接分离时，分式同除x，构造u=y/x，得y’=u’x+u再分离变量</p>
<h3 id="非齐次"><a href="#非齐次" class="headerlink" title="非齐次"></a>非齐次</h3><h4 id="分式有常数不可以同除"><a href="#分式有常数不可以同除" class="headerlink" title="分式有常数不可以同除"></a>分式有常数不可以同除</h4><p>发现x和y在分子和分母系数成比例，则改为设u=ax+by，此时y’=(du/dx - a)/b=(u+c)/(ku+d)直接解得<br>否则构造X=x+c，Y=y+d变为求齐次分式</p>
<h4 id="标准结构y’-Qy-P"><a href="#标准结构y’-Qy-P" class="headerlink" title="标准结构y’+Qy=P"></a>标准结构y’+Qy=P</h4><p>常数变异法，换为x的函数u，带回求得u<br>y=ce^(-∫Pdx)+e^(-∫Pdx)*∫Qe^(∫Pdx)dx<br>解的性质：有y1,y2为特解，y1-y2则为齐次通解，(y1+y2)/2为通解</p>
<h4 id="伯努利"><a href="#伯努利" class="headerlink" title="伯努利"></a>伯努利</h4><p>y’+py=qy^n =&gt; y‘y^(-n)+py^(1-n)=q =&gt; z’+pz=q 其中z=y^(1-n)</p>
<h2 id="二阶微分方程"><a href="#二阶微分方程" class="headerlink" title="二阶微分方程"></a>二阶微分方程</h2><h3 id="可降阶"><a href="#可降阶" class="headerlink" title="可降阶"></a>可降阶</h3><h4 id="y’’-f-x"><a href="#y’’-f-x" class="headerlink" title="y’’=f(x)"></a>y’’=f(x)</h4><p>积分降阶</p>
<h4 id="y’’-f-x-y’"><a href="#y’’-f-x-y’" class="headerlink" title="y’’=f(x,y’)"></a>y’’=f(x,y’)</h4><p>设p=y’，y’’=p’=f(x,p’)，变为一阶</p>
<h4 id="y’’-f-y-y’"><a href="#y’’-f-y-y’" class="headerlink" title="y’’=f(y,y’)"></a>y’’=f(y,y’)</h4><p>设p=y’，y’’=p*dp/dy=f(y,p’)，变为一阶</p>
<h3 id="标准结构y’’-py‘-qy-F"><a href="#标准结构y’’-py‘-qy-F" class="headerlink" title="标准结构y’’+py‘+qy=F"></a>标准结构y’’+py‘+qy=F</h3><h4 id="齐次且p-q为常数"><a href="#齐次且p-q为常数" class="headerlink" title="齐次且p,q为常数"></a>齐次且p,q为常数</h4><p>设y=e^(rx)，得r^2+pr+q=0<br>求得r1≠r2，y=C1e^(r1x)+C2e^(r2x)<br>求得r1=r2，y=C1e^(r1x)+C2xe^(r2x)<br>求得r=a±bi，y=e^(ax)(C1sinbx+C2cosbx)</p>
<h4 id="非齐次且p-q为常数且F-Re-kx"><a href="#非齐次且p-q为常数且F-Re-kx" class="headerlink" title="非齐次且p,q为常数且F=Re^(kx)"></a>非齐次且p,q为常数且F=Re^(kx)</h4><p>R 为 多项式 或 多项式sinbx+多项式cosbx</p>
<p>求出齐次方程r</p>
<p>令 y特解=F=Re^kx ，此时R的常系数变异，换为变系数，若k=r1则R需乘上x，若k=r1=r2则R需乘上x^2<br>即y*=x^n Re^(kx)</p>
<p>将F=y*带入原式求得变量即求得y特解，特解加上通解则为通解</p>
<h2 id="叠加原理"><a href="#叠加原理" class="headerlink" title="叠加原理"></a>叠加原理</h2><p>对于非齐次F=f1+f2<br>可以使原式分别等于f1,f2求出特解y1,y2<br>y1+y2则为原式的特解</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>再求原函数y=f(x)时求的是特解，要找f(x)隐藏的初始条件</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>新年快乐</title>
    <url>/2022/02/05/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<h1 id="blog搭建完成"><a href="#blog搭建完成" class="headerlink" title="blog搭建完成"></a>blog搭建完成</h1>]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>曲线和曲面积分</title>
    <url>/2022/06/12/%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="曲线和曲面积分"><a href="#曲线和曲面积分" class="headerlink" title="曲线和曲面积分"></a>曲线和曲面积分</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="第一类曲线积分-对弧长"><a href="#第一类曲线积分-对弧长" class="headerlink" title="第一类曲线积分(对弧长)"></a>第一类曲线积分(对弧长)</h2><p>背景：求弧长质量<br>不具方向性，下限一定小于上限</p>
<script type="math/tex; mode=display">
\int_Lf(x,y)dl=\int_a^bf(x,y(x))\sqrt{1+y'^2}dx=\int_α^βf(x(t),y(t))\sqrt{x'(t)^2+y'(t)^2)}dt</script><h2 id="第二类曲线积分-对坐标"><a href="#第二类曲线积分-对坐标" class="headerlink" title="第二类曲线积分(对坐标)"></a>第二类曲线积分(对坐标)</h2><p>背景：求做功<br>具有方向性</p>
<script type="math/tex; mode=display">
\int_L\vec{f}(x,y)d\vec{l}=\int_a^b(P(x,y(x))+Q(x,y(x))y'(x))dx=\int_α^β(P(x(t),y(t))x'(t)+Q(x(t),y(t))y'(t))dt</script><h2 id="两类曲线的联系"><a href="#两类曲线的联系" class="headerlink" title="两类曲线的联系"></a>两类曲线的联系</h2><p>根据线与其在坐标轴上的投影形成的方向角</p>
<script type="math/tex; mode=display">
\int_L(P(x,y(x))dx+Q(x,y(x))dy)=\int_L(Pcosα+Qcosβ)dl</script><h2 id="第一类曲面积分-对面积"><a href="#第一类曲面积分-对面积" class="headerlink" title="第一类曲面积分(对面积)"></a>第一类曲面积分(对面积)</h2><p>背景：求曲面质量</p>
<script type="math/tex; mode=display">
\iint_Df(x,y,z)ds=\iint_Df(x,y,z(x,y))\sqrt{1+z_x^2+z_y^2}dxdy</script><h2 id="第二类曲面积分"><a href="#第二类曲面积分" class="headerlink" title="第二类曲面积分"></a>第二类曲面积分</h2><p>背景：求流量</p>
<script type="math/tex; mode=display">
\iint_\sum v(x,y,z)ds=\iint_{D_{xy}} (P(x,y,z(x,y))dydz+Q(x,y,z(x,y))dxdz+R(x,y,z(x,y))dxdy)</script><h2 id="两类曲面的联系"><a href="#两类曲面的联系" class="headerlink" title="两类曲面的联系"></a>两类曲面的联系</h2><p>任一曲面均为z=z’x<em>x+z’y</em>y+c，所以有正向法向量为(-z’x,-z’y,1)，所以可以求得法向量得方向余弦<br>曲面乘以法向量方向余弦x得曲面在对应坐标面yoz上的投影</p>
<script type="math/tex; mode=display">
\iint_{D_{xy}} (P(x,y,z(x,y))dydz+Q(x,y,z(x,y))dxdz+R(x,y,z(x,y))dxdy)
=\iint_\sum (P(x,y,z(x,y))cosα+Q(x,y,z(x,y))cosβ+R(x,y,z(x,y))cosσ)ds\\
=\iint_{D_{xy}} (-z_xP(z,y,z(x,y))-z_yQ(z,y,z(x,y))+R(z,y,z(x,y)))/\sqrt{1+z_x^2+z_y^2}*ds\\</script><h2 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h2><p>用于：解决第二类曲线积分<br>要求：封闭，正向(D在l左侧)，P,Q可连续偏导<br>原理：D内部分成多个无限小的D1，分别求出再求和</p>
<script type="math/tex; mode=display">
\oint_L(P(x,y(x))dx+Q(x,y(x))dy)=\iint_D(∂Q/∂x-∂P/∂y)dxdy</script><p>挖洞问题(对于D内有奇点)：l为被挖掉的区域边界<br>补线问题(对于不封闭l)：l为补上的线段</p>
<script type="math/tex; mode=display">
I=\oint_{L+l}\vec{f}(x,y)d\vec{l}-\oint_l\vec{f}(x,y)d\vec{l}</script><p>特性：<br>对于封闭D，第二类曲线积分为0<br>即做功与过程无关，与起点和终点有关<br>f相当于D内某一点的全微分<br>D内任意一点都存在∂Q/∂x=∂P/∂y</p>
<h2 id="高斯公式"><a href="#高斯公式" class="headerlink" title="高斯公式"></a>高斯公式</h2><p>用于：解决第二类曲面积分<br>要求：封闭，从内向外，P,Q,R可连续偏导</p>
<script type="math/tex; mode=display">
\iint_\sum (P(x,y,z(x,y))dydz+Q(x,y,z(x,y))dxdz+R(x ,y,z(x,y))dxdy)=\iiint_Ω(∂P/∂x+∂Q/∂y+∂P/∂z)dxdydz</script>]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>级数</title>
    <url>/2022/06/24/%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="通用性质"><a href="#通用性质" class="headerlink" title="通用性质"></a>通用性质</h2><p>级数<strong>绝对收敛</strong>，则原级数一定收敛</p>
<p>级数的绝对值发散时，由比值或根植法证得的，原级数才发散</p>
<p>改变有限项不改变级数敛散性</p>
<h2 id="常数项级数"><a href="#常数项级数" class="headerlink" title="常数项级数"></a>常数项级数</h2><script type="math/tex; mode=display">
一般形式\sum_{n=1}^{\infty}u_n\\
等比(几何)级数\sum_{n=1}^{\infty}aq^n\\
p级数\sum_{n=1}^{\infty}1/n^p\\
调和级数\sum_{n=1}^{\infty}1/n\\
交错级数\sum_{n=1}^{\infty}(-1)^{n+c}Un</script><p>Sn趋向于S(级数收敛)<br>    =&gt;Un趋向于0<br>    =&gt;加括号仍然收敛  </p>
<p>|q|&lt;1,<strong>等比级数</strong>收敛于a/(1-q)</p>
<p>p&gt;1,<strong>p级数收敛</strong></p>
<p>p=1的p级数即为<strong>调和级数</strong></p>
<p>任意n满足U_(n+1)≤U_n且n趋向无穷时Un等于0则<strong>交错级数</strong>收敛且S≤U1</p>
<h2 id="正项级数审敛"><a href="#正项级数审敛" class="headerlink" title="正项级数审敛"></a>正项级数审敛</h2><p>级数收敛 &lt;=&gt; Sn有界</p>
<p>比较法1：Vn≤Un，若Un收敛则Vn收敛，若Vn发散则Un发散<br>比较法2：Vn/Un=L，若[0,+∞)中Un收敛则Vn收敛，若(0,+∞)或+∞中Un发散则Vn发散<br>极限法：nUn∈(0,+∞)或+∞则发散，n^pUn∈[0,+∞)则收敛</p>
<p>比值法：U_(n+1)/U_n   <1则收敛   >1则发散<br>根值法：Un^(1/n)   <1则收敛   >1则发散</p>
<h2 id="函数项级数"><a href="#函数项级数" class="headerlink" title="函数项级数"></a>函数项级数</h2><script type="math/tex; mode=display">
一般形式\sum_{n=1}^{\infty}u_n(x)\\
幂级数\sum_{n=0}^{\infty}a_nx^n\\
三角级数a_0/2+\sum_{n=0}^{\infty}（a_ncosn\pi x/l+b_nsinn\pi x/l）</script><p>对于<strong>幂级数</strong>，x0该点收敛时，|x|&lt;|x0|收敛，x0该点发散时，|x0|&lt;|x|发散，0点到收敛的边界点的长度称收敛半径R</p>
<p>根据比值法|a_(n+1) / a_n|=ρ=1/R<br>对于缺项或者(x-x0)可使用还原法或者根据比值法原理求取|x|的范围即R</p>
<p>求Sn时，可以先求导或对0到x积分再求和然后再对0到x积分或求导</p>
<p>对于l=pi即周期为2pi的<strong>三角级数</strong>，根据性质可知</p>
<script type="math/tex; mode=display">
a0=1/\pi\int_{-\pi}^\pi f(x)dx \\
an=1/\pi\int_{-\pi}^\pi f(x)cosnxdx \\
bn=1/\pi\int_{-\pi}^\pi f(x)sinnxdx \\
以上三条称傅里叶系数，带入三角级数后也称傅里叶级数</script><p>对于l=pi即周期为2pi的<strong>三角级数</strong>，在一个周期中第一类间断点和极值点只有有限个，则收敛于(f(+)+f(-))/2<br>对于任意周期为的<strong>三角级数</strong>，设t=pix/l，有F(t)=f(l/pi <em> t)=f(x)=f(x+2pi)=f(l/p </em> (t+2pi))=F(t+2pi)<br>通过周期为2pi的形式求得F(t)，再回代x即可</p>
<p>当求固定范围i的<strong>三角级数</strong>时，周期或者奇偶延拓后求出傅里叶系数，再限制有效范围即可</p>
<h2 id="三角函数系性质"><a href="#三角函数系性质" class="headerlink" title="三角函数系性质"></a>三角函数系性质</h2><p>cosnx,sinnx,cosnxcoskx,sinnxsinkx,sinnxcosnx在（-pi,pi）的积分为0</p>
<p>cos^2(nx),sin^2(nx)在（-pi,pi）的积分不为0</p>
<h2 id="求幂级数展开式"><a href="#求幂级数展开式" class="headerlink" title="求幂级数展开式"></a>求幂级数展开式</h2><p>求f的n次幂<br>写出级数fn(x)x^n/n!<br>证明n趋向于无穷时|Rn|=|fε(x)x^n/n!|趋向于0即可</p>
<p>间接法(代换x)，注意范围</p>
<script type="math/tex; mode=display">
e^x=\sum_{n=0}x^n/n!\space\space\space (-\infty,\infty)\\
In(x+1)=\sum_{n=0}(-1)^nx^{n+1}/(n+1)\space\space\space (-1,1)\\
sinx=\sum_{n=0}(-1)^nx^{2n+1}/(2n+1)!\space\space\space (-\infty,\infty)\\
cosx=\sum_{n=0}(-1)^nx^{2n}/(2n)!\space\space\space (-\infty,\infty)\\
1/(1+x)=\sum_{n=0}(-1)^nx^n\space\space\space (-1,1)\\
1/(1-x)=\sum_{n=0}x^n\space\space\space (-1,1)\\</script>]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>重积分</title>
    <url>/2022/06/01/%E9%87%8D%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="重积分"><a href="#重积分" class="headerlink" title="重积分"></a>重积分</h1><p>注意：只收录方法和简易(重要)定义(用于复习)</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>limλ-&gt;0Σi_n f(x,y)dσ=limn-&gt;∞m-&gt;∞Σi_nΣi_md(1/mn)=∬_D f(x,y)dσ</p>
<p>几何意义为体积代数和</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>∬_ D  f(x,y)dσ=∬_ D f(x,y)dxdy=∫[∫f(x,y)dx]dy<br>本质为两次定积分，所以性质相似<br>如奇偶性，华里士，中值定理等等</p>
<h2 id="二重积分计算"><a href="#二重积分计算" class="headerlink" title="二重积分计算"></a>二重积分计算</h2><p>∫dy∫f(x,y)dx<br>直角坐标系的计算几何意义为求f高度对y或x的积分得面积，然后再求面积对x或y的积分得体积<br>可以画图选择交换积分次序，用简单的算</p>
<p>∫dθ∫f(rcosθ,rsinθ)rdr注意有个r本质是(r+dr)/2，当D或f出现圆或反比例函数<br>极坐标系的计算几何意义为求f高度*r对r的积分得面积，然后再求面积对θ的积分得体积</p>
<p>一般式<br>将x,y换为u(x,y),v(x,y)，变为f*J(u,v)对u,v重积分</p>
<h2 id="三重积分计算"><a href="#三重积分计算" class="headerlink" title="三重积分计算"></a>三重积分计算</h2><p>与二重积分计算类似，先对z积分(穿线法)</p>
<p>∫dy∫dx∫f(x,y)dz<br>利用直角坐标计算<br>∫dθ∫dr∫f(rcosθ,rsinθ,z)dz<br>利用柱面坐标计算<br>以上均为求f(四维)对z(穿线)的积分变为二重积分体积</p>
<p>∫dθ∫dφ∫f(rcosθsinφ,rsinθsinφ,rcosφ)r^2sinφdr<br>利用球面坐标计算</p>
<h2 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h2><p>先看D是否存在对称<br>如果f关于对称时相等则可以积分限除2，原式乘2<br>如果f关于对称时相反则等于0</p>
<p>主观上相当于看二重积分的体积是否存在对称性质</p>
<p>轮换对称<br>x和y的地位相等即调换不变则改为(f(x)+f(y))/2来简化运算</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>曲斜面与坐标面上投影的关系</p>
<p>dxdy/ds =  1/√(1+fx^2+fy^2)     在xoy面上的投影</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
